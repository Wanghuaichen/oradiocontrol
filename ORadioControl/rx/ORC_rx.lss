
ORC_rx.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001566  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          000000c9  00800100  00800100  000015da  2**0
                  ALLOC
  2 .noinit       00000004  008001c9  008001c9  000015da  2**0
                  ALLOC
  3 .stab         00000990  00000000  00000000  000015dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000112  00000000  00000000  00001f6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000218  00000000  00000000  0000207e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000004d3  00000000  00000000  00002296  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001bb4  00000000  00000000  00002769  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a1  00000000  00000000  0000431d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001ef9  00000000  00000000  000048be  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000003d0  00000000  00000000  000067b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000008ee  00000000  00000000  00006b88  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000b24  00000000  00000000  00007476  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000218  00000000  00000000  00007f9a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
    return(false);
}

uint8_t read, write;
void writeTelemetrie(uint16_t sensor, uint16_t value)
{
       0:	43 c0       	rjmp	.+134    	; 0x88 <__ctors_end>

uint8_t get_Data(void)
{
  SPI_MasterTransmit(CC2500_READ_SINGLE | CC2500_RXFIFO);
  return(SPI_MasterTransmit(CC2500_SNOP));
}
       2:	6b c0       	rjmp	.+214    	; 0xda <__vector_1>
       4:	69 c0       	rjmp	.+210    	; 0xd8 <__bad_interrupt>
       6:	68 c0       	rjmp	.+208    	; 0xd8 <__bad_interrupt>
       8:	67 c0       	rjmp	.+206    	; 0xd8 <__bad_interrupt>
       a:	66 c0       	rjmp	.+204    	; 0xd8 <__bad_interrupt>
       c:	65 c0       	rjmp	.+202    	; 0xd8 <__bad_interrupt>
       e:	64 c0       	rjmp	.+200    	; 0xd8 <__bad_interrupt>
      10:	63 c0       	rjmp	.+198    	; 0xd8 <__bad_interrupt>
      12:	62 c0       	rjmp	.+196    	; 0xd8 <__bad_interrupt>
      14:	61 c0       	rjmp	.+194    	; 0xd8 <__bad_interrupt>
      16:	76 c0       	rjmp	.+236    	; 0x104 <__vector_11>
      18:	5f c0       	rjmp	.+190    	; 0xd8 <__bad_interrupt>
      1a:	5e c0       	rjmp	.+188    	; 0xd8 <__bad_interrupt>
      1c:	5d c0       	rjmp	.+186    	; 0xd8 <__bad_interrupt>
      1e:	5c c0       	rjmp	.+184    	; 0xd8 <__bad_interrupt>
      20:	5b c0       	rjmp	.+182    	; 0xd8 <__bad_interrupt>
      22:	5a c0       	rjmp	.+180    	; 0xd8 <__bad_interrupt>
      24:	59 c0       	rjmp	.+178    	; 0xd8 <__bad_interrupt>
      26:	58 c0       	rjmp	.+176    	; 0xd8 <__bad_interrupt>
      28:	57 c0       	rjmp	.+174    	; 0xd8 <__bad_interrupt>
      2a:	56 c0       	rjmp	.+172    	; 0xd8 <__bad_interrupt>
      2c:	55 c0       	rjmp	.+170    	; 0xd8 <__bad_interrupt>
      2e:	54 c0       	rjmp	.+168    	; 0xd8 <__bad_interrupt>
      30:	53 c0       	rjmp	.+166    	; 0xd8 <__bad_interrupt>
      32:	52 c0       	rjmp	.+164    	; 0xd8 <__bad_interrupt>
      34:	25 c3       	rjmp	.+1610   	; 0x680 <getFailSafe+0x42>
      36:	26 c3       	rjmp	.+1612   	; 0x684 <getFailSafe+0x46>
      38:	27 c3       	rjmp	.+1614   	; 0x688 <getFailSafe+0x4a>
      3a:	28 c3       	rjmp	.+1616   	; 0x68c <getFailSafe+0x4e>
      3c:	29 c3       	rjmp	.+1618   	; 0x690 <getFailSafe+0x52>
      3e:	2a c3       	rjmp	.+1620   	; 0x694 <getFailSafe+0x56>
      40:	2b c3       	rjmp	.+1622   	; 0x698 <getFailSafe+0x5a>
      42:	2c c3       	rjmp	.+1624   	; 0x69c <getFailSafe+0x5e>
      44:	83 c4       	rjmp	.+2310   	; 0x94c <checkPulses+0x36>
      46:	84 c4       	rjmp	.+2312   	; 0x950 <checkPulses+0x3a>
      48:	85 c4       	rjmp	.+2314   	; 0x954 <checkPulses+0x3e>
      4a:	86 c4       	rjmp	.+2316   	; 0x958 <checkPulses+0x42>
      4c:	87 c4       	rjmp	.+2318   	; 0x95c <checkPulses+0x46>
      4e:	88 c4       	rjmp	.+2320   	; 0x960 <checkPulses+0x4a>
      50:	89 c4       	rjmp	.+2322   	; 0x964 <checkPulses+0x4e>
      52:	8a c4       	rjmp	.+2324   	; 0x968 <checkPulses+0x52>

00000054 <freq>:
      54:	00 28 d8 78 88 50 b0                                .(.x.P.

0000005b <cc2500InitValue>:
      5b:	29 2e 06 07 d3 91 03 0c 44 00 00 0a 00 5c 6c 4e     ).......D....\lN
      6b:	2d 3b 73 f3 ff 00 07 00 18 1d 1c c7 00 b0 87 6b     -;s............k
      7b:	f8 b6 10 ea 0a 00 11 41 00 59 88 31 0b              .......A.Y.1.

00000088 <__ctors_end>:
      88:	11 24       	eor	r1, r1
      8a:	1f be       	out	0x3f, r1	; 63
      8c:	cf ef       	ldi	r28, 0xFF	; 255
      8e:	d4 e0       	ldi	r29, 0x04	; 4
      90:	de bf       	out	0x3e, r29	; 62
      92:	cd bf       	out	0x3d, r28	; 61

00000094 <get_mcusr>:
void get_mcusr(void) \
  __attribute__((naked)) \
  __attribute__((section(".init3")));
void get_mcusr(void)
{
  wdt_reset();
      94:	a8 95       	wdr
  mcusr_mirror = MCUSR;
      96:	84 b7       	in	r24, 0x34	; 52
      98:	80 93 c9 01 	sts	0x01C9, r24
  MCUSR = 0;
      9c:	14 be       	out	0x34, r1	; 52
  wdt_disable();
      9e:	88 e1       	ldi	r24, 0x18	; 24
      a0:	0f b6       	in	r0, 0x3f	; 63
      a2:	f8 94       	cli
      a4:	80 93 60 00 	sts	0x0060, r24
      a8:	10 92 60 00 	sts	0x0060, r1
      ac:	0f be       	out	0x3f, r0	; 63

000000ae <__do_copy_data>:
      ae:	11 e0       	ldi	r17, 0x01	; 1
      b0:	a0 e0       	ldi	r26, 0x00	; 0
      b2:	b1 e0       	ldi	r27, 0x01	; 1
      b4:	e6 e6       	ldi	r30, 0x66	; 102
      b6:	f5 e1       	ldi	r31, 0x15	; 21
      b8:	02 c0       	rjmp	.+4      	; 0xbe <.do_copy_data_start>

000000ba <.do_copy_data_loop>:
      ba:	05 90       	lpm	r0, Z+
      bc:	0d 92       	st	X+, r0

000000be <.do_copy_data_start>:
      be:	a0 30       	cpi	r26, 0x00	; 0
      c0:	b1 07       	cpc	r27, r17
      c2:	d9 f7       	brne	.-10     	; 0xba <.do_copy_data_loop>

000000c4 <__do_clear_bss>:
      c4:	11 e0       	ldi	r17, 0x01	; 1
      c6:	a0 e0       	ldi	r26, 0x00	; 0
      c8:	b1 e0       	ldi	r27, 0x01	; 1
      ca:	01 c0       	rjmp	.+2      	; 0xce <.do_clear_bss_start>

000000cc <.do_clear_bss_loop>:
      cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
      ce:	a9 3c       	cpi	r26, 0xC9	; 201
      d0:	b1 07       	cpc	r27, r17
      d2:	e1 f7       	brne	.-8      	; 0xcc <.do_clear_bss_loop>
      d4:	1f d8       	rcall	.-4034   	; 0xfffff114 <__eeprom_end+0xff7ef114>
      d6:	45 ca       	rjmp	.-2934   	; 0xfffff562 <__eeprom_end+0xff7ef562>

000000d8 <__bad_interrupt>:
      d8:	93 cf       	rjmp	.-218    	; 0x0 <__vectors>

000000da <__vector_1>:
}

ISR(INT0_vect, ISR_NAKED)          // Heisse Konstruktion!
{
  asm volatile("push    r24");    // immer prüfen ob nur R24 verwendet wird
      da:	8f 93       	push	r24
  state.RxTimer = TCNT2;
      dc:	80 91 b2 00 	lds	r24, 0x00B2
      e0:	80 93 97 01 	sts	0x0197, r24
  sei();                          // Verlust zusätzlich 6 Clocks
      e4:	78 94       	sei
  ReceiverInterrupt = true;
      e6:	81 e0       	ldi	r24, 0x01	; 1
      e8:	80 93 c8 01 	sts	0x01C8, r24
  asm volatile(
      ec:	8f 91       	pop	r24
      ee:	18 95       	reti

000000f0 <warte>:

/**********************************/

void warte(uint8_t t)           // 17
{
  asm volatile(
      f0:	82 50       	subi	r24, 0x02	; 2
      f2:	81 50       	subi	r24, 0x01	; 1
      f4:	29 f0       	breq	.+10     	; 0x100 <warte+0x10>
	...
      fe:	f9 cf       	rjmp	.-14     	; 0xf2 <warte+0x2>
     100:	00 00       	nop
  "nop""\n\t"
  "rjmp    .-14""\n\t"
  "nop":::"r24"
  );
  return;                               // 4
}
     102:	08 95       	ret

00000104 <__vector_11>:

FASTPPM ppm;

ISR(TIMER1_COMPA_vect)                  // pulse generation, resolution 1µs, Interrupt ist aus!
{
     104:	1f 92       	push	r1
     106:	0f 92       	push	r0
     108:	0f b6       	in	r0, 0x3f	; 63
     10a:	0f 92       	push	r0
     10c:	11 24       	eor	r1, r1
     10e:	bf 92       	push	r11
     110:	cf 92       	push	r12
     112:	df 92       	push	r13
     114:	ef 92       	push	r14
     116:	ff 92       	push	r15
     118:	0f 93       	push	r16
     11a:	1f 93       	push	r17
     11c:	2f 93       	push	r18
     11e:	3f 93       	push	r19
     120:	4f 93       	push	r20
     122:	5f 93       	push	r21
     124:	6f 93       	push	r22
     126:	7f 93       	push	r23
     128:	8f 93       	push	r24
     12a:	9f 93       	push	r25
     12c:	af 93       	push	r26
     12e:	bf 93       	push	r27
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	ef 93       	push	r30
     136:	ff 93       	push	r31
  asm volatile(
     138:	90 91 88 00 	lds	r25, 0x0088
     13c:	99 5b       	subi	r25, 0xB9	; 185
     13e:	80 91 84 00 	lds	r24, 0x0084
     142:	89 1b       	sub	r24, r25
     144:	e2 f3       	brmi	.-8      	; 0x13e <__vector_11+0x3a>
     146:	90 91 84 00 	lds	r25, 0x0084
     14a:	80 91 88 00 	lds	r24, 0x0088
     14e:	99 54       	subi	r25, 0x49	; 73
     150:	98 1b       	sub	r25, r24
     152:	89 2f       	mov	r24, r25
     154:	88 7f       	andi	r24, 0xF8	; 248
     156:	41 f4       	brne	.+16     	; 0x168 <L_72+0x6>
     158:	e1 eb       	ldi	r30, 0xB1	; 177
     15a:	f0 e0       	ldi	r31, 0x00	; 0
     15c:	e9 0f       	add	r30, r25
     15e:	f1 1d       	adc	r31, r1
     160:	09 94       	ijmp

00000162 <L_72>:
	...
     16e:	00 00       	nop
  "nop""\n\t"
  "nop""\n\t"
  "nop""\n\t"
  "nop":::"r24","r25","r30","r31");

  uint8_t c = TCNT1L; //- OCR1AL;          // 0x55
     170:	b0 90 84 00 	lds	r11, 0x0084

  uint8_t *p = &ppm.toggleC[output.idx];
     174:	80 91 8f 01 	lds	r24, 0x018F
     178:	c8 2f       	mov	r28, r24
     17a:	d0 e0       	ldi	r29, 0x00	; 0
     17c:	ce 54       	subi	r28, 0x4E	; 78
     17e:	de 4f       	sbci	r29, 0xFE	; 254
  uint8_t c1,d1,c2,d2,c3,d3,c4,d4;
  c1 = *p;
     180:	98 81       	ld	r25, Y
  c2 = *(p + 1);                        // Hier wird auch eventuell Müll gelesen
     182:	09 81       	ldd	r16, Y+1	; 0x01
  c3 = *(p + 2);                        // macht aber nichts
     184:	ea 80       	ldd	r14, Y+2	; 0x02
  c4 = *(p + 3);                        // Wichtig ist der immer gleiche Ablauf
     186:	cb 80       	ldd	r12, Y+3	; 0x03
  d1 = *(p + 4);
     188:	8c 81       	ldd	r24, Y+4	; 0x04
  d2 = *(p + 5);
     18a:	1d 81       	ldd	r17, Y+5	; 0x05
  d3 = *(p + 6);
     18c:	fe 80       	ldd	r15, Y+6	; 0x06
  d4 = *(p + 7);
     18e:	df 80       	ldd	r13, Y+7	; 0x07

  while(1)
  {
    PIND = d1;
     190:	89 b9       	out	0x09, r24	; 9
    PINC = c1;
     192:	96 b9       	out	0x06, r25	; 6
    uint8_t dif = *(p + 8);
     194:	88 85       	ldd	r24, Y+8	; 0x08
    if(dif != 1)
     196:	81 30       	cpi	r24, 0x01	; 1
     198:	49 f0       	breq	.+18     	; 0x1ac <L_72+0x4a>
    {
      if(!dif)
     19a:	88 23       	and	r24, r24
     19c:	41 f1       	breq	.+80     	; 0x1ee <L_72+0x8c>
        break;
      if(dif == 2)
     19e:	82 30       	cpi	r24, 0x02	; 2
     1a0:	21 f4       	brne	.+8      	; 0x1aa <L_72+0x48>
      {
        NOP();
     1a2:	00 00       	nop
        NOP();
     1a4:	00 00       	nop
        NOP();
     1a6:	00 00       	nop
     1a8:	01 c0       	rjmp	.+2      	; 0x1ac <L_72+0x4a>
      }
      else
        warte(dif);
     1aa:	a2 df       	rcall	.-188    	; 0xf0 <warte>
    }
    NOP();
     1ac:	00 00       	nop
    PIND = d2;
     1ae:	19 b9       	out	0x09, r17	; 9
    PINC = c2;
     1b0:	06 b9       	out	0x06, r16	; 6
    dif = *(p + 9);
     1b2:	89 85       	ldd	r24, Y+9	; 0x09
    if(dif != 1)
     1b4:	81 30       	cpi	r24, 0x01	; 1
     1b6:	49 f0       	breq	.+18     	; 0x1ca <L_72+0x68>
    {
      if(!dif)
     1b8:	88 23       	and	r24, r24
     1ba:	c9 f0       	breq	.+50     	; 0x1ee <L_72+0x8c>
        break;
      if(dif == 2)
     1bc:	82 30       	cpi	r24, 0x02	; 2
     1be:	21 f4       	brne	.+8      	; 0x1c8 <L_72+0x66>
      {
        NOP();
     1c0:	00 00       	nop
        NOP();
     1c2:	00 00       	nop
        NOP();
     1c4:	00 00       	nop
     1c6:	01 c0       	rjmp	.+2      	; 0x1ca <L_72+0x68>
      }
      else
        warte(dif);
     1c8:	93 df       	rcall	.-218    	; 0xf0 <warte>
    }
    NOP();
     1ca:	00 00       	nop
    PIND = d3;
     1cc:	f9 b8       	out	0x09, r15	; 9
    PINC = c3;
     1ce:	e6 b8       	out	0x06, r14	; 6
    dif = *(p + 10);
     1d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    if(dif != 1)
     1d2:	81 30       	cpi	r24, 0x01	; 1
     1d4:	49 f0       	breq	.+18     	; 0x1e8 <L_72+0x86>
    {
      if(!dif)
     1d6:	88 23       	and	r24, r24
     1d8:	51 f0       	breq	.+20     	; 0x1ee <L_72+0x8c>
        break;
      if(dif == 2)
     1da:	82 30       	cpi	r24, 0x02	; 2
     1dc:	21 f4       	brne	.+8      	; 0x1e6 <L_72+0x84>
      {
        NOP();
     1de:	00 00       	nop
        NOP();
     1e0:	00 00       	nop
        NOP();
     1e2:	00 00       	nop
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <L_72+0x86>
      }
      else
        warte(dif);
     1e6:	84 df       	rcall	.-248    	; 0xf0 <warte>
    }
    NOP();
     1e8:	00 00       	nop
    PIND = d4;
     1ea:	d9 b8       	out	0x09, r13	; 9
    PINC = c4;
     1ec:	c6 b8       	out	0x06, r12	; 6
    break;
  }
  bool receiverIntTemp = EIFR & (1 << INTF0);
     1ee:	2c b3       	in	r18, 0x1c	; 28
  TIMSK1 &= ~(1<<OCIE1A);         // PPM Interrupt aus
     1f0:	80 91 6f 00 	lds	r24, 0x006F
     1f4:	8d 7f       	andi	r24, 0xFD	; 253
     1f6:	80 93 6f 00 	sts	0x006F, r24
  sei();                          // Interrupt ein, jetzt kommen alle anderen Interrupts zum Zug
     1fa:	78 94       	sei
  c -= OCR1AL;
     1fc:	80 91 88 00 	lds	r24, 0x0088
     200:	9b 2d       	mov	r25, r11
     202:	98 1b       	sub	r25, r24
  uint8_t i = output.idx;
     204:	e0 91 8f 01 	lds	r30, 0x018F
     208:	02 c0       	rjmp	.+4      	; 0x20e <L_72+0xac>
  while(*(p + 8) && (i < 3))                    // Ende suchen
  {
    ++p;
     20a:	21 96       	adiw	r28, 0x01	; 1
    ++i;
     20c:	ef 5f       	subi	r30, 0xFF	; 255
  bool receiverIntTemp = EIFR & (1 << INTF0);
  TIMSK1 &= ~(1<<OCIE1A);         // PPM Interrupt aus
  sei();                          // Interrupt ein, jetzt kommen alle anderen Interrupts zum Zug
  c -= OCR1AL;
  uint8_t i = output.idx;
  while(*(p + 8) && (i < 3))                    // Ende suchen
     20e:	88 85       	ldd	r24, Y+8	; 0x08
     210:	88 23       	and	r24, r24
     212:	11 f0       	breq	.+4      	; 0x218 <L_72+0xb6>
     214:	e3 30       	cpi	r30, 0x03	; 3
     216:	c8 f3       	brcs	.-14     	; 0x20a <L_72+0xa8>
  {
    ++p;
    ++i;
  }
  ++i;
     218:	8e 2f       	mov	r24, r30
     21a:	8f 5f       	subi	r24, 0xFF	; 255
  if((ppm.raw[i] == 0) || (i > 3))              // prüfen ob noch was kommt
     21c:	e8 2f       	mov	r30, r24
     21e:	f0 e0       	ldi	r31, 0x00	; 0
     220:	ee 0f       	add	r30, r30
     222:	ff 1f       	adc	r31, r31
     224:	e2 54       	subi	r30, 0x42	; 66
     226:	fe 4f       	sbci	r31, 0xFE	; 254
     228:	01 90       	ld	r0, Z+
     22a:	f0 81       	ld	r31, Z
     22c:	e0 2d       	mov	r30, r0
     22e:	30 97       	sbiw	r30, 0x00	; 0
     230:	11 f0       	breq	.+4      	; 0x236 <L_72+0xd4>
     232:	84 30       	cpi	r24, 0x04	; 4
     234:	18 f0       	brcs	.+6      	; 0x23c <L_72+0xda>
  {
//    TIMSK1 &= ~(1<<OCIE1A);           // Interrupt aus
    TCCR1B = 0;                         // Timer aus
     236:	10 92 81 00 	sts	0x0081, r1
     23a:	0b c0       	rjmp	.+22     	; 0x252 <L_72+0xf0>
  }
  else
  {
    OCR1A = ppm.raw[i];
     23c:	f0 93 89 00 	sts	0x0089, r31
     240:	e0 93 88 00 	sts	0x0088, r30
    output.idx = i;
     244:	80 93 8f 01 	sts	0x018F, r24
    TIMSK1 |= (1<<OCIE1A);           // Interrupt ein
     248:	80 91 6f 00 	lds	r24, 0x006F
     24c:	82 60       	ori	r24, 0x02	; 2
     24e:	80 93 6f 00 	sts	0x006F, r24
  }

  if(output.latenzMin > c)
     252:	80 91 91 01 	lds	r24, 0x0191
     256:	98 17       	cp	r25, r24
     258:	10 f4       	brcc	.+4      	; 0x25e <L_72+0xfc>
    output.latenzMin = c;
     25a:	90 93 91 01 	sts	0x0191, r25
  if(output.latenzMax < c)
     25e:	80 91 92 01 	lds	r24, 0x0192
     262:	89 17       	cp	r24, r25
     264:	10 f4       	brcc	.+4      	; 0x26a <L_72+0x108>
    output.latenzMax = c;
     266:	90 93 92 01 	sts	0x0192, r25

  if(receiverIntTemp)                           // Empfängerinterrupt ist während cli() gekommen
     26a:	20 ff       	sbrs	r18, 0
     26c:	05 c0       	rjmp	.+10     	; 0x278 <L_72+0x116>
    --state.RxTimer;                            // Capturewert etwas korrigieren
     26e:	80 91 97 01 	lds	r24, 0x0197
     272:	81 50       	subi	r24, 0x01	; 1
     274:	80 93 97 01 	sts	0x0197, r24

//  static uint8_t tes;
//  if(TCNT1L > tes)
//    tes = TCNT1L;
}
     278:	ff 91       	pop	r31
     27a:	ef 91       	pop	r30
     27c:	df 91       	pop	r29
     27e:	cf 91       	pop	r28
     280:	bf 91       	pop	r27
     282:	af 91       	pop	r26
     284:	9f 91       	pop	r25
     286:	8f 91       	pop	r24
     288:	7f 91       	pop	r23
     28a:	6f 91       	pop	r22
     28c:	5f 91       	pop	r21
     28e:	4f 91       	pop	r20
     290:	3f 91       	pop	r19
     292:	2f 91       	pop	r18
     294:	1f 91       	pop	r17
     296:	0f 91       	pop	r16
     298:	ff 90       	pop	r15
     29a:	ef 90       	pop	r14
     29c:	df 90       	pop	r13
     29e:	cf 90       	pop	r12
     2a0:	bf 90       	pop	r11
     2a2:	0f 90       	pop	r0
     2a4:	0f be       	out	0x3f, r0	; 63
     2a6:	0f 90       	pop	r0
     2a8:	1f 90       	pop	r1
     2aa:	18 95       	reti

000002ac <setupPulses>:

void setupPulses(bool highGroup)
{
     2ac:	ef 92       	push	r14
     2ae:	ff 92       	push	r15
     2b0:	0f 93       	push	r16
     2b2:	1f 93       	push	r17
     2b4:	cf 93       	push	r28
     2b6:	df 93       	push	r29
     2b8:	38 2f       	mov	r19, r24
  uint8_t i, y;

  if(TIMSK1 & (1<<OCIE1A))                // läuft noch 
     2ba:	80 91 6f 00 	lds	r24, 0x006F
     2be:	81 fd       	sbrc	r24, 1
     2c0:	48 c1       	rjmp	.+656    	; 0x552 <__stack+0x53>
    return;

  uint8_t Cflag;
  uint8_t Dflag;

  if(!highGroup)
     2c2:	33 23       	and	r19, r19
     2c4:	79 f5       	brne	.+94     	; 0x324 <setupPulses+0x78>
  {
    output.pulsesOffset = 0;
     2c6:	10 92 86 01 	sts	0x0186, r1
    if(!(output.portCflg & ((1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2)
     2ca:	20 91 84 01 	lds	r18, 0x0184
     2ce:	82 2f       	mov	r24, r18
     2d0:	90 e0       	ldi	r25, 0x00	; 0
     2d2:	8f 70       	andi	r24, 0x0F	; 15
     2d4:	90 70       	andi	r25, 0x00	; 0
     2d6:	89 2b       	or	r24, r25
     2d8:	09 f4       	brne	.+2      	; 0x2dc <setupPulses+0x30>
     2da:	3b c1       	rjmp	.+630    	; 0x552 <__stack+0x53>
        | (1 << OUT_C_CHANNEL3) | (1 << OUT_C_CHANNEL4))))
      return;
    Cflag = (output.portCflg & ((1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2)
     2dc:	52 2f       	mov	r21, r18
     2de:	5f 70       	andi	r21, 0x0F	; 15
     2e0:	50 6c       	ori	r21, 0xC0	; 192
        | (1 << OUT_C_CHANNEL3) | (1 << OUT_C_CHANNEL4)))
        | ~((1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2) | (1 << OUT_C_CHANNEL3)   // Alle Nichtausgänge auf C setzen
        | (1 << OUT_C_CHANNEL4) | (1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6));
    Dflag = (uint8_t)~((1 << OUT_D_LED) | (1 << OUT_D_ANT1) | (1 << OUT_D_ANT2)   // Alle Nichtausgänge (Eingänge) auf D setzen
        | (1 << OUT_D_CHANNEL7) | (1 << OUT_D_CHANNEL8));
    ppm.toggleC[0] = (1 << OUT_C_CHANNEL1) & Cflag;
     2e2:	85 2f       	mov	r24, r21
     2e4:	81 70       	andi	r24, 0x01	; 1
     2e6:	80 93 b2 01 	sts	0x01B2, r24
    ppm.toggleC[1] = (1 << OUT_C_CHANNEL2) & Cflag;
     2ea:	85 2f       	mov	r24, r21
     2ec:	82 70       	andi	r24, 0x02	; 2
     2ee:	80 93 b3 01 	sts	0x01B3, r24
    ppm.toggleC[2] = (1 << OUT_C_CHANNEL3) & Cflag;
     2f2:	85 2f       	mov	r24, r21
     2f4:	84 70       	andi	r24, 0x04	; 4
     2f6:	80 93 b4 01 	sts	0x01B4, r24
    ppm.toggleC[3] = (1 << OUT_C_CHANNEL4) & Cflag;
     2fa:	85 2f       	mov	r24, r21
     2fc:	88 70       	andi	r24, 0x08	; 8
     2fe:	80 93 b5 01 	sts	0x01B5, r24
    ppm.toggleD[0] = 0;
     302:	10 92 b6 01 	sts	0x01B6, r1
    ppm.toggleD[1] = 0;
     306:	10 92 b7 01 	sts	0x01B7, r1
    output.pulsesTimer[0] = 0;
     30a:	10 92 87 01 	sts	0x0187, r1
    output.pulsesTimer[1] = 0;
     30e:	10 92 88 01 	sts	0x0188, r1
    output.pulsesTimer[2] = 0;
     312:	10 92 89 01 	sts	0x0189, r1
    output.pulsesTimer[3] = 0;
     316:	10 92 8a 01 	sts	0x018A, r1
    output.portCflg &= ~((1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2)
     31a:	20 7f       	andi	r18, 0xF0	; 240
     31c:	20 93 84 01 	sts	0x0184, r18
     320:	1c e2       	ldi	r17, 0x2C	; 44
     322:	35 c0       	rjmp	.+106    	; 0x38e <setupPulses+0xe2>
            | (1 << OUT_C_CHANNEL3) | (1 << OUT_C_CHANNEL4));
  }
  else
  {
    if(!(output.portCflg & ((1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6)))
     324:	20 91 84 01 	lds	r18, 0x0184
     328:	82 2f       	mov	r24, r18
     32a:	80 73       	andi	r24, 0x30	; 48
     32c:	41 f4       	brne	.+16     	; 0x33e <setupPulses+0x92>
     32e:	80 91 85 01 	lds	r24, 0x0185
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	83 70       	andi	r24, 0x03	; 3
     336:	90 70       	andi	r25, 0x00	; 0
     338:	89 2b       	or	r24, r25
     33a:	09 f4       	brne	.+2      	; 0x33e <setupPulses+0x92>
     33c:	0a c1       	rjmp	.+532    	; 0x552 <__stack+0x53>
        && !(output.portDflg & ((1 << OUT_D_CHANNEL7) | (1 << OUT_D_CHANNEL8))))
      return;
    Cflag = (output.portCflg & ((1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6)))
     33e:	52 2f       	mov	r21, r18
     340:	50 73       	andi	r21, 0x30	; 48
     342:	50 6c       	ori	r21, 0xC0	; 192
        | ~((1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2) | (1 << OUT_C_CHANNEL3)
        | (1 << OUT_C_CHANNEL4) | (1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6));
    Dflag = (output.portDflg & ((1 << OUT_D_CHANNEL7) | (1 << OUT_D_CHANNEL8)))
     344:	10 91 85 01 	lds	r17, 0x0185
     348:	13 70       	andi	r17, 0x03	; 3
     34a:	1c 62       	ori	r17, 0x2C	; 44
        | ~((1 << OUT_D_LED) | (1 << OUT_D_ANT1) | (1 << OUT_D_ANT2)
        | (1 << OUT_D_CHANNEL7) | (1 << OUT_D_CHANNEL8));
    ppm.toggleC[0] = (1 << OUT_C_CHANNEL5) & Cflag;
     34c:	85 2f       	mov	r24, r21
     34e:	80 71       	andi	r24, 0x10	; 16
     350:	80 93 b2 01 	sts	0x01B2, r24
    ppm.toggleC[1] = (1 << OUT_C_CHANNEL6) & Cflag;
     354:	85 2f       	mov	r24, r21
     356:	80 72       	andi	r24, 0x20	; 32
     358:	80 93 b3 01 	sts	0x01B3, r24
    ppm.toggleC[2] = 0;
     35c:	10 92 b4 01 	sts	0x01B4, r1
    ppm.toggleC[3] = 0;
     360:	10 92 b5 01 	sts	0x01B5, r1
    ppm.toggleD[0] = (1 << OUT_D_CHANNEL7) & Dflag;
     364:	81 2f       	mov	r24, r17
     366:	81 70       	andi	r24, 0x01	; 1
     368:	80 93 b6 01 	sts	0x01B6, r24
    ppm.toggleD[1] = (1 << OUT_D_CHANNEL8) & Dflag;
     36c:	81 2f       	mov	r24, r17
     36e:	82 70       	andi	r24, 0x02	; 2
     370:	80 93 b7 01 	sts	0x01B7, r24
    output.pulsesTimer[4] = 0;
     374:	10 92 8b 01 	sts	0x018B, r1
    output.pulsesTimer[5] = 0;
     378:	10 92 8c 01 	sts	0x018C, r1
    output.pulsesTimer[6] = 0;
     37c:	10 92 8d 01 	sts	0x018D, r1
    output.pulsesTimer[7] = 0;
     380:	10 92 8e 01 	sts	0x018E, r1
    output.portCflg &= ~((1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6));
     384:	2f 7c       	andi	r18, 0xCF	; 207
     386:	20 93 84 01 	sts	0x0184, r18
    output.portDflg = 0;
     38a:	10 92 85 01 	sts	0x0185, r1
  }
  ppm.toggleD[2] = 0;
     38e:	10 92 b8 01 	sts	0x01B8, r1
  ppm.toggleD[3] = 0;
     392:	10 92 b9 01 	sts	0x01B9, r1
     396:	4e eb       	ldi	r20, 0xBE	; 190
     398:	e4 2e       	mov	r14, r20
     39a:	41 e0       	ldi	r20, 0x01	; 1
     39c:	f4 2e       	mov	r15, r20
     39e:	a4 e7       	ldi	r26, 0x74	; 116
     3a0:	b1 e0       	ldi	r27, 0x01	; 1
     3a2:	f7 01       	movw	r30, r14

  for(i = 0;i < 4;++i)
  {
    uint16_t temp;
    if(highGroup)
     3a4:	33 23       	and	r19, r19
     3a6:	29 f0       	breq	.+10     	; 0x3b2 <setupPulses+0x106>
      temp = output.chan_1us[i + 4];
     3a8:	18 96       	adiw	r26, 0x08	; 8
     3aa:	8d 91       	ld	r24, X+
     3ac:	9c 91       	ld	r25, X
     3ae:	19 97       	sbiw	r26, 0x09	; 9
     3b0:	03 c0       	rjmp	.+6      	; 0x3b8 <setupPulses+0x10c>
    else
      temp = output.chan_1us[i];
     3b2:	8d 91       	ld	r24, X+
     3b4:	9c 91       	ld	r25, X
     3b6:	11 97       	sbiw	r26, 0x01	; 1
    ppm.raw[i] = temp * 8 + (INTERRUPTOFFSET * 8 - 116);   // Mit Pulslänge füllen
     3b8:	23 e0       	ldi	r18, 0x03	; 3
     3ba:	88 0f       	add	r24, r24
     3bc:	99 1f       	adc	r25, r25
     3be:	2a 95       	dec	r18
     3c0:	e1 f7       	brne	.-8      	; 0x3ba <setupPulses+0x10e>
     3c2:	84 59       	subi	r24, 0x94	; 148
     3c4:	91 4d       	sbci	r25, 0xD1	; 209
     3c6:	81 93       	st	Z+, r24
     3c8:	91 93       	st	Z+, r25
     3ca:	12 96       	adiw	r26, 0x02	; 2
    output.portDflg = 0;
  }
  ppm.toggleD[2] = 0;
  ppm.toggleD[3] = 0;

  for(i = 0;i < 4;++i)
     3cc:	81 e0       	ldi	r24, 0x01	; 1
     3ce:	e6 3c       	cpi	r30, 0xC6	; 198
     3d0:	f8 07       	cpc	r31, r24
     3d2:	41 f7       	brne	.-48     	; 0x3a4 <setupPulses+0xf8>
     3d4:	bf 01       	movw	r22, r30
     3d6:	64 51       	subi	r22, 0x14	; 20
     3d8:	70 40       	sbci	r23, 0x00	; 0
     3da:	ef 01       	movw	r28, r30
     3dc:	28 97       	sbiw	r28, 0x08	; 8
     3de:	db 01       	movw	r26, r22
     3e0:	80 e0       	ldi	r24, 0x00	; 0
      temp = output.chan_1us[i];
    ppm.raw[i] = temp * 8 + (INTERRUPTOFFSET * 8 - 116);   // Mit Pulslänge füllen
  }
  for(i = 0;i < 3;++i)            // qsort
  {
    for(y = i + 1;y < 4;++y)
     3e2:	08 2f       	mov	r16, r24
     3e4:	0f 5f       	subi	r16, 0xFF	; 255
     3e6:	40 2f       	mov	r20, r16
    {
      if((ppm.raw[i] > ppm.raw[y]) || ((ppm.raw[i] == 0) && (ppm.raw[y] != 0)))
     3e8:	88 81       	ld	r24, Y
     3ea:	99 81       	ldd	r25, Y+1	; 0x01
     3ec:	24 2f       	mov	r18, r20
     3ee:	30 e0       	ldi	r19, 0x00	; 0
     3f0:	f9 01       	movw	r30, r18
     3f2:	ee 0f       	add	r30, r30
     3f4:	ff 1f       	adc	r31, r31
     3f6:	e2 54       	subi	r30, 0x42	; 66
     3f8:	fe 4f       	sbci	r31, 0xFE	; 254
     3fa:	01 90       	ld	r0, Z+
     3fc:	f0 81       	ld	r31, Z
     3fe:	e0 2d       	mov	r30, r0
     400:	e8 17       	cp	r30, r24
     402:	f9 07       	cpc	r31, r25
     404:	20 f0       	brcs	.+8      	; 0x40e <setupPulses+0x162>
     406:	00 97       	sbiw	r24, 0x00	; 0
     408:	d1 f4       	brne	.+52     	; 0x43e <setupPulses+0x192>
     40a:	30 97       	sbiw	r30, 0x00	; 0
     40c:	c1 f0       	breq	.+48     	; 0x43e <setupPulses+0x192>
      {
        uint16_t temp = ppm.raw[i];
        ppm.raw[i] = ppm.raw[y];
     40e:	f9 83       	std	Y+1, r31	; 0x01
     410:	e8 83       	st	Y, r30
        ppm.raw[y] = temp;
     412:	f9 01       	movw	r30, r18
     414:	ee 0f       	add	r30, r30
     416:	ff 1f       	adc	r31, r31
     418:	e2 54       	subi	r30, 0x42	; 66
     41a:	fe 4f       	sbci	r31, 0xFE	; 254
     41c:	91 83       	std	Z+1, r25	; 0x01
     41e:	80 83       	st	Z, r24
        uint8_t ctemp = ppm.toggleC[i];
     420:	9c 91       	ld	r25, X
        ppm.toggleC[i] = ppm.toggleC[y];
     422:	f9 01       	movw	r30, r18
     424:	ee 54       	subi	r30, 0x4E	; 78
     426:	fe 4f       	sbci	r31, 0xFE	; 254
     428:	80 81       	ld	r24, Z
     42a:	8c 93       	st	X, r24
        ppm.toggleC[y] = ctemp;
     42c:	90 83       	st	Z, r25
        ctemp = ppm.toggleD[i];
     42e:	14 96       	adiw	r26, 0x04	; 4
     430:	9c 91       	ld	r25, X
     432:	14 97       	sbiw	r26, 0x04	; 4
        ppm.toggleD[i] = ppm.toggleD[y];
     434:	84 81       	ldd	r24, Z+4	; 0x04
     436:	14 96       	adiw	r26, 0x04	; 4
     438:	8c 93       	st	X, r24
     43a:	14 97       	sbiw	r26, 0x04	; 4
        ppm.toggleD[y] = ctemp;
     43c:	94 83       	std	Z+4, r25	; 0x04
      temp = output.chan_1us[i];
    ppm.raw[i] = temp * 8 + (INTERRUPTOFFSET * 8 - 116);   // Mit Pulslänge füllen
  }
  for(i = 0;i < 3;++i)            // qsort
  {
    for(y = i + 1;y < 4;++y)
     43e:	4f 5f       	subi	r20, 0xFF	; 255
     440:	44 30       	cpi	r20, 0x04	; 4
     442:	90 f2       	brcs	.-92     	; 0x3e8 <setupPulses+0x13c>
     444:	22 96       	adiw	r28, 0x02	; 2
     446:	11 96       	adiw	r26, 0x01	; 1
     448:	80 2f       	mov	r24, r16
      temp = output.chan_1us[i + 4];
    else
      temp = output.chan_1us[i];
    ppm.raw[i] = temp * 8 + (INTERRUPTOFFSET * 8 - 116);   // Mit Pulslänge füllen
  }
  for(i = 0;i < 3;++i)            // qsort
     44a:	03 30       	cpi	r16, 0x03	; 3
     44c:	51 f6       	brne	.-108    	; 0x3e2 <setupPulses+0x136>
    {
      ppm.toggleC[i + 1] |= ppm.toggleC[i];
      ppm.toggleD[i + 1] |= ppm.toggleD[i];
      ppm.raw[i] = 0;             // ungültig markieren
    }
    if(delaytemp > state.minAb)     // kürzeste Zeit zwischen 2 Interrupts
     44e:	80 91 b1 01 	lds	r24, 0x01B1
     452:	c8 2f       	mov	r28, r24
     454:	d0 e0       	ldi	r29, 0x00	; 0
     456:	e2 eb       	ldi	r30, 0xB2	; 178
     458:	f1 e0       	ldi	r31, 0x01	; 1
     45a:	df 01       	movw	r26, r30
     45c:	1c 96       	adiw	r26, 0x0c	; 12
      }
    }
  }
  for(i = 0;i < 3;++i)            // Gleiche zusammenfassen
  {
    uint16_t delaytemp = (ppm.raw[i + 1] - ppm.raw[i]) / 8;
     45e:	12 96       	adiw	r26, 0x02	; 2
     460:	2d 91       	ld	r18, X+
     462:	3c 91       	ld	r19, X
     464:	13 97       	sbiw	r26, 0x03	; 3
     466:	8d 91       	ld	r24, X+
     468:	9c 91       	ld	r25, X
     46a:	11 97       	sbiw	r26, 0x01	; 1
     46c:	28 1b       	sub	r18, r24
     46e:	39 0b       	sbc	r19, r25
     470:	03 e0       	ldi	r16, 0x03	; 3
     472:	36 95       	lsr	r19
     474:	27 95       	ror	r18
     476:	0a 95       	dec	r16
     478:	e1 f7       	brne	.-8      	; 0x472 <setupPulses+0x1c6>
    if(delaytemp == 0)
     47a:	21 15       	cp	r18, r1
     47c:	31 05       	cpc	r19, r1
     47e:	61 f4       	brne	.+24     	; 0x498 <setupPulses+0x1ec>
    {
      ppm.toggleC[i + 1] |= ppm.toggleC[i];
     480:	81 81       	ldd	r24, Z+1	; 0x01
     482:	90 81       	ld	r25, Z
     484:	89 2b       	or	r24, r25
     486:	81 83       	std	Z+1, r24	; 0x01
      ppm.toggleD[i + 1] |= ppm.toggleD[i];
     488:	85 81       	ldd	r24, Z+5	; 0x05
     48a:	94 81       	ldd	r25, Z+4	; 0x04
     48c:	89 2b       	or	r24, r25
     48e:	85 83       	std	Z+5, r24	; 0x05
      ppm.raw[i] = 0;             // ungültig markieren
     490:	11 96       	adiw	r26, 0x01	; 1
     492:	1c 92       	st	X, r1
     494:	1e 92       	st	-X, r1
     496:	05 c0       	rjmp	.+10     	; 0x4a2 <setupPulses+0x1f6>
    }
    if(delaytemp > state.minAb)     // kürzeste Zeit zwischen 2 Interrupts
     498:	c2 17       	cp	r28, r18
     49a:	d3 07       	cpc	r29, r19
     49c:	10 f4       	brcc	.+4      	; 0x4a2 <setupPulses+0x1f6>
      ppm.nextdelay[i] = 0;
     49e:	10 86       	std	Z+8, r1	; 0x08
     4a0:	01 c0       	rjmp	.+2      	; 0x4a4 <setupPulses+0x1f8>
    else
      ppm.nextdelay[i] = (uint8_t)delaytemp;
     4a2:	20 87       	std	Z+8, r18	; 0x08
     4a4:	12 96       	adiw	r26, 0x02	; 2
     4a6:	31 96       	adiw	r30, 0x01	; 1
        ppm.toggleD[i] = ppm.toggleD[y];
        ppm.toggleD[y] = ctemp;
      }
    }
  }
  for(i = 0;i < 3;++i)            // Gleiche zusammenfassen
     4a8:	91 e0       	ldi	r25, 0x01	; 1
     4aa:	a4 3c       	cpi	r26, 0xC4	; 196
     4ac:	b9 07       	cpc	r27, r25
     4ae:	b9 f6       	brne	.-82     	; 0x45e <setupPulses+0x1b2>
    if(delaytemp > state.minAb)     // kürzeste Zeit zwischen 2 Interrupts
      ppm.nextdelay[i] = 0;
    else
      ppm.nextdelay[i] = (uint8_t)delaytemp;
  }
  ppm.nextdelay[3] = 0;
     4b0:	10 92 bd 01 	sts	0x01BD, r1
     4b4:	31 e0       	ldi	r19, 0x01	; 1
  for(i = 0;i < 3;++i)            // Rest dahinter, herschieben
  {
    if(ppm.raw[i] == 0)           // Platz ist leer
     4b6:	e7 01       	movw	r28, r14
     4b8:	88 81       	ld	r24, Y
     4ba:	99 81       	ldd	r25, Y+1	; 0x01
     4bc:	89 2b       	or	r24, r25
     4be:	01 f5       	brne	.+64     	; 0x500 <__stack+0x1>
     4c0:	23 2f       	mov	r18, r19
    {
      for(y = i + 1;y < 4;++y)
      {
        if(ppm.raw[y] == 0)
     4c2:	e2 2f       	mov	r30, r18
     4c4:	f0 e0       	ldi	r31, 0x00	; 0
     4c6:	df 01       	movw	r26, r30
     4c8:	aa 0f       	add	r26, r26
     4ca:	bb 1f       	adc	r27, r27
     4cc:	a2 54       	subi	r26, 0x42	; 66
     4ce:	be 4f       	sbci	r27, 0xFE	; 254
     4d0:	8d 91       	ld	r24, X+
     4d2:	9c 91       	ld	r25, X
     4d4:	11 97       	sbiw	r26, 0x01	; 1
     4d6:	00 97       	sbiw	r24, 0x00	; 0
     4d8:	81 f0       	breq	.+32     	; 0x4fa <setupPulses+0x24e>
          continue;
        ppm.raw[i] = ppm.raw[y];
     4da:	e7 01       	movw	r28, r14
     4dc:	99 83       	std	Y+1, r25	; 0x01
     4de:	88 83       	st	Y, r24
        ppm.toggleC[i] = ppm.toggleC[y];
     4e0:	ee 54       	subi	r30, 0x4E	; 78
     4e2:	fe 4f       	sbci	r31, 0xFE	; 254
     4e4:	80 81       	ld	r24, Z
     4e6:	eb 01       	movw	r28, r22
     4e8:	88 83       	st	Y, r24
        ppm.toggleD[i] = ppm.toggleD[y];
     4ea:	84 81       	ldd	r24, Z+4	; 0x04
     4ec:	8c 83       	std	Y+4, r24	; 0x04
        ppm.nextdelay[i] = ppm.nextdelay[y];
     4ee:	80 85       	ldd	r24, Z+8	; 0x08
     4f0:	88 87       	std	Y+8, r24	; 0x08
        ppm.raw[y] = 0;
     4f2:	1d 92       	st	X+, r1
     4f4:	1c 92       	st	X, r1
        ppm.nextdelay[y] = 0;
     4f6:	10 86       	std	Z+8, r1	; 0x08
     4f8:	03 c0       	rjmp	.+6      	; 0x500 <__stack+0x1>
  ppm.nextdelay[3] = 0;
  for(i = 0;i < 3;++i)            // Rest dahinter, herschieben
  {
    if(ppm.raw[i] == 0)           // Platz ist leer
    {
      for(y = i + 1;y < 4;++y)
     4fa:	2f 5f       	subi	r18, 0xFF	; 255
     4fc:	24 30       	cpi	r18, 0x04	; 4
     4fe:	08 f3       	brcs	.-62     	; 0x4c2 <setupPulses+0x216>
     500:	3f 5f       	subi	r19, 0xFF	; 255
     502:	e2 e0       	ldi	r30, 0x02	; 2
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	ee 0e       	add	r14, r30
     508:	ff 1e       	adc	r15, r31
     50a:	6f 5f       	subi	r22, 0xFF	; 255
     50c:	7f 4f       	sbci	r23, 0xFF	; 255
      ppm.nextdelay[i] = 0;
    else
      ppm.nextdelay[i] = (uint8_t)delaytemp;
  }
  ppm.nextdelay[3] = 0;
  for(i = 0;i < 3;++i)            // Rest dahinter, herschieben
     50e:	34 30       	cpi	r19, 0x04	; 4
     510:	91 f6       	brne	.-92     	; 0x4b6 <setupPulses+0x20a>
        ppm.nextdelay[y] = 0;
        break;
      }
    }
  }
  output.idx = 0;
     512:	10 92 8f 01 	sts	0x018F, r1
  output.port = false;
     516:	10 92 90 01 	sts	0x0190, r1
  TCCR1B = 0;      // Timer aus
     51a:	10 92 81 00 	sts	0x0081, r1
  TCNT1 = 0;
     51e:	10 92 85 00 	sts	0x0085, r1
     522:	10 92 84 00 	sts	0x0084, r1
  OCR1A = ppm.raw[0];
     526:	80 91 be 01 	lds	r24, 0x01BE
     52a:	90 91 bf 01 	lds	r25, 0x01BF
     52e:	90 93 89 00 	sts	0x0089, r25
     532:	80 93 88 00 	sts	0x0088, r24
  //SET_BIT(TIFR1, OCF1A);
  TIFR1 = (1 << OCF1A);
     536:	82 e0       	ldi	r24, 0x02	; 2
     538:	86 bb       	out	0x16, r24	; 22
  SET_BIT(TIMSK1, OCIE1A);          // Timer Interrupt Mask Register
     53a:	80 91 6f 00 	lds	r24, 0x006F
     53e:	82 60       	ori	r24, 0x02	; 2
     540:	80 93 6f 00 	sts	0x006F, r24
  TCCR1B = (1 << CS10);      // Timer an 8MHz
     544:	81 e0       	ldi	r24, 0x01	; 1
     546:	80 93 81 00 	sts	0x0081, r24

//  NOP();
  PORTD |= Dflag;
     54a:	8b b1       	in	r24, 0x0b	; 11
     54c:	18 2b       	or	r17, r24
     54e:	1b b9       	out	0x0b, r17	; 11
  PORTC = Cflag;
     550:	58 b9       	out	0x08, r21	; 8
//  NOP();                // ***
}
     552:	df 91       	pop	r29
     554:	cf 91       	pop	r28
     556:	1f 91       	pop	r17
     558:	0f 91       	pop	r16
     55a:	ff 90       	pop	r15
     55c:	ef 90       	pop	r14
     55e:	08 95       	ret

00000560 <SPI_MasterTransmit>:

uint8_t SPI_MasterTransmit(uint8_t cData)
{
     560:	98 2f       	mov	r25, r24
  uint8_t i = 0;
  if(PORTB & (1 << OUT_B_SPI_SS))
     562:	2a 9b       	sbis	0x05, 2	; 5
     564:	27 c0       	rjmp	.+78     	; 0x5b4 <SPI_MasterTransmit+0x54>
  {
    RES_BIT(PORTB, OUT_B_SPI_SS);
     566:	2a 98       	cbi	0x05, 2	; 5
    NOP();
     568:	00 00       	nop
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	09 c0       	rjmp	.+18     	; 0x580 <SPI_MasterTransmit+0x20>
    while(PINB & (1<<OUT_B_SPI_SS))
      if(++i > 0xfe)
     56e:	8f 5f       	subi	r24, 0xFF	; 255
     570:	8f 3f       	cpi	r24, 0xFF	; 255
     572:	31 f4       	brne	.+12     	; 0x580 <SPI_MasterTransmit+0x20>
      {
        SET_BIT(state.ledError, L_SPI_ERROR);
     574:	80 91 a2 01 	lds	r24, 0x01A2
     578:	88 60       	ori	r24, 0x08	; 8
     57a:	80 93 a2 01 	sts	0x01A2, r24
     57e:	02 c0       	rjmp	.+4      	; 0x584 <SPI_MasterTransmit+0x24>
  uint8_t i = 0;
  if(PORTB & (1 << OUT_B_SPI_SS))
  {
    RES_BIT(PORTB, OUT_B_SPI_SS);
    NOP();
    while(PINB & (1<<OUT_B_SPI_SS))
     580:	1a 99       	sbic	0x03, 2	; 3
     582:	f5 cf       	rjmp	.-22     	; 0x56e <SPI_MasterTransmit+0xe>
      if(++i > 0xfe)
      {
        SET_BIT(state.ledError, L_SPI_ERROR);
        break;
      }
    NOP();
     584:	00 00       	nop
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	09 c0       	rjmp	.+18     	; 0x59c <SPI_MasterTransmit+0x3c>
    i = 0;
    while(PINB & (1 << INP_B_SPI_MISO))
      if(++i > 0xfe)
     58a:	8f 5f       	subi	r24, 0xFF	; 255
     58c:	8f 3f       	cpi	r24, 0xFF	; 255
     58e:	31 f4       	brne	.+12     	; 0x59c <SPI_MasterTransmit+0x3c>
      {
        SET_BIT(state.ledError, L_SPI_ERROR);
     590:	80 91 a2 01 	lds	r24, 0x01A2
     594:	88 60       	ori	r24, 0x08	; 8
     596:	80 93 a2 01 	sts	0x01A2, r24
     59a:	0c c0       	rjmp	.+24     	; 0x5b4 <SPI_MasterTransmit+0x54>
        SET_BIT(state.ledError, L_SPI_ERROR);
        break;
      }
    NOP();
    i = 0;
    while(PINB & (1 << INP_B_SPI_MISO))
     59c:	1c 99       	sbic	0x03, 4	; 3
     59e:	f5 cf       	rjmp	.-22     	; 0x58a <SPI_MasterTransmit+0x2a>
     5a0:	09 c0       	rjmp	.+18     	; 0x5b4 <SPI_MasterTransmit+0x54>
        break;
      }
  }
  i = 0;
  while(PIND & (1<<INP_D_CC2500_GDO2))
    if(++i > 0xfe)
     5a2:	8f 5f       	subi	r24, 0xFF	; 255
     5a4:	8f 3f       	cpi	r24, 0xFF	; 255
     5a6:	39 f4       	brne	.+14     	; 0x5b6 <SPI_MasterTransmit+0x56>
    {
      SET_BIT(state.ledError, L_SPI_ERROR);
     5a8:	80 91 a2 01 	lds	r24, 0x01A2
     5ac:	88 60       	ori	r24, 0x08	; 8
     5ae:	80 93 a2 01 	sts	0x01A2, r24
     5b2:	03 c0       	rjmp	.+6      	; 0x5ba <SPI_MasterTransmit+0x5a>
      break;
     5b4:	80 e0       	ldi	r24, 0x00	; 0
        SET_BIT(state.ledError, L_SPI_ERROR);
        break;
      }
  }
  i = 0;
  while(PIND & (1<<INP_D_CC2500_GDO2))
     5b6:	4b 99       	sbic	0x09, 3	; 9
     5b8:	f4 cf       	rjmp	.-24     	; 0x5a2 <SPI_MasterTransmit+0x42>
    if(++i > 0xfe)
    {
      SET_BIT(state.ledError, L_SPI_ERROR);
      break;
    }
  if(SPSR & (1<<SPIF))
     5ba:	0d b4       	in	r0, 0x2d	; 45
     5bc:	07 fc       	sbrc	r0, 7
    i = SPDR;
     5be:	8e b5       	in	r24, 0x2e	; 46
  do
    SPDR = cData;
     5c0:	9e bd       	out	0x2e, r25	; 46
  while(SPSR & (1 << WCOL));
     5c2:	0d b4       	in	r0, 0x2d	; 45
     5c4:	06 fc       	sbrc	r0, 6
     5c6:	fc cf       	rjmp	.-8      	; 0x5c0 <SPI_MasterTransmit+0x60>
     5c8:	01 c0       	rjmp	.+2      	; 0x5cc <SPI_MasterTransmit+0x6c>
  while(!(SPSR & (1<<SPIF))) NOP();                            /* Wait for transmission complete */
     5ca:	00 00       	nop
     5cc:	0d b4       	in	r0, 0x2d	; 45
     5ce:	07 fe       	sbrs	r0, 7
     5d0:	fc cf       	rjmp	.-8      	; 0x5ca <SPI_MasterTransmit+0x6a>
  return(SPDR);
     5d2:	8e b5       	in	r24, 0x2e	; 46
}
     5d4:	08 95       	ret

000005d6 <cc2500_Off>:

void cc2500_Off(void)
{
  SET_BIT(PORTB, OUT_B_SPI_SS);
     5d6:	2a 9a       	sbi	0x05, 2	; 5
  do
  {
    NOP();
     5d8:	00 00       	nop
  }
  while(!(PINB & (1<<OUT_B_SPI_SS)));
     5da:	1a 9b       	sbis	0x03, 2	; 3
     5dc:	fd cf       	rjmp	.-6      	; 0x5d8 <cc2500_Off+0x2>
}
     5de:	08 95       	ret

000005e0 <setAnt>:
  cc2500WriteReg(CC2500_PKTLEN, sizeof(Telemetrie));
}*/

void setAnt(bool ant)
{
  if(ant)
     5e0:	88 23       	and	r24, r24
     5e2:	29 f0       	breq	.+10     	; 0x5ee <setAnt+0xe>
  {
    RES_BIT(PORTD, OUT_D_ANT2);
     5e4:	5f 98       	cbi	0x0b, 7	; 11
    SET_BIT(PORTD, OUT_D_ANT1);
     5e6:	5e 9a       	sbi	0x0b, 6	; 11
    state.actAnt = false;
     5e8:	10 92 9a 01 	sts	0x019A, r1
     5ec:	08 95       	ret
  }
  else
  {
    RES_BIT(PORTD, OUT_D_ANT1);
     5ee:	5e 98       	cbi	0x0b, 6	; 11
    SET_BIT(PORTD, OUT_D_ANT2);
     5f0:	5f 9a       	sbi	0x0b, 7	; 11
    state.actAnt = true;
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	80 93 9a 01 	sts	0x019A, r24
     5f8:	08 95       	ret

000005fa <setReceiveError>:
  cc2500WriteReg(CC2500_FSCTRL0, pgm_read_byte(&freq[state.actFreqIdx]));
}

void setReceiveError(void)
{
  setAnt(state.actAnt);               // Antenne wechseln
     5fa:	80 91 9a 01 	lds	r24, 0x019A
     5fe:	f0 df       	rcall	.-32     	; 0x5e0 <setAnt>
  if(state.errorCount < 0xff)
     600:	80 91 a3 01 	lds	r24, 0x01A3
     604:	8f 3f       	cpi	r24, 0xFF	; 255
     606:	19 f0       	breq	.+6      	; 0x60e <setReceiveError+0x14>
    ++state.errorCount;
     608:	8f 5f       	subi	r24, 0xFF	; 255
     60a:	80 93 a3 01 	sts	0x01A3, r24
//  if(state.errorSum < 0xffff)
  ++state.errorSum;                 // max über 100 Tage Totalausfall
     60e:	80 91 a5 01 	lds	r24, 0x01A5
     612:	90 91 a6 01 	lds	r25, 0x01A6
     616:	a0 91 a7 01 	lds	r26, 0x01A7
     61a:	b0 91 a8 01 	lds	r27, 0x01A8
     61e:	01 96       	adiw	r24, 0x01	; 1
     620:	a1 1d       	adc	r26, r1
     622:	b1 1d       	adc	r27, r1
     624:	80 93 a5 01 	sts	0x01A5, r24
     628:	90 93 a6 01 	sts	0x01A6, r25
     62c:	a0 93 a7 01 	sts	0x01A7, r26
     630:	b0 93 a8 01 	sts	0x01A8, r27
  if(state.led)
     634:	80 91 96 01 	lds	r24, 0x0196
     638:	81 11       	cpse	r24, r1
    LED_OFF;
     63a:	5c 98       	cbi	0x0b, 4	; 11
     63c:	08 95       	ret

0000063e <getFailSafe>:
  else
    return(false);
}

void getFailSafe(void)          // FailSafe- Werte beim Einschalten als Default übernehmen
{
     63e:	cf 93       	push	r28
     640:	df 93       	push	r29
     642:	30 91 85 01 	lds	r19, 0x0185
     646:	20 91 84 01 	lds	r18, 0x0184
     64a:	a7 e4       	ldi	r26, 0x47	; 71
     64c:	b1 e0       	ldi	r27, 0x01	; 1
     64e:	c4 e7       	ldi	r28, 0x74	; 116
     650:	d1 e0       	ldi	r29, 0x01	; 1
     652:	40 e0       	ldi	r20, 0x00	; 0
  uint8_t i;
  for(i = 0;i < MAXCHAN;++i)
  {
    if(!eeprom.failSafe[i].failSafeMode)        // Nur Kanäle mit Hold oder On
     654:	8c 91       	ld	r24, X
     656:	88 23       	and	r24, r24
     658:	11 f5       	brne	.+68     	; 0x69e <getFailSafe+0x60>
    {
      uint16_t t = eeprom.failSafe[i].failSafePos;
     65a:	11 96       	adiw	r26, 0x01	; 1
     65c:	8d 91       	ld	r24, X+
     65e:	9c 91       	ld	r25, X
     660:	12 97       	sbiw	r26, 0x02	; 2
      if(t & 0x400)                 // Auf zulässige Werte begrenzen
     662:	92 ff       	sbrs	r25, 2
     664:	02 c0       	rjmp	.+4      	; 0x66a <getFailSafe+0x2c>
        t |= 0xf800;
     666:	98 6f       	ori	r25, 0xF8	; 248
     668:	01 c0       	rjmp	.+2      	; 0x66c <getFailSafe+0x2e>
      else
        t &= 0x3ff;
     66a:	93 70       	andi	r25, 0x03	; 3
      output.chan_1us[i] = t;
     66c:	99 83       	std	Y+1, r25	; 0x01
     66e:	88 83       	st	Y, r24
      switch(i)
     670:	e4 2f       	mov	r30, r20
     672:	f0 e0       	ldi	r31, 0x00	; 0
     674:	e8 30       	cpi	r30, 0x08	; 8
     676:	f1 05       	cpc	r31, r1
     678:	90 f4       	brcc	.+36     	; 0x69e <getFailSafe+0x60>
     67a:	e6 5e       	subi	r30, 0xE6	; 230
     67c:	ff 4f       	sbci	r31, 0xFF	; 255
     67e:	09 94       	ijmp
      {
      case 0:
        output.portCflg |= (1 << OUT_C_CHANNEL1);
     680:	21 60       	ori	r18, 0x01	; 1
     682:	0d c0       	rjmp	.+26     	; 0x69e <getFailSafe+0x60>
        break;
      case 1:
        output.portCflg |= (1 << OUT_C_CHANNEL2);
     684:	22 60       	ori	r18, 0x02	; 2
     686:	0b c0       	rjmp	.+22     	; 0x69e <getFailSafe+0x60>
        break;
      case 2:
        output.portCflg |= (1 << OUT_C_CHANNEL3);
     688:	24 60       	ori	r18, 0x04	; 4
     68a:	09 c0       	rjmp	.+18     	; 0x69e <getFailSafe+0x60>
        break;
      case 3:
        output.portCflg |= (1 << OUT_C_CHANNEL4);
     68c:	28 60       	ori	r18, 0x08	; 8
     68e:	07 c0       	rjmp	.+14     	; 0x69e <getFailSafe+0x60>
        break;
      case 4:
        output.portCflg |= (1 << OUT_C_CHANNEL5);
     690:	20 61       	ori	r18, 0x10	; 16
     692:	05 c0       	rjmp	.+10     	; 0x69e <getFailSafe+0x60>
        break;
      case 5:
        output.portCflg |= (1 << OUT_C_CHANNEL6);
     694:	20 62       	ori	r18, 0x20	; 32
     696:	03 c0       	rjmp	.+6      	; 0x69e <getFailSafe+0x60>
        break;
      case 6:
        output.portDflg |= (1 << OUT_D_CHANNEL7);
     698:	31 60       	ori	r19, 0x01	; 1
     69a:	01 c0       	rjmp	.+2      	; 0x69e <getFailSafe+0x60>
        break;
      case 7:
        output.portDflg |= (1 << OUT_D_CHANNEL8);
     69c:	32 60       	ori	r19, 0x02	; 2
}

void getFailSafe(void)          // FailSafe- Werte beim Einschalten als Default übernehmen
{
  uint8_t i;
  for(i = 0;i < MAXCHAN;++i)
     69e:	4f 5f       	subi	r20, 0xFF	; 255
     6a0:	14 96       	adiw	r26, 0x04	; 4
     6a2:	22 96       	adiw	r28, 0x02	; 2
     6a4:	48 30       	cpi	r20, 0x08	; 8
     6a6:	b1 f6       	brne	.-84     	; 0x654 <getFailSafe+0x16>
     6a8:	30 93 85 01 	sts	0x0185, r19
     6ac:	20 93 84 01 	sts	0x0184, r18
        output.portDflg |= (1 << OUT_D_CHANNEL8);
        break;
      }
    }
  }
}
     6b0:	df 91       	pop	r29
     6b2:	cf 91       	pop	r28
     6b4:	08 95       	ret

000006b6 <tstFailSafe>:
  eeprom_write_block(&eeprom.failSafe,(uint8_t *)((int)&eeprom.failSafe - (int)&eeprom) ,sizeof(eeprom.failSafe));
  SET_BIT(state.ledError, L_SET_FAILSAVE);
}

void tstFailSafe(void)                  // Alle 20 ms
{
     6b6:	cf 93       	push	r28
     6b8:	df 93       	push	r29
     6ba:	20 91 ad 01 	lds	r18, 0x01AD
     6be:	30 91 ae 01 	lds	r19, 0x01AE
  uint8_t i;

  for(i = 0;i < 2;++i)
  {
    if(state.groupTimer[i] < 0xff)
     6c2:	80 91 9d 01 	lds	r24, 0x019D
     6c6:	8f 3f       	cpi	r24, 0xFF	; 255
     6c8:	19 f0       	breq	.+6      	; 0x6d0 <tstFailSafe+0x1a>
      ++state.groupTimer[i];            // Zählt Zeit seit letzter Datenaktualisierung (in 20ms Schritten)
     6ca:	8f 5f       	subi	r24, 0xFF	; 255
     6cc:	80 93 9d 01 	sts	0x019D, r24
    if(state.groupTimer[i] == 2)        // 2 = 40ms
     6d0:	80 91 9d 01 	lds	r24, 0x019D
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	31 f4       	brne	.+12     	; 0x6e4 <tstFailSafe+0x2e>
      if(state.frameLost < 0xffff)      // Wenn nach 40ms keine neue Daten -> Frame verloren
     6d8:	8f ef       	ldi	r24, 0xFF	; 255
     6da:	2f 3f       	cpi	r18, 0xFF	; 255
     6dc:	38 07       	cpc	r19, r24
     6de:	11 f0       	breq	.+4      	; 0x6e4 <tstFailSafe+0x2e>
        ++state.frameLost;              // Zählt aber nur einmal, wenn nichts mehr empfangen wird
     6e0:	2f 5f       	subi	r18, 0xFF	; 255
     6e2:	3f 4f       	sbci	r19, 0xFF	; 255
{
  uint8_t i;

  for(i = 0;i < 2;++i)
  {
    if(state.groupTimer[i] < 0xff)
     6e4:	80 91 9e 01 	lds	r24, 0x019E
     6e8:	8f 3f       	cpi	r24, 0xFF	; 255
     6ea:	19 f0       	breq	.+6      	; 0x6f2 <tstFailSafe+0x3c>
      ++state.groupTimer[i];            // Zählt Zeit seit letzter Datenaktualisierung (in 20ms Schritten)
     6ec:	8f 5f       	subi	r24, 0xFF	; 255
     6ee:	80 93 9e 01 	sts	0x019E, r24
    if(state.groupTimer[i] == 2)        // 2 = 40ms
     6f2:	80 91 9e 01 	lds	r24, 0x019E
     6f6:	82 30       	cpi	r24, 0x02	; 2
     6f8:	31 f4       	brne	.+12     	; 0x706 <tstFailSafe+0x50>
      if(state.frameLost < 0xffff)      // Wenn nach 40ms keine neue Daten -> Frame verloren
     6fa:	8f ef       	ldi	r24, 0xFF	; 255
     6fc:	2f 3f       	cpi	r18, 0xFF	; 255
     6fe:	38 07       	cpc	r19, r24
     700:	11 f0       	breq	.+4      	; 0x706 <tstFailSafe+0x50>
        ++state.frameLost;              // Zählt aber nur einmal, wenn nichts mehr empfangen wird
     702:	2f 5f       	subi	r18, 0xFF	; 255
     704:	3f 4f       	sbci	r19, 0xFF	; 255
     706:	30 93 ae 01 	sts	0x01AE, r19
     70a:	20 93 ad 01 	sts	0x01AD, r18
     70e:	a7 e4       	ldi	r26, 0x47	; 71
     710:	b1 e0       	ldi	r27, 0x01	; 1
     712:	c4 e7       	ldi	r28, 0x74	; 116
     714:	d1 e0       	ldi	r29, 0x01	; 1
     716:	40 e0       	ldi	r20, 0x00	; 0
  }

  for(i = 0;i < MAXCHAN;++i)
  {
    if((!eeprom.failSafe[i].failSafeMode)                       // On oder Hold
     718:	8c 91       	ld	r24, X
     71a:	88 23       	and	r24, r24
     71c:	f1 f4       	brne	.+60     	; 0x75a <tstFailSafe+0xa4>
     71e:	13 96       	adiw	r26, 0x03	; 3
     720:	5c 91       	ld	r21, X
     722:	13 97       	sbiw	r26, 0x03	; 3
     724:	e4 2f       	mov	r30, r20
     726:	e6 95       	lsr	r30
     728:	e6 95       	lsr	r30
     72a:	f0 e0       	ldi	r31, 0x00	; 0
     72c:	eb 56       	subi	r30, 0x6B	; 107
     72e:	fe 4f       	sbci	r31, 0xFE	; 254
     730:	20 85       	ldd	r18, Z+8	; 0x08
     732:	30 e0       	ldi	r19, 0x00	; 0
     734:	85 2f       	mov	r24, r21
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	01 96       	adiw	r24, 0x01	; 1
     73a:	82 17       	cp	r24, r18
     73c:	93 07       	cpc	r25, r19
     73e:	6c f4       	brge	.+26     	; 0x75a <tstFailSafe+0xa4>
     740:	5f 3f       	cpi	r21, 0xFF	; 255
     742:	59 f0       	breq	.+22     	; 0x75a <tstFailSafe+0xa4>
      && (state.groupTimer[i / 4] > eeprom.failSafe[i].failSafeDelay + 1)  // Zeit abgelaufen
      && (eeprom.failSafe[i].failSafeDelay != 0xff))      // kein Hold
    {
      uint16_t t = eeprom.failSafe[i].failSafePos;
     744:	11 96       	adiw	r26, 0x01	; 1
     746:	8d 91       	ld	r24, X+
     748:	9c 91       	ld	r25, X
     74a:	12 97       	sbiw	r26, 0x02	; 2
      if(t & 0x400)                 // Auf zulässige Werte begrenzen
     74c:	92 ff       	sbrs	r25, 2
     74e:	02 c0       	rjmp	.+4      	; 0x754 <tstFailSafe+0x9e>
        t |= 0xf800;
     750:	98 6f       	ori	r25, 0xF8	; 248
     752:	01 c0       	rjmp	.+2      	; 0x756 <tstFailSafe+0xa0>
      else
        t &= 0x3ff;
     754:	93 70       	andi	r25, 0x03	; 3
      output.chan_1us[i] = t;
     756:	99 83       	std	Y+1, r25	; 0x01
     758:	88 83       	st	Y, r24
    if(state.groupTimer[i] == 2)        // 2 = 40ms
      if(state.frameLost < 0xffff)      // Wenn nach 40ms keine neue Daten -> Frame verloren
        ++state.frameLost;              // Zählt aber nur einmal, wenn nichts mehr empfangen wird
  }

  for(i = 0;i < MAXCHAN;++i)
     75a:	4f 5f       	subi	r20, 0xFF	; 255
     75c:	14 96       	adiw	r26, 0x04	; 4
     75e:	22 96       	adiw	r28, 0x02	; 2
     760:	48 30       	cpi	r20, 0x08	; 8
     762:	d1 f6       	brne	.-76     	; 0x718 <tstFailSafe+0x62>
      else
        t &= 0x3ff;
      output.chan_1us[i] = t;
    }
  }
}
     764:	df 91       	pop	r29
     766:	cf 91       	pop	r28
     768:	08 95       	ret

0000076a <copyChan>:

volatile uint16_t xy;

void copyChan(Message *mes, uint8_t x)
{
     76a:	0f 93       	push	r16
     76c:	1f 93       	push	r17
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
     772:	ec 01       	movw	r28, r24
  uint8_t i;
  uint16_t high = mes->data.channel.chan_1ushigh;
     774:	4c 81       	ldd	r20, Y+4	; 0x04
     776:	8d 81       	ldd	r24, Y+5	; 0x05
     778:	58 2f       	mov	r21, r24
     77a:	5f 70       	andi	r21, 0x0F	; 15
     77c:	73 e0       	ldi	r23, 0x03	; 3
  {
    uint8_t f = (uint8_t)high & 7;
    uint16_t val = (f << 8) + mes->data.channel.chan_1uslow[i];
    if(val & 0x400)
      val |= 0xf800;              // erweitern auf 16 Bit
    output.chan_1us[i + x] = val;
     77e:	06 2f       	mov	r16, r22
     780:	10 e0       	ldi	r17, 0x00	; 0

  i = 3;
  do
  {
    uint8_t f = (uint8_t)high & 7;
    uint16_t val = (f << 8) + mes->data.channel.chan_1uslow[i];
     782:	a7 2f       	mov	r26, r23
     784:	b0 e0       	ldi	r27, 0x00	; 0
     786:	84 2f       	mov	r24, r20
     788:	87 70       	andi	r24, 0x07	; 7
     78a:	90 e0       	ldi	r25, 0x00	; 0
     78c:	38 2f       	mov	r19, r24
     78e:	22 27       	eor	r18, r18
     790:	fe 01       	movw	r30, r28
     792:	ea 0f       	add	r30, r26
     794:	fb 1f       	adc	r31, r27
     796:	80 81       	ld	r24, Z
     798:	28 0f       	add	r18, r24
     79a:	31 1d       	adc	r19, r1
    if(val & 0x400)
     79c:	32 fd       	sbrc	r19, 2
      val |= 0xf800;              // erweitern auf 16 Bit
     79e:	38 6f       	ori	r19, 0xF8	; 248
    output.chan_1us[i + x] = val;
     7a0:	a0 0f       	add	r26, r16
     7a2:	b1 1f       	adc	r27, r17
     7a4:	aa 0f       	add	r26, r26
     7a6:	bb 1f       	adc	r27, r27
     7a8:	ac 58       	subi	r26, 0x8C	; 140
     7aa:	be 4f       	sbci	r27, 0xFE	; 254
     7ac:	2d 93       	st	X+, r18
     7ae:	3c 93       	st	X, r19
    high >>= 3;
  }
  while(i-- > 0);
     7b0:	77 23       	and	r23, r23
     7b2:	39 f0       	breq	.+14     	; 0x7c2 <copyChan+0x58>
    uint8_t f = (uint8_t)high & 7;
    uint16_t val = (f << 8) + mes->data.channel.chan_1uslow[i];
    if(val & 0x400)
      val |= 0xf800;              // erweitern auf 16 Bit
    output.chan_1us[i + x] = val;
    high >>= 3;
     7b4:	63 e0       	ldi	r22, 0x03	; 3
     7b6:	56 95       	lsr	r21
     7b8:	47 95       	ror	r20
     7ba:	6a 95       	dec	r22
     7bc:	e1 f7       	brne	.-8      	; 0x7b6 <copyChan+0x4c>
  }
  while(i-- > 0);
     7be:	71 50       	subi	r23, 0x01	; 1
     7c0:	e0 cf       	rjmp	.-64     	; 0x782 <copyChan+0x18>
}
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	1f 91       	pop	r17
     7c8:	0f 91       	pop	r16
     7ca:	08 95       	ret

000007cc <checkId>:
  }
}

bool checkId(void)
{
  return (eeprom.bind.id && (eeprom.bind.id != 0xffff) &&
     7cc:	80 91 44 01 	lds	r24, 0x0144
     7d0:	90 91 45 01 	lds	r25, 0x0145
     7d4:	01 97       	sbiw	r24, 0x01	; 1
     7d6:	8e 5f       	subi	r24, 0xFE	; 254
     7d8:	9f 4f       	sbci	r25, 0xFF	; 255
     7da:	60 f4       	brcc	.+24     	; 0x7f4 <checkId+0x28>
     7dc:	80 91 46 01 	lds	r24, 0x0146
     7e0:	85 30       	cpi	r24, 0x05	; 5
     7e2:	40 f0       	brcs	.+16     	; 0x7f4 <checkId+0x28>
     7e4:	90 e0       	ldi	r25, 0x00	; 0
     7e6:	8d 35       	cpi	r24, 0x5D	; 93
     7e8:	08 f0       	brcs	.+2      	; 0x7ec <checkId+0x20>
     7ea:	91 e0       	ldi	r25, 0x01	; 1
     7ec:	81 e0       	ldi	r24, 0x01	; 1
     7ee:	98 27       	eor	r25, r24
     7f0:	89 2f       	mov	r24, r25
     7f2:	08 95       	ret
     7f4:	80 e0       	ldi	r24, 0x00	; 0
     7f6:	90 e0       	ldi	r25, 0x00	; 0
         (eeprom.bind.step > 4) && (eeprom.bind.step < MAXHOPPCHAN / 2 - 4));
}
     7f8:	08 95       	ret

000007fa <checkKey>:

bool checkKey(void)
{
  return (!(PIND & (1 << INP_D_KEY)));
     7fa:	89 b1       	in	r24, 0x09	; 9
     7fc:	82 95       	swap	r24
     7fe:	86 95       	lsr	r24
     800:	87 70       	andi	r24, 0x07	; 7
     802:	80 95       	com	r24
}
     804:	81 70       	andi	r24, 0x01	; 1
     806:	08 95       	ret

00000808 <set_led>:
void set_led(void)
{
  static uint8_t timer_alt;
  static uint8_t led_count;

  int8_t diff = ((uint8_t)Timer25ms) - timer_alt;
     808:	80 91 93 01 	lds	r24, 0x0193
     80c:	90 91 94 01 	lds	r25, 0x0194
  if(diff > (1000 / 4 / 25))
     810:	20 91 05 01 	lds	r18, 0x0105
     814:	82 1b       	sub	r24, r18
     816:	8b 30       	cpi	r24, 0x0B	; 11
     818:	0c f4       	brge	.+2      	; 0x81c <set_led+0x14>
     81a:	4b c0       	rjmp	.+150    	; 0x8b2 <set_led+0xaa>
  {
    timer_alt = (uint8_t)Timer25ms;
     81c:	80 91 93 01 	lds	r24, 0x0193
     820:	90 91 94 01 	lds	r25, 0x0194
     824:	38 2f       	mov	r19, r24
     826:	80 93 05 01 	sts	0x0105, r24

    if(!(led_count & 0xf))            // unteres Nibble 0 (Blinkzähler)
     82a:	20 91 04 01 	lds	r18, 0x0104
     82e:	82 2f       	mov	r24, r18
     830:	90 e0       	ldi	r25, 0x00	; 0
     832:	8f 70       	andi	r24, 0x0F	; 15
     834:	90 70       	andi	r25, 0x00	; 0
     836:	89 2b       	or	r24, r25
     838:	e9 f4       	brne	.+58     	; 0x874 <set_led+0x6c>
    {
      uint8_t ledtemp;
      if((ledtemp = state.ledError))
     83a:	80 91 a2 01 	lds	r24, 0x01A2
     83e:	88 23       	and	r24, r24
     840:	51 f1       	breq	.+84     	; 0x896 <set_led+0x8e>
      {
        while(1)
        {
          led_count += 0x10;
          led_count &= 0x7f;
          if(ledtemp & (1 << (led_count >> 4)))
     842:	48 2f       	mov	r20, r24
     844:	50 e0       	ldi	r21, 0x00	; 0
      uint8_t ledtemp;
      if((ledtemp = state.ledError))
      {
        while(1)
        {
          led_count += 0x10;
     846:	20 5f       	subi	r18, 0xF0	; 240
          led_count &= 0x7f;
     848:	2f 77       	andi	r18, 0x7F	; 127
          if(ledtemp & (1 << (led_count >> 4)))
     84a:	82 2f       	mov	r24, r18
     84c:	82 95       	swap	r24
     84e:	8f 70       	andi	r24, 0x0F	; 15
     850:	ba 01       	movw	r22, r20
     852:	02 c0       	rjmp	.+4      	; 0x858 <set_led+0x50>
     854:	75 95       	asr	r23
     856:	67 95       	ror	r22
     858:	8a 95       	dec	r24
     85a:	e2 f7       	brpl	.-8      	; 0x854 <set_led+0x4c>
     85c:	60 ff       	sbrs	r22, 0
     85e:	f3 cf       	rjmp	.-26     	; 0x846 <set_led+0x3e>
          {
            led_count |= (led_count >> 3) | 1;      // Blinkzähler setzen
     860:	82 2f       	mov	r24, r18
     862:	86 95       	lsr	r24
     864:	86 95       	lsr	r24
     866:	86 95       	lsr	r24
     868:	21 60       	ori	r18, 0x01	; 1
     86a:	82 2b       	or	r24, r18
     86c:	80 93 04 01 	sts	0x0104, r24
            LED_ON;
     870:	5c 9a       	sbi	0x0b, 4	; 11
     872:	11 c0       	rjmp	.+34     	; 0x896 <set_led+0x8e>
        }
      }
    }
    else
    {
      --led_count;
     874:	82 2f       	mov	r24, r18
     876:	81 50       	subi	r24, 0x01	; 1
     878:	80 93 04 01 	sts	0x0104, r24
      if(led_count & 1)
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	80 ff       	sbrs	r24, 0
     880:	02 c0       	rjmp	.+4      	; 0x886 <set_led+0x7e>
        LED_ON;
     882:	5c 9a       	sbi	0x0b, 4	; 11
     884:	01 c0       	rjmp	.+2      	; 0x888 <set_led+0x80>
      else
        LED_OFF;
     886:	5c 98       	cbi	0x0b, 4	; 11
      if(!(led_count & 0xf))
     888:	8f 70       	andi	r24, 0x0F	; 15
     88a:	90 70       	andi	r25, 0x00	; 0
     88c:	89 2b       	or	r24, r25
     88e:	19 f4       	brne	.+6      	; 0x896 <set_led+0x8e>
        timer_alt += (1000 / 4 / 25 * 3);                    // Pause
     890:	32 5e       	subi	r19, 0xE2	; 226
     892:	30 93 05 01 	sts	0x0105, r19
    }
    if(!(led_count & 0xf) && !state.ledError)
     896:	80 91 04 01 	lds	r24, 0x0104
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	8f 70       	andi	r24, 0x0F	; 15
     89e:	90 70       	andi	r25, 0x00	; 0
     8a0:	89 2b       	or	r24, r25
     8a2:	39 f4       	brne	.+14     	; 0x8b2 <set_led+0xaa>
     8a4:	80 91 a2 01 	lds	r24, 0x01A2
     8a8:	88 23       	and	r24, r24
     8aa:	19 f4       	brne	.+6      	; 0x8b2 <set_led+0xaa>
      state.led = true;
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	80 93 96 01 	sts	0x0196, r24
  }
  if(state.led && state.ledError)
     8b2:	80 91 96 01 	lds	r24, 0x0196
     8b6:	88 23       	and	r24, r24
     8b8:	39 f0       	breq	.+14     	; 0x8c8 <set_led+0xc0>
     8ba:	80 91 a2 01 	lds	r24, 0x01A2
     8be:	88 23       	and	r24, r24
     8c0:	19 f0       	breq	.+6      	; 0x8c8 <set_led+0xc0>
  {
    state.led = false;
     8c2:	10 92 96 01 	sts	0x0196, r1
    LED_OFF;
     8c6:	5c 98       	cbi	0x0b, 4	; 11
     8c8:	08 95       	ret

000008ca <setTimer>:
  }
}

void setTimer(uint8_t value)
{
  OCR2A = value;
     8ca:	80 93 b3 00 	sts	0x00B3, r24
//  SET_BIT(TIFR2, OCF2A);
  TIFR2 = (1 << OCF2A);
     8ce:	82 e0       	ldi	r24, 0x02	; 2
     8d0:	87 bb       	out	0x17, r24	; 23
}
     8d2:	08 95       	ret

000008d4 <adjTimer>:

void adjTimer(void)
{
  uint8_t temp = -state.RxTimer;
     8d4:	80 91 97 01 	lds	r24, 0x0197
  TCNT2 += temp;            // Timer initialisieren
     8d8:	90 91 b2 00 	lds	r25, 0x00B2
     8dc:	98 1b       	sub	r25, r24
     8de:	90 93 b2 00 	sts	0x00B2, r25

  int8_t te = state.RxTimer;
     8e2:	90 91 97 01 	lds	r25, 0x0197
  if(te > state.max)
     8e6:	80 91 b0 01 	lds	r24, 0x01B0
     8ea:	89 17       	cp	r24, r25
     8ec:	14 f4       	brge	.+4      	; 0x8f2 <adjTimer+0x1e>
    state.max = te;
     8ee:	90 93 b0 01 	sts	0x01B0, r25
  if(te < state.min)
     8f2:	80 91 af 01 	lds	r24, 0x01AF
     8f6:	98 17       	cp	r25, r24
     8f8:	14 f4       	brge	.+4      	; 0x8fe <adjTimer+0x2a>
    state.min = te;
     8fa:	90 93 af 01 	sts	0x01AF, r25
  if(checkKey())
     8fe:	7d df       	rcall	.-262    	; 0x7fa <checkKey>
     900:	88 23       	and	r24, r24
     902:	31 f0       	breq	.+12     	; 0x910 <adjTimer+0x3c>
  {
    state.min = 0x7f;
     904:	8f e7       	ldi	r24, 0x7F	; 127
     906:	80 93 af 01 	sts	0x01AF, r24
    state.max = -0x80;
     90a:	80 e8       	ldi	r24, 0x80	; 128
     90c:	80 93 b0 01 	sts	0x01B0, r24
  }

  state.RxTimer = 0;
     910:	10 92 97 01 	sts	0x0197, r1
//  else
//    if(state.pll < 127)
//      ++state.pll;
//    else
//      NOP();
}
     914:	08 95       	ret

00000916 <checkPulses>:
    break;
  }
}

void checkPulses(void)
{
     916:	cf 93       	push	r28
     918:	df 93       	push	r29
     91a:	20 91 85 01 	lds	r18, 0x0185
     91e:	90 91 84 01 	lds	r25, 0x0184
     922:	a7 e8       	ldi	r26, 0x87	; 135
     924:	b1 e0       	ldi	r27, 0x01	; 1
     926:	c7 e4       	ldi	r28, 0x47	; 71
     928:	d1 e0       	ldi	r29, 0x01	; 1
     92a:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t i;

  for(i = 0;i < MAXCHAN;++i)
  {
    ++output.pulsesTimer[i];
     92c:	8c 91       	ld	r24, X
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	8c 93       	st	X, r24
    if(output.pulsesTimer[i] > 25)           // Spätestens nach 25 ms Servos ansteuern
     932:	8a 31       	cpi	r24, 0x1A	; 26
     934:	d0 f0       	brcs	.+52     	; 0x96a <checkPulses+0x54>
    {
      if(!eeprom.failSafe[i].failSafeMode)
     936:	88 81       	ld	r24, Y
     938:	88 23       	and	r24, r24
     93a:	b9 f4       	brne	.+46     	; 0x96a <checkPulses+0x54>
      {
        switch(i)
     93c:	e3 2f       	mov	r30, r19
     93e:	f0 e0       	ldi	r31, 0x00	; 0
     940:	e8 30       	cpi	r30, 0x08	; 8
     942:	f1 05       	cpc	r31, r1
     944:	90 f4       	brcc	.+36     	; 0x96a <checkPulses+0x54>
     946:	ee 5d       	subi	r30, 0xDE	; 222
     948:	ff 4f       	sbci	r31, 0xFF	; 255
     94a:	09 94       	ijmp
        {
        case 0:
          output.portCflg |= (1 << OUT_C_CHANNEL1);
     94c:	91 60       	ori	r25, 0x01	; 1
     94e:	0d c0       	rjmp	.+26     	; 0x96a <checkPulses+0x54>
          break;
        case 1:
          output.portCflg |= (1 << OUT_C_CHANNEL2);
     950:	92 60       	ori	r25, 0x02	; 2
     952:	0b c0       	rjmp	.+22     	; 0x96a <checkPulses+0x54>
          break;
        case 2:
          output.portCflg |= (1 << OUT_C_CHANNEL3);
     954:	94 60       	ori	r25, 0x04	; 4
     956:	09 c0       	rjmp	.+18     	; 0x96a <checkPulses+0x54>
          break;
        case 3:
          output.portCflg |= (1 << OUT_C_CHANNEL4);
     958:	98 60       	ori	r25, 0x08	; 8
     95a:	07 c0       	rjmp	.+14     	; 0x96a <checkPulses+0x54>
          break;
        case 4:
          output.portCflg |= (1 << OUT_C_CHANNEL5);
     95c:	90 61       	ori	r25, 0x10	; 16
     95e:	05 c0       	rjmp	.+10     	; 0x96a <checkPulses+0x54>
          break;
        case 5:
          output.portCflg |= (1 << OUT_C_CHANNEL6);
     960:	90 62       	ori	r25, 0x20	; 32
     962:	03 c0       	rjmp	.+6      	; 0x96a <checkPulses+0x54>
          break;
        case 6:
          output.portDflg |= (1 << OUT_D_CHANNEL7);
     964:	21 60       	ori	r18, 0x01	; 1
     966:	01 c0       	rjmp	.+2      	; 0x96a <checkPulses+0x54>
          break;
        case 7:
          output.portDflg |= (1 << OUT_D_CHANNEL8);
     968:	22 60       	ori	r18, 0x02	; 2

void checkPulses(void)
{
  uint8_t i;

  for(i = 0;i < MAXCHAN;++i)
     96a:	3f 5f       	subi	r19, 0xFF	; 255
     96c:	11 96       	adiw	r26, 0x01	; 1
     96e:	24 96       	adiw	r28, 0x04	; 4
     970:	38 30       	cpi	r19, 0x08	; 8
     972:	e1 f6       	brne	.-72     	; 0x92c <checkPulses+0x16>
     974:	20 93 85 01 	sts	0x0185, r18
     978:	90 93 84 01 	sts	0x0184, r25
          break;
        }
      }
    }
  }
}
     97c:	df 91       	pop	r29
     97e:	cf 91       	pop	r28
     980:	08 95       	ret

00000982 <setBindMode>:
//      NOP();
}

void setBindMode(void)
{
  cc2500WriteReg(CC2500_SYNC0, (unsigned char)BINDMODEID);
     982:	85 e0       	ldi	r24, 0x05	; 5
     984:	69 e0       	ldi	r22, 0x09	; 9
     986:	e0 d4       	rcall	.+2496   	; 0x1348 <cc2500WriteReg>
  cc2500WriteReg(CC2500_SYNC1, (unsigned char)(BINDMODEID >> 8));
     988:	84 e0       	ldi	r24, 0x04	; 4
     98a:	60 e1       	ldi	r22, 0x10	; 16
     98c:	dd d4       	rcall	.+2490   	; 0x1348 <cc2500WriteReg>
  cc2500WriteReg(CC2500_PKTLEN, sizeof(BindData));
     98e:	86 e0       	ldi	r24, 0x06	; 6
     990:	63 e0       	ldi	r22, 0x03	; 3
     992:	da d4       	rcall	.+2484   	; 0x1348 <cc2500WriteReg>
  cc2500WriteReg(CC2500_AGCCTRL2, 0xfb);              // Empfindlichkeit reduzieren
     994:	8b e1       	ldi	r24, 0x1B	; 27
     996:	6b ef       	ldi	r22, 0xFB	; 251
     998:	d7 d4       	rcall	.+2478   	; 0x1348 <cc2500WriteReg>

  SET_BIT(state.ledError, L_BIND_ON);
     99a:	80 91 a2 01 	lds	r24, 0x01A2
     99e:	82 60       	ori	r24, 0x02	; 2
     9a0:	80 93 a2 01 	sts	0x01A2, r24
  eeprom.bind.step = BINDMODESTEP;
     9a4:	80 e4       	ldi	r24, 0x40	; 64
     9a6:	80 93 46 01 	sts	0x0146, r24
}
     9aa:	08 95       	ret

000009ac <setNewRxFrequ>:

prog_int8_t APM freq[] = {0, 40, -40, 120, -120, 80, -80};

void setNewRxFrequ(void)
{
  setAnt(state.actAnt);               // Antenne wechseln
     9ac:	80 91 9a 01 	lds	r24, 0x019A
     9b0:	17 de       	rcall	.-978    	; 0x5e0 <setAnt>
  if(++state.actFreqIdx >= 7)
     9b2:	80 91 9b 01 	lds	r24, 0x019B
     9b6:	8f 5f       	subi	r24, 0xFF	; 255
     9b8:	80 93 9b 01 	sts	0x019B, r24
     9bc:	87 30       	cpi	r24, 0x07	; 7
     9be:	10 f0       	brcs	.+4      	; 0x9c4 <setNewRxFrequ+0x18>
    state.actFreqIdx = 0;
     9c0:	10 92 9b 01 	sts	0x019B, r1
  state.freqOffset = pgm_read_byte(&freq[state.actFreqIdx]);
     9c4:	e0 91 9b 01 	lds	r30, 0x019B
     9c8:	f0 e0       	ldi	r31, 0x00	; 0
     9ca:	ec 5a       	subi	r30, 0xAC	; 172
     9cc:	ff 4f       	sbci	r31, 0xFF	; 255
     9ce:	e4 91       	lpm	r30, Z+
     9d0:	e0 93 9c 01 	sts	0x019C, r30
  cc2500WriteReg(CC2500_FSCTRL0, pgm_read_byte(&freq[state.actFreqIdx]));
     9d4:	8c e0       	ldi	r24, 0x0C	; 12
     9d6:	6e 2f       	mov	r22, r30
     9d8:	b7 d4       	rcall	.+2414   	; 0x1348 <cc2500WriteReg>
}
     9da:	08 95       	ret

000009dc <setFrequencyOffset>:
{
  int16_t freq;

//  freqoff = cc2500ReadStatusReg(CC2500_FREQEST);
//  cc2500_Off();
  if(freqoff)
     9dc:	88 23       	and	r24, r24
     9de:	09 f1       	breq	.+66     	; 0xa22 <setFrequencyOffset+0x46>
  {
    if(lim)
     9e0:	66 23       	and	r22, r22
     9e2:	29 f0       	breq	.+10     	; 0x9ee <setFrequencyOffset+0x12>
     9e4:	87 fd       	sbrc	r24, 7
     9e6:	8f ef       	ldi	r24, 0xFF	; 255
     9e8:	18 16       	cp	r1, r24
     9ea:	0c f4       	brge	.+2      	; 0x9ee <setFrequencyOffset+0x12>
     9ec:	81 e0       	ldi	r24, 0x01	; 1
      else if(freqoff < -1)
        freqoff = -1;
    }
//    fsctrl = cc2500ReadReg(CC2500_FSCTRL0);
//    freq = freqoff + fsctrl;
    freq = freqoff + state.freqOffset;
     9ee:	68 2f       	mov	r22, r24
     9f0:	77 27       	eor	r23, r23
     9f2:	67 fd       	sbrc	r22, 7
     9f4:	70 95       	com	r23
     9f6:	80 91 9c 01 	lds	r24, 0x019C
     9fa:	99 27       	eor	r25, r25
     9fc:	87 fd       	sbrc	r24, 7
     9fe:	90 95       	com	r25
     a00:	68 0f       	add	r22, r24
     a02:	79 1f       	adc	r23, r25
     a04:	8f ef       	ldi	r24, 0xFF	; 255
     a06:	60 38       	cpi	r22, 0x80	; 128
     a08:	78 07       	cpc	r23, r24
     a0a:	14 f4       	brge	.+4      	; 0xa10 <setFrequencyOffset+0x34>
     a0c:	60 e8       	ldi	r22, 0x80	; 128
     a0e:	7f ef       	ldi	r23, 0xFF	; 255
     a10:	60 38       	cpi	r22, 0x80	; 128
     a12:	71 05       	cpc	r23, r1
     a14:	14 f0       	brlt	.+4      	; 0xa1a <setFrequencyOffset+0x3e>
     a16:	6f e7       	ldi	r22, 0x7F	; 127
     a18:	70 e0       	ldi	r23, 0x00	; 0
    if(freq > 0x7f)
      freq = 0x7f;
    else if(freq < -0x80)
      freq = -0x80;
    state.freqOffset = freq;
     a1a:	60 93 9c 01 	sts	0x019C, r22
    cc2500WriteReg(CC2500_FSCTRL0, (int8_t)freq);
     a1e:	8c e0       	ldi	r24, 0x0C	; 12
     a20:	93 d4       	rcall	.+2342   	; 0x1348 <cc2500WriteReg>
     a22:	08 95       	ret

00000a24 <checkchanFree>:
}

bool checkchanFree(void)            // False: Kanal frei
{
//  if(SPI_MasterReadReg(CC2500_PKTSTATUS | CC2500_READ_BURST) & 0x10)
  int8_t rssi = cc2500ReadStatusReg(CC2500_RSSI);
     a24:	84 e3       	ldi	r24, 0x34	; 52
     a26:	98 d4       	rcall	.+2352   	; 0x1358 <cc2500ReadStatusReg>
//  cc2500_Off();
  return(rssi < 0);         // Offset mit ca. 70 entspricht also -70dbm
}
     a28:	88 1f       	adc	r24, r24
     a2a:	88 27       	eor	r24, r24
     a2c:	88 1f       	adc	r24, r24
     a2e:	08 95       	ret

00000a30 <setRx>:
//  cc2500WriteRegCheckIdle(CC2500_CHANNR, tempChan);
//}

void setRx(void)
{
  SET_BIT(PORTB, OUT_B_PRE);
     a30:	28 9a       	sbi	0x05, 0	; 5
  cc2500CommandStrobe(CC2500_SRX);       // Emfänger ein
     a32:	84 e3       	ldi	r24, 0x34	; 52
     a34:	b5 d4       	rcall	.+2410   	; 0x13a0 <cc2500CommandStrobe>
//  SET_BIT(EIFR, INTF0);
//  SET_BIT(EIMSK, INT0);                    // INT0 ein
//  Timercapt = 0;
}
     a36:	08 95       	ret

00000a38 <setFreeChanRx>:
//  cc2500_Off();
  return(rssi < 0);         // Offset mit ca. 70 entspricht also -70dbm
}

void setFreeChanRx(void)            // Nächsten Kanal einstellen um zu sehen, ob er belegt ist
{
     a38:	cf 93       	push	r28
     a3a:	df 93       	push	r29
  uint16_t tempChan = state.actChan + 3;
     a3c:	80 91 99 01 	lds	r24, 0x0199
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	ec 01       	movw	r28, r24
     a44:	23 96       	adiw	r28, 0x03	; 3
  if(tempChan > MAXHOPPCHAN)
     a46:	c4 3c       	cpi	r28, 0xC4	; 196
     a48:	d1 05       	cpc	r29, r1
     a4a:	18 f0       	brcs	.+6      	; 0xa52 <setFreeChanRx+0x1a>
    tempChan -= (MAXHOPPCHAN + 1);
     a4c:	ec 01       	movw	r28, r24
     a4e:	c1 5c       	subi	r28, 0xC1	; 193
     a50:	d0 40       	sbci	r29, 0x00	; 0
//  cc2500Idle();
  cc2500WriteReg(CC2500_CHANNR, tempChan);
     a52:	8a e0       	ldi	r24, 0x0A	; 10
     a54:	6c 2f       	mov	r22, r28
     a56:	78 d4       	rcall	.+2288   	; 0x1348 <cc2500WriteReg>
  setRx();
     a58:	eb df       	rcall	.-42     	; 0xa30 <setRx>
//  SET_BIT(PORTB, OUT_B_PRE);
//  cc2500CommandStrobe(CC2500_SRX);
  state.actChan = tempChan;
     a5a:	c0 93 99 01 	sts	0x0199, r28
}
     a5e:	df 91       	pop	r29
     a60:	cf 91       	pop	r28
     a62:	08 95       	ret

00000a64 <sendTelemetrie>:
void sendTelemetrie(void)  // wird etwas später gesendet, + 0,5ms
{
  static Telemetrie mes;

//  setNextChanCheckIdle();
  RES_BIT(EIMSK, INT0);                    // INT0 aus
     a64:	e8 98       	cbi	0x1d, 0	; 29

  cc2500CommandStrobe(CC2500_SFTX);             // Sendepuffer leeren
     a66:	8b e3       	ldi	r24, 0x3B	; 59
     a68:	9b d4       	rcall	.+2358   	; 0x13a0 <cc2500CommandStrobe>
  if(read != write)
     a6a:	20 91 c7 01 	lds	r18, 0x01C7
     a6e:	80 91 c6 01 	lds	r24, 0x01C6
     a72:	28 17       	cp	r18, r24
     a74:	69 f1       	breq	.+90     	; 0xad0 <sendTelemetrie+0x6c>
  {
    mes.Unspec.dataB1 = telemetrieBuf[read].Unspec.dataB1;
     a76:	82 2f       	mov	r24, r18
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	fc 01       	movw	r30, r24
     a7c:	ee 0f       	add	r30, r30
     a7e:	ff 1f       	adc	r31, r31
     a80:	e8 0f       	add	r30, r24
     a82:	f9 1f       	adc	r31, r25
     a84:	ee 0f       	add	r30, r30
     a86:	ff 1f       	adc	r31, r31
     a88:	df 01       	movw	r26, r30
     a8a:	ac 5e       	subi	r26, 0xEC	; 236
     a8c:	be 4f       	sbci	r27, 0xFE	; 254
     a8e:	15 96       	adiw	r26, 0x05	; 5
     a90:	8c 91       	ld	r24, X
     a92:	15 97       	sbiw	r26, 0x05	; 5
     a94:	80 93 0b 01 	sts	0x010B, r24
    mes.Unspec.dataB2 = telemetrieBuf[read].Unspec.dataB2;
     a98:	14 96       	adiw	r26, 0x04	; 4
     a9a:	8c 91       	ld	r24, X
     a9c:	14 97       	sbiw	r26, 0x04	; 4
     a9e:	80 93 0a 01 	sts	0x010A, r24
    mes.Unspec.dataB3 = telemetrieBuf[read].Unspec.dataB3;
     aa2:	13 96       	adiw	r26, 0x03	; 3
     aa4:	8c 91       	ld	r24, X
     aa6:	13 97       	sbiw	r26, 0x03	; 3
     aa8:	80 93 09 01 	sts	0x0109, r24
    mes.Unspec.dataB4 = telemetrieBuf[read].Unspec.dataB4;
     aac:	ea 5e       	subi	r30, 0xEA	; 234
     aae:	fe 4f       	sbci	r31, 0xFE	; 254
     ab0:	80 81       	ld	r24, Z
     ab2:	80 93 08 01 	sts	0x0108, r24
    mes.Unspec.dataB5 = telemetrieBuf[read].Unspec.dataB5;
     ab6:	11 96       	adiw	r26, 0x01	; 1
     ab8:	8c 91       	ld	r24, X
     aba:	11 97       	sbiw	r26, 0x01	; 1
     abc:	80 93 07 01 	sts	0x0107, r24
    mes.Unspec.dataB6 = telemetrieBuf[read].Unspec.dataB6;
     ac0:	8c 91       	ld	r24, X
     ac2:	80 93 06 01 	sts	0x0106, r24
    ++read;
     ac6:	2f 5f       	subi	r18, 0xFF	; 255
    read &= 0x7;
     ac8:	27 70       	andi	r18, 0x07	; 7
     aca:	20 93 c7 01 	sts	0x01C7, r18
     ace:	2c c0       	rjmp	.+88     	; 0xb28 <sendTelemetrie+0xc4>
  }
  else                                        // Status senden
  {
    mes.StatusRx.type = 1;
     ad0:	80 91 0b 01 	lds	r24, 0x010B
     ad4:	8f 70       	andi	r24, 0x0F	; 15
     ad6:	80 61       	ori	r24, 0x10	; 16
     ad8:	80 93 0b 01 	sts	0x010B, r24
    mes.StatusRx.scanCount = state.scanCount;
     adc:	80 91 a4 01 	lds	r24, 0x01A4
     ae0:	80 93 0a 01 	sts	0x010A, r24
    if(state.errorSum >> 16)
     ae4:	20 91 a5 01 	lds	r18, 0x01A5
     ae8:	30 91 a6 01 	lds	r19, 0x01A6
     aec:	40 91 a7 01 	lds	r20, 0x01A7
     af0:	50 91 a8 01 	lds	r21, 0x01A8
     af4:	ca 01       	movw	r24, r20
     af6:	aa 27       	eor	r26, r26
     af8:	bb 27       	eor	r27, r27
     afa:	00 97       	sbiw	r24, 0x00	; 0
     afc:	a1 05       	cpc	r26, r1
     afe:	b1 05       	cpc	r27, r1
     b00:	39 f0       	breq	.+14     	; 0xb10 <sendTelemetrie+0xac>
      mes.StatusRx.errorSum = 0xffff;
     b02:	8f ef       	ldi	r24, 0xFF	; 255
     b04:	9f ef       	ldi	r25, 0xFF	; 255
     b06:	90 93 09 01 	sts	0x0109, r25
     b0a:	80 93 08 01 	sts	0x0108, r24
     b0e:	04 c0       	rjmp	.+8      	; 0xb18 <sendTelemetrie+0xb4>
    else
      mes.StatusRx.errorSum = state.errorSum;
     b10:	30 93 09 01 	sts	0x0109, r19
     b14:	20 93 08 01 	sts	0x0108, r18
    mes.StatusRx.frameLost = state.frameLost;
     b18:	80 91 ad 01 	lds	r24, 0x01AD
     b1c:	90 91 ae 01 	lds	r25, 0x01AE
     b20:	90 93 07 01 	sts	0x0107, r25
     b24:	80 93 06 01 	sts	0x0106, r24
  }
  if(eeprom.txDisable)
     b28:	80 91 70 01 	lds	r24, 0x0170
     b2c:	88 23       	and	r24, r24
     b2e:	11 f0       	breq	.+4      	; 0xb34 <sendTelemetrie+0xd0>
  {
    cc2500CommandStrobe(CC2500_SCAL);
     b30:	83 e3       	ldi	r24, 0x33	; 51
     b32:	06 c0       	rjmp	.+12     	; 0xb40 <sendTelemetrie+0xdc>
  }
  else
  {
    cc2500WriteFIFOBlock((uint8_t *)&mes, sizeof(mes));
     b34:	86 e0       	ldi	r24, 0x06	; 6
     b36:	91 e0       	ldi	r25, 0x01	; 1
     b38:	66 e0       	ldi	r22, 0x06	; 6
     b3a:	43 d4       	rcall	.+2182   	; 0x13c2 <cc2500WriteFIFOBlock>
    RES_BIT(PORTB, OUT_B_PRE);
     b3c:	28 98       	cbi	0x05, 0	; 5
    cc2500CommandStrobe(CC2500_STX);            // Enable TX
     b3e:	85 e3       	ldi	r24, 0x35	; 53
     b40:	2f d4       	rcall	.+2142   	; 0x13a0 <cc2500CommandStrobe>
     b42:	08 95       	ret

00000b44 <setFailSafe>:
    }
  }
}

void setFailSafe(void)
{
     b44:	a4 e7       	ldi	r26, 0x74	; 116
     b46:	b1 e0       	ldi	r27, 0x01	; 1
     b48:	e8 e4       	ldi	r30, 0x48	; 72
     b4a:	f1 e0       	ldi	r31, 0x01	; 1
  uint8_t i;
  for(i = 0;i < MAXCHAN;++i)
    eeprom.failSafe[i].failSafePos = output.chan_1us[i];        // Alle Positionen übernehmen
     b4c:	8d 91       	ld	r24, X+
     b4e:	9d 91       	ld	r25, X+
     b50:	91 83       	std	Z+1, r25	; 0x01
     b52:	80 83       	st	Z, r24
     b54:	34 96       	adiw	r30, 0x04	; 4
}

void setFailSafe(void)
{
  uint8_t i;
  for(i = 0;i < MAXCHAN;++i)
     b56:	81 e0       	ldi	r24, 0x01	; 1
     b58:	a4 38       	cpi	r26, 0x84	; 132
     b5a:	b8 07       	cpc	r27, r24
     b5c:	b9 f7       	brne	.-18     	; 0xb4c <setFailSafe+0x8>
    eeprom.failSafe[i].failSafePos = output.chan_1us[i];        // Alle Positionen übernehmen
  eeprom_write_block(&eeprom.failSafe,(uint8_t *)((int)&eeprom.failSafe - (int)&eeprom) ,sizeof(eeprom.failSafe));
     b5e:	87 e4       	ldi	r24, 0x47	; 71
     b60:	91 e0       	ldi	r25, 0x01	; 1
     b62:	63 e0       	ldi	r22, 0x03	; 3
     b64:	70 e0       	ldi	r23, 0x00	; 0
     b66:	40 e2       	ldi	r20, 0x20	; 32
     b68:	50 e0       	ldi	r21, 0x00	; 0
     b6a:	e1 d4       	rcall	.+2498   	; 0x152e <__eewr_block_m88>
  SET_BIT(state.ledError, L_SET_FAILSAVE);
     b6c:	80 91 a2 01 	lds	r24, 0x01A2
     b70:	81 60       	ori	r24, 0x01	; 1
     b72:	80 93 a2 01 	sts	0x01A2, r24
}
     b76:	08 95       	ret

00000b78 <readData>:
  }
  while(i-- > 0);
}

bool readData(void)
{
     b78:	1f 93       	push	r17
  static Message mes;

  if(cc2500ReadFIFOBlock((uint8_t *)&mes, sizeof(mes)) && (mes.crcOk))          // CRC ok
     b7a:	8c e0       	ldi	r24, 0x0C	; 12
     b7c:	91 e0       	ldi	r25, 0x01	; 1
     b7e:	68 e0       	ldi	r22, 0x08	; 8
     b80:	37 d4       	rcall	.+2158   	; 0x13f0 <cc2500ReadFIFOBlock>
     b82:	88 23       	and	r24, r24
     b84:	09 f4       	brne	.+2      	; 0xb88 <readData+0x10>
     b86:	e8 c0       	rjmp	.+464    	; 0xd58 <readData+0x1e0>
     b88:	80 91 13 01 	lds	r24, 0x0113
     b8c:	87 ff       	sbrs	r24, 7
     b8e:	e4 c0       	rjmp	.+456    	; 0xd58 <readData+0x1e0>
  {
    if(mes.data.command.rts)
     b90:	90 91 11 01 	lds	r25, 0x0111
     b94:	97 ff       	sbrs	r25, 7
     b96:	09 c0       	rjmp	.+18     	; 0xbaa <readData+0x32>
    {
      if(state.RxCount != 7)
     b98:	80 91 98 01 	lds	r24, 0x0198
     b9c:	87 30       	cpi	r24, 0x07	; 7
     b9e:	61 f0       	breq	.+24     	; 0xbb8 <readData+0x40>
      {
        state.syncError = true;
     ba0:	81 e0       	ldi	r24, 0x01	; 1
     ba2:	80 93 9f 01 	sts	0x019F, r24
        state.RxCount = 7;
     ba6:	87 e0       	ldi	r24, 0x07	; 7
     ba8:	05 c0       	rjmp	.+10     	; 0xbb4 <readData+0x3c>
      }
    }
    else if(state.RxCount >= 7)
     baa:	80 91 98 01 	lds	r24, 0x0198
     bae:	87 30       	cpi	r24, 0x07	; 7
     bb0:	18 f0       	brcs	.+6      	; 0xbb8 <readData+0x40>
      state.RxCount = 6;
     bb2:	86 e0       	ldi	r24, 0x06	; 6
     bb4:	80 93 98 01 	sts	0x0198, r24

    uint8_t type = mes.data.channel.type;
     bb8:	10 91 11 01 	lds	r17, 0x0111
     bbc:	12 95       	swap	r17
     bbe:	1f 70       	andi	r17, 0x0F	; 15
     bc0:	17 70       	andi	r17, 0x07	; 7
    if(type <= 4)                               // Kanaldaten
     bc2:	15 30       	cpi	r17, 0x05	; 5
     bc4:	08 f0       	brcs	.+2      	; 0xbc8 <readData+0x50>
     bc6:	74 c0       	rjmp	.+232    	; 0xcb0 <readData+0x138>
    {
      if(!eeprom.chanOff == (type & 2))              // Kanäle 8 - 16 verwenden
     bc8:	41 2f       	mov	r20, r17
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	20 e0       	ldi	r18, 0x00	; 0
     bce:	30 e0       	ldi	r19, 0x00	; 0
     bd0:	80 91 71 01 	lds	r24, 0x0171
     bd4:	88 23       	and	r24, r24
     bd6:	11 f4       	brne	.+4      	; 0xbdc <readData+0x64>
     bd8:	21 e0       	ldi	r18, 0x01	; 1
     bda:	30 e0       	ldi	r19, 0x00	; 0
     bdc:	ca 01       	movw	r24, r20
     bde:	82 70       	andi	r24, 0x02	; 2
     be0:	90 70       	andi	r25, 0x00	; 0
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	09 f0       	breq	.+2      	; 0xbea <readData+0x72>
     be8:	53 c0       	rjmp	.+166    	; 0xc90 <readData+0x118>
      {
        if(!(type & 1))
     bea:	40 fd       	sbrc	r20, 0
     bec:	27 c0       	rjmp	.+78     	; 0xc3c <readData+0xc4>
        {
          copyChan(&mes, 0);
     bee:	8c e0       	ldi	r24, 0x0C	; 12
     bf0:	91 e0       	ldi	r25, 0x01	; 1
     bf2:	60 e0       	ldi	r22, 0x00	; 0
     bf4:	ba dd       	rcall	.-1164   	; 0x76a <copyChan>
          state.groupTimer[0] = 0;
     bf6:	10 92 9d 01 	sts	0x019D, r1
          uint8_t flgtmp = output.portCflg;
     bfa:	20 91 84 01 	lds	r18, 0x0184
          if(output.pulsesTimer[0] > eeprom.pulsesDelay[0])
     bfe:	90 91 87 01 	lds	r25, 0x0187
     c02:	80 91 68 01 	lds	r24, 0x0168
     c06:	89 17       	cp	r24, r25
     c08:	08 f4       	brcc	.+2      	; 0xc0c <readData+0x94>
            flgtmp |= (1 << OUT_C_CHANNEL1);
     c0a:	21 60       	ori	r18, 0x01	; 1
          if(output.pulsesTimer[1] > eeprom.pulsesDelay[1])
     c0c:	90 91 88 01 	lds	r25, 0x0188
     c10:	80 91 69 01 	lds	r24, 0x0169
     c14:	89 17       	cp	r24, r25
     c16:	08 f4       	brcc	.+2      	; 0xc1a <readData+0xa2>
            flgtmp |= (1 << OUT_C_CHANNEL2);
     c18:	22 60       	ori	r18, 0x02	; 2
          if(output.pulsesTimer[2] > eeprom.pulsesDelay[2])
     c1a:	90 91 89 01 	lds	r25, 0x0189
     c1e:	80 91 6a 01 	lds	r24, 0x016A
     c22:	89 17       	cp	r24, r25
     c24:	08 f4       	brcc	.+2      	; 0xc28 <readData+0xb0>
            flgtmp |= (1 << OUT_C_CHANNEL3);
     c26:	24 60       	ori	r18, 0x04	; 4
          if(output.pulsesTimer[3] > eeprom.pulsesDelay[3])
     c28:	90 91 8a 01 	lds	r25, 0x018A
     c2c:	80 91 6b 01 	lds	r24, 0x016B
     c30:	89 17       	cp	r24, r25
     c32:	08 f4       	brcc	.+2      	; 0xc36 <readData+0xbe>
            flgtmp |= (1 << OUT_C_CHANNEL4);
     c34:	28 60       	ori	r18, 0x08	; 8
          output.portCflg = flgtmp;
     c36:	20 93 84 01 	sts	0x0184, r18
     c3a:	2a c0       	rjmp	.+84     	; 0xc90 <readData+0x118>
//          output.portCflg |= (1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2)
//              | (1 << OUT_C_CHANNEL3) | (1 << OUT_C_CHANNEL4);
        }
        else if(type & 1)
        {
          copyChan(&mes, 4);
     c3c:	8c e0       	ldi	r24, 0x0C	; 12
     c3e:	91 e0       	ldi	r25, 0x01	; 1
     c40:	64 e0       	ldi	r22, 0x04	; 4
     c42:	93 dd       	rcall	.-1242   	; 0x76a <copyChan>
          state.groupTimer[1] = 0;
     c44:	10 92 9e 01 	sts	0x019E, r1
          uint8_t flgtmp = output.portCflg;
     c48:	20 91 84 01 	lds	r18, 0x0184
          if(output.pulsesTimer[4] > eeprom.pulsesDelay[4])
     c4c:	90 91 8b 01 	lds	r25, 0x018B
     c50:	80 91 6c 01 	lds	r24, 0x016C
     c54:	89 17       	cp	r24, r25
     c56:	08 f4       	brcc	.+2      	; 0xc5a <readData+0xe2>
            flgtmp |= (1 << OUT_C_CHANNEL5);
     c58:	20 61       	ori	r18, 0x10	; 16
          if(output.pulsesTimer[5] > eeprom.pulsesDelay[5])
     c5a:	90 91 8c 01 	lds	r25, 0x018C
     c5e:	80 91 6d 01 	lds	r24, 0x016D
     c62:	89 17       	cp	r24, r25
     c64:	08 f4       	brcc	.+2      	; 0xc68 <readData+0xf0>
            flgtmp |= (1 << OUT_C_CHANNEL6);
     c66:	20 62       	ori	r18, 0x20	; 32
          output.portCflg = flgtmp;
     c68:	20 93 84 01 	sts	0x0184, r18
          flgtmp = output.portDflg;
     c6c:	20 91 85 01 	lds	r18, 0x0185
          if(output.pulsesTimer[6] > eeprom.pulsesDelay[6])
     c70:	90 91 8d 01 	lds	r25, 0x018D
     c74:	80 91 6e 01 	lds	r24, 0x016E
     c78:	89 17       	cp	r24, r25
     c7a:	08 f4       	brcc	.+2      	; 0xc7e <readData+0x106>
            flgtmp |= (1 << OUT_D_CHANNEL7);
     c7c:	21 60       	ori	r18, 0x01	; 1
          if(output.pulsesTimer[7] > eeprom.pulsesDelay[7])
     c7e:	90 91 8e 01 	lds	r25, 0x018E
     c82:	80 91 6f 01 	lds	r24, 0x016F
     c86:	89 17       	cp	r24, r25
     c88:	08 f4       	brcc	.+2      	; 0xc8c <readData+0x114>
            flgtmp |= (1 << OUT_D_CHANNEL8);
     c8a:	22 60       	ori	r18, 0x02	; 2
          output.portDflg = flgtmp;
     c8c:	20 93 85 01 	sts	0x0185, r18
//          output.portCflg |= (1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6);
//          output.portDflg = (1 << OUT_D_CHANNEL7) | (1 << OUT_D_CHANNEL8);

        }
      }
      if((type == 4) && (output.pulsesOffset > eeprom.outputOffset + 2)) // obere Gruppe erst ausgeben
     c90:	14 30       	cpi	r17, 0x04	; 4
     c92:	09 f0       	breq	.+2      	; 0xc96 <readData+0x11e>
     c94:	3d c0       	rjmp	.+122    	; 0xd10 <readData+0x198>
     c96:	20 91 86 01 	lds	r18, 0x0186
     c9a:	30 e0       	ldi	r19, 0x00	; 0
     c9c:	80 91 67 01 	lds	r24, 0x0167
     ca0:	90 e0       	ldi	r25, 0x00	; 0
     ca2:	02 96       	adiw	r24, 0x02	; 2
     ca4:	82 17       	cp	r24, r18
     ca6:	93 07       	cpc	r25, r19
     ca8:	9c f5       	brge	.+102    	; 0xd10 <readData+0x198>
        setupPulses(false);
     caa:	80 e0       	ldi	r24, 0x00	; 0
     cac:	ff da       	rcall	.-2562   	; 0x2ac <setupPulses>
     cae:	30 c0       	rjmp	.+96     	; 0xd10 <readData+0x198>
    }
    else if(type == 5)  // eeprom
     cb0:	15 30       	cpi	r17, 0x05	; 5
     cb2:	29 f5       	brne	.+74     	; 0xcfe <readData+0x186>
    {
      if((mes.data.MemoryWord.tar == 0)
     cb4:	89 2f       	mov	r24, r25
     cb6:	8c 70       	andi	r24, 0x0C	; 12
     cb8:	59 f5       	brne	.+86     	; 0xd10 <readData+0x198>
     cba:	20 91 0e 01 	lds	r18, 0x010E
     cbe:	30 91 0f 01 	lds	r19, 0x010F
     cc2:	23 30       	cpi	r18, 0x03	; 3
     cc4:	31 05       	cpc	r19, r1
     cc6:	20 f1       	brcs	.+72     	; 0xd10 <readData+0x198>
     cc8:	80 91 10 01 	lds	r24, 0x0110
     ccc:	81 30       	cpi	r24, 0x01	; 1
     cce:	01 f5       	brne	.+64     	; 0xd10 <readData+0x198>
          && ((int)mes.data.MemoryWord.adr >= sizeof(BindData))
          && (mes.data.MemoryWord.des == 1))            // Adresse auf 1
        if(mes.data.MemoryWord.wr)                      // schreiben
     cd0:	90 ff       	sbrs	r25, 0
     cd2:	1e c0       	rjmp	.+60     	; 0xd10 <readData+0x198>
        {
          if(mes.data.MemoryWord.size)
     cd4:	91 ff       	sbrs	r25, 1
     cd6:	07 c0       	rjmp	.+14     	; 0xce6 <readData+0x16e>
            eeprom_write_word(mes.data.MemoryWord.adr, mes.data.MemoryWord.data);
     cd8:	60 91 0c 01 	lds	r22, 0x010C
     cdc:	70 91 0d 01 	lds	r23, 0x010D
     ce0:	c9 01       	movw	r24, r18
     ce2:	3c d4       	rcall	.+2168   	; 0x155c <__eewr_word_m88>
     ce4:	04 c0       	rjmp	.+8      	; 0xcee <readData+0x176>
          else
            eeprom_write_byte(mes.data.MemoryByte.adr, mes.data.MemoryByte.data);
     ce6:	c9 01       	movw	r24, r18
     ce8:	60 91 0d 01 	lds	r22, 0x010D
     cec:	29 d4       	rcall	.+2130   	; 0x1540 <__eewr_byte_m88>
          eeprom_read_block(&eeprom, 0, sizeof(eeprom));    // Daten wieder auslesen
     cee:	84 e4       	ldi	r24, 0x44	; 68
     cf0:	91 e0       	ldi	r25, 0x01	; 1
     cf2:	60 e0       	ldi	r22, 0x00	; 0
     cf4:	70 e0       	ldi	r23, 0x00	; 0
     cf6:	4e e2       	ldi	r20, 0x2E	; 46
     cf8:	50 e0       	ldi	r21, 0x00	; 0
     cfa:	09 d4       	rcall	.+2066   	; 0x150e <__eerd_block_m88>
     cfc:	09 c0       	rjmp	.+18     	; 0xd10 <readData+0x198>
        }
    }
    else if(type == 7)
     cfe:	17 30       	cpi	r17, 0x07	; 7
     d00:	39 f4       	brne	.+14     	; 0xd10 <readData+0x198>
    {
      if(mes.data.command.command == 1)     // FailSafe Position setzen
     d02:	80 91 0f 01 	lds	r24, 0x010F
     d06:	90 91 10 01 	lds	r25, 0x0110
     d0a:	01 97       	sbiw	r24, 0x01	; 1
     d0c:	09 f4       	brne	.+2      	; 0xd10 <readData+0x198>
        setFailSafe();
     d0e:	1a df       	rcall	.-460    	; 0xb44 <setFailSafe>
    }
    if(/*(mes.rssi > 50) ||*/ (mes.lqi < 5))   // Empfang schlecht
     d10:	80 91 13 01 	lds	r24, 0x0113
     d14:	8f 77       	andi	r24, 0x7F	; 127
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	05 97       	sbiw	r24, 0x05	; 5
     d1a:	1c f4       	brge	.+6      	; 0xd22 <readData+0x1aa>
      setAnt(state.actAnt);               // Antenne wechseln
     d1c:	80 91 9a 01 	lds	r24, 0x019A
     d20:	5f dc       	rcall	.-1858   	; 0x5e0 <setAnt>
//    if(state.okSum < 0xffffffff)
    ++state.okSum;                        // Hält bald 100 Tage
     d22:	80 91 a9 01 	lds	r24, 0x01A9
     d26:	90 91 aa 01 	lds	r25, 0x01AA
     d2a:	a0 91 ab 01 	lds	r26, 0x01AB
     d2e:	b0 91 ac 01 	lds	r27, 0x01AC
     d32:	01 96       	adiw	r24, 0x01	; 1
     d34:	a1 1d       	adc	r26, r1
     d36:	b1 1d       	adc	r27, r1
     d38:	80 93 a9 01 	sts	0x01A9, r24
     d3c:	90 93 aa 01 	sts	0x01AA, r25
     d40:	a0 93 ab 01 	sts	0x01AB, r26
     d44:	b0 93 ac 01 	sts	0x01AC, r27
    state.errorCount = 0;
     d48:	10 92 a3 01 	sts	0x01A3, r1
    if(state.led)
     d4c:	80 91 96 01 	lds	r24, 0x0196
     d50:	81 11       	cpse	r24, r1
      LED_ON;
     d52:	5c 9a       	sbi	0x0b, 4	; 11
     d54:	81 e0       	ldi	r24, 0x01	; 1
     d56:	01 c0       	rjmp	.+2      	; 0xd5a <readData+0x1e2>
     d58:	80 e0       	ldi	r24, 0x00	; 0
    return(true);
  }
  else
    return(false);
}
     d5a:	1f 91       	pop	r17
     d5c:	08 95       	ret

00000d5e <readBindData>:
  if(state.led)
    LED_OFF;
}

bool readBindData(void)
{
     d5e:	df 93       	push	r29
     d60:	cf 93       	push	r28
     d62:	00 d0       	rcall	.+0      	; 0xd64 <readBindData+0x6>
     d64:	00 d0       	rcall	.+0      	; 0xd66 <readBindData+0x8>
     d66:	0f 92       	push	r0
     d68:	cd b7       	in	r28, 0x3d	; 61
     d6a:	de b7       	in	r29, 0x3e	; 62
  MessageBind mes;

  if(cc2500ReadFIFOBlock((uint8_t *)&mes, sizeof(mes)) && (mes.crcOk))
     d6c:	ce 01       	movw	r24, r28
     d6e:	01 96       	adiw	r24, 0x01	; 1
     d70:	65 e0       	ldi	r22, 0x05	; 5
     d72:	3e d3       	rcall	.+1660   	; 0x13f0 <cc2500ReadFIFOBlock>
     d74:	88 23       	and	r24, r24
     d76:	81 f1       	breq	.+96     	; 0xdd8 <readBindData+0x7a>
     d78:	8d 81       	ldd	r24, Y+5	; 0x05
     d7a:	87 ff       	sbrs	r24, 7
     d7c:	2d c0       	rjmp	.+90     	; 0xdd8 <readBindData+0x7a>
  {
    eeprom.bind.id = mes.data.id;
     d7e:	89 81       	ldd	r24, Y+1	; 0x01
     d80:	9a 81       	ldd	r25, Y+2	; 0x02
     d82:	90 93 45 01 	sts	0x0145, r25
     d86:	80 93 44 01 	sts	0x0144, r24
    eeprom.bind.step = mes.data.step;
     d8a:	8b 81       	ldd	r24, Y+3	; 0x03
     d8c:	80 93 46 01 	sts	0x0146, r24
     d90:	e8 e6       	ldi	r30, 0x68	; 104
     d92:	f1 e0       	ldi	r31, 0x01	; 1
    uint8_t i;
    for(i = 0;i < MAXCHAN;++i)
      if(eeprom.pulsesDelay[i] == 0xff)
        eeprom.pulsesDelay[i] = 15;                  // Default mindestens 15 ms Delay
     d94:	9f e0       	ldi	r25, 0x0F	; 15
  {
    eeprom.bind.id = mes.data.id;
    eeprom.bind.step = mes.data.step;
    uint8_t i;
    for(i = 0;i < MAXCHAN;++i)
      if(eeprom.pulsesDelay[i] == 0xff)
     d96:	80 81       	ld	r24, Z
     d98:	8f 3f       	cpi	r24, 0xFF	; 255
     d9a:	09 f4       	brne	.+2      	; 0xd9e <readBindData+0x40>
        eeprom.pulsesDelay[i] = 15;                  // Default mindestens 15 ms Delay
     d9c:	90 83       	st	Z, r25
     d9e:	31 96       	adiw	r30, 0x01	; 1
  if(cc2500ReadFIFOBlock((uint8_t *)&mes, sizeof(mes)) && (mes.crcOk))
  {
    eeprom.bind.id = mes.data.id;
    eeprom.bind.step = mes.data.step;
    uint8_t i;
    for(i = 0;i < MAXCHAN;++i)
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	e0 37       	cpi	r30, 0x70	; 112
     da4:	f8 07       	cpc	r31, r24
     da6:	b9 f7       	brne	.-18     	; 0xd96 <readBindData+0x38>
      if(eeprom.pulsesDelay[i] == 0xff)
        eeprom.pulsesDelay[i] = 15;                  // Default mindestens 15 ms Delay
    if(eeprom.outputOffset == 0xff)
     da8:	80 91 67 01 	lds	r24, 0x0167
     dac:	8f 3f       	cpi	r24, 0xFF	; 255
     dae:	51 f4       	brne	.+20     	; 0xdc4 <readBindData+0x66>
    {
      eeprom.outputOffset = 10;                 // Default 10 ms Versatz
     db0:	8a e0       	ldi	r24, 0x0A	; 10
     db2:	80 93 67 01 	sts	0x0167, r24
      eeprom_write_block(&eeprom, 0 ,sizeof(eeprom));
     db6:	cf 01       	movw	r24, r30
     db8:	8c 97       	sbiw	r24, 0x2c	; 44
     dba:	60 e0       	ldi	r22, 0x00	; 0
     dbc:	70 e0       	ldi	r23, 0x00	; 0
     dbe:	4e e2       	ldi	r20, 0x2E	; 46
     dc0:	50 e0       	ldi	r21, 0x00	; 0
     dc2:	06 c0       	rjmp	.+12     	; 0xdd0 <readBindData+0x72>
    }
    else
      eeprom_write_block(&eeprom.bind, 0 ,sizeof(eeprom.bind));
     dc4:	cf 01       	movw	r24, r30
     dc6:	8c 97       	sbiw	r24, 0x2c	; 44
     dc8:	60 e0       	ldi	r22, 0x00	; 0
     dca:	70 e0       	ldi	r23, 0x00	; 0
     dcc:	43 e0       	ldi	r20, 0x03	; 3
     dce:	50 e0       	ldi	r21, 0x00	; 0
     dd0:	ae d3       	rcall	.+1884   	; 0x152e <__eewr_block_m88>
    state.bindmode = false;
     dd2:	10 92 95 01 	sts	0x0195, r1
     dd6:	ff cf       	rjmp	.-2      	; 0xdd6 <readBindData+0x78>
    while(1);                   //       reset durch Watchdog
  }
  else
    return(false);
}
     dd8:	80 e0       	ldi	r24, 0x00	; 0
     dda:	0f 90       	pop	r0
     ddc:	0f 90       	pop	r0
     dde:	0f 90       	pop	r0
     de0:	0f 90       	pop	r0
     de2:	0f 90       	pop	r0
     de4:	cf 91       	pop	r28
     de6:	df 91       	pop	r29
     de8:	08 95       	ret

00000dea <processData>:
    cc2500CommandStrobe(CC2500_STX);            // Enable TX
  }
}

bool processData(uint8_t data_len)                // Nachsehen ob was da
{
     dea:	1f 93       	push	r17
     dec:	18 2f       	mov	r17, r24
  if(state.bindmode)
     dee:	80 91 95 01 	lds	r24, 0x0195
     df2:	88 23       	and	r24, r24
     df4:	51 f0       	breq	.+20     	; 0xe0a <processData+0x20>
  {
    if(data_len == sizeof(MessageBind))
     df6:	15 30       	cpi	r17, 0x05	; 5
     df8:	29 f4       	brne	.+10     	; 0xe04 <processData+0x1a>
      return(readBindData());
     dfa:	b1 df       	rcall	.-158    	; 0xd5e <readBindData>
     dfc:	10 c0       	rjmp	.+32     	; 0xe1e <processData+0x34>
    else
    {
//      setReceiveError();
      //  cc2500FlushReceiveData();           // geht nicht Empfänger läuft schon wieder!?
      while(data_len-- > 0)
        cc2500ReadReg(CC2500_RXFIFO);
     dfe:	8f e3       	ldi	r24, 0x3F	; 63
     e00:	9e d2       	rcall	.+1340   	; 0x133e <cc2500ReadReg>
     e02:	11 50       	subi	r17, 0x01	; 1
      return(readBindData());
    else
    {
//      setReceiveError();
      //  cc2500FlushReceiveData();           // geht nicht Empfänger läuft schon wieder!?
      while(data_len-- > 0)
     e04:	11 23       	and	r17, r17
     e06:	d9 f7       	brne	.-10     	; 0xdfe <processData+0x14>
     e08:	09 c0       	rjmp	.+18     	; 0xe1c <processData+0x32>
        cc2500ReadReg(CC2500_RXFIFO);
      return(false);
    }
  }
  else if(data_len == sizeof(Message))
     e0a:	18 30       	cpi	r17, 0x08	; 8
     e0c:	29 f4       	brne	.+10     	; 0xe18 <processData+0x2e>
    return(readData());
     e0e:	b4 de       	rcall	.-664    	; 0xb78 <readData>
     e10:	06 c0       	rjmp	.+12     	; 0xe1e <processData+0x34>
  else
  {
//    setReceiveError();
    while(data_len-- > 0)
      cc2500ReadReg(CC2500_RXFIFO);
     e12:	8f e3       	ldi	r24, 0x3F	; 63
     e14:	94 d2       	rcall	.+1320   	; 0x133e <cc2500ReadReg>
     e16:	11 50       	subi	r17, 0x01	; 1
  else if(data_len == sizeof(Message))
    return(readData());
  else
  {
//    setReceiveError();
    while(data_len-- > 0)
     e18:	11 23       	and	r17, r17
     e1a:	d9 f7       	brne	.-10     	; 0xe12 <processData+0x28>
     e1c:	80 e0       	ldi	r24, 0x00	; 0
      cc2500ReadReg(CC2500_RXFIFO);
    return(false);
  }
}
     e1e:	1f 91       	pop	r17
     e20:	08 95       	ret

00000e22 <setNextChanGoRx>:
//  SET_BIT(EIMSK, INT0);                    // INT0 ein
//  Timercapt = 0;
}

void setNextChanGoRx(uint8_t c)                // Kanal schreiben und auf Empfang
{
     e22:	28 2f       	mov	r18, r24
  if(PIND & (1<<INP_D_CC2500_GDO0))
     e24:	4a 9b       	sbis	0x09, 2	; 9
     e26:	05 c0       	rjmp	.+10     	; 0xe32 <setNextChanGoRx+0x10>
    SET_BIT(state.ledError, L_TX_NOT_READY);
     e28:	80 91 a2 01 	lds	r24, 0x01A2
     e2c:	80 64       	ori	r24, 0x40	; 64
     e2e:	80 93 a2 01 	sts	0x01A2, r24
  uint16_t tempChan = state.actChan;
     e32:	80 91 99 01 	lds	r24, 0x0199
     e36:	68 2f       	mov	r22, r24
     e38:	70 e0       	ldi	r23, 0x00	; 0
  while(c--)
    tempChan += eeprom.bind.step * 2 + 1;
     e3a:	80 91 46 01 	lds	r24, 0x0146
     e3e:	90 e0       	ldi	r25, 0x00	; 0
     e40:	88 0f       	add	r24, r24
     e42:	99 1f       	adc	r25, r25
     e44:	01 96       	adiw	r24, 0x01	; 1
     e46:	03 c0       	rjmp	.+6      	; 0xe4e <setNextChanGoRx+0x2c>
void setNextChanGoRx(uint8_t c)                // Kanal schreiben und auf Empfang
{
  if(PIND & (1<<INP_D_CC2500_GDO0))
    SET_BIT(state.ledError, L_TX_NOT_READY);
  uint16_t tempChan = state.actChan;
  while(c--)
     e48:	68 0f       	add	r22, r24
     e4a:	79 1f       	adc	r23, r25
     e4c:	21 50       	subi	r18, 0x01	; 1
     e4e:	22 23       	and	r18, r18
     e50:	d9 f7       	brne	.-10     	; 0xe48 <setNextChanGoRx+0x26>
     e52:	02 c0       	rjmp	.+4      	; 0xe58 <setNextChanGoRx+0x36>
    tempChan += eeprom.bind.step * 2 + 1;
  while(tempChan > MAXHOPPCHAN)
    tempChan -= (MAXHOPPCHAN + 1);
     e54:	64 5c       	subi	r22, 0xC4	; 196
     e56:	70 40       	sbci	r23, 0x00	; 0
  if(PIND & (1<<INP_D_CC2500_GDO0))
    SET_BIT(state.ledError, L_TX_NOT_READY);
  uint16_t tempChan = state.actChan;
  while(c--)
    tempChan += eeprom.bind.step * 2 + 1;
  while(tempChan > MAXHOPPCHAN)
     e58:	64 3c       	cpi	r22, 0xC4	; 196
     e5a:	71 05       	cpc	r23, r1
     e5c:	d8 f7       	brcc	.-10     	; 0xe54 <setNextChanGoRx+0x32>
    tempChan -= (MAXHOPPCHAN + 1);
  state.actChan = tempChan;
     e5e:	60 93 99 01 	sts	0x0199, r22
  cc2500WriteRegCheckIdle(CC2500_CHANNR, tempChan);
     e62:	8a e0       	ldi	r24, 0x0A	; 10
     e64:	8a d2       	rcall	.+1300   	; 0x137a <cc2500WriteRegCheckIdle>
  setRx();
     e66:	e4 dd       	rcall	.-1080   	; 0xa30 <setRx>
}
     e68:	08 95       	ret

00000e6a <rxState>:
  SET_BIT(state.ledError, L_BIND_ON);
  eeprom.bind.step = BINDMODESTEP;
}

void rxState(void)
{
     e6a:	0f 93       	push	r16
     e6c:	1f 93       	push	r17
     e6e:	cf 93       	push	r28
     e70:	df 93       	push	r29
  static enum receiver rxstate;
  static uint16_t counter;
  uint8_t cc2500status, frequ, data_len;

  switch(rxstate)
     e72:	10 91 03 01 	lds	r17, 0x0103
     e76:	12 30       	cpi	r17, 0x02	; 2
     e78:	09 f4       	brne	.+2      	; 0xe7c <rxState+0x12>
     e7a:	51 c0       	rjmp	.+162    	; 0xf1e <rxState+0xb4>
     e7c:	13 30       	cpi	r17, 0x03	; 3
     e7e:	30 f4       	brcc	.+12     	; 0xe8c <rxState+0x22>
     e80:	11 23       	and	r17, r17
     e82:	71 f0       	breq	.+28     	; 0xea0 <rxState+0x36>
     e84:	11 30       	cpi	r17, 0x01	; 1
     e86:	09 f0       	breq	.+2      	; 0xe8a <rxState+0x20>
     e88:	40 c1       	rjmp	.+640    	; 0x110a <rxState+0x2a0>
     e8a:	26 c0       	rjmp	.+76     	; 0xed8 <rxState+0x6e>
     e8c:	14 30       	cpi	r17, 0x04	; 4
     e8e:	09 f4       	brne	.+2      	; 0xe92 <rxState+0x28>
     e90:	20 c1       	rjmp	.+576    	; 0x10d2 <rxState+0x268>
     e92:	14 30       	cpi	r17, 0x04	; 4
     e94:	08 f4       	brcc	.+2      	; 0xe98 <rxState+0x2e>
     e96:	97 c0       	rjmp	.+302    	; 0xfc6 <rxState+0x15c>
     e98:	15 30       	cpi	r17, 0x05	; 5
     e9a:	09 f0       	breq	.+2      	; 0xe9e <rxState+0x34>
     e9c:	36 c1       	rjmp	.+620    	; 0x110a <rxState+0x2a0>
     e9e:	1e c1       	rjmp	.+572    	; 0x10dc <rxState+0x272>
  {
  case Start:
    if(checkKey() || !checkId())
     ea0:	ac dc       	rcall	.-1704   	; 0x7fa <checkKey>
     ea2:	88 23       	and	r24, r24
     ea4:	19 f4       	brne	.+6      	; 0xeac <rxState+0x42>
     ea6:	92 dc       	rcall	.-1756   	; 0x7cc <checkId>
     ea8:	88 23       	and	r24, r24
     eaa:	29 f4       	brne	.+10     	; 0xeb6 <rxState+0x4c>
    {
      setBindMode();
     eac:	6a dd       	rcall	.-1324   	; 0x982 <setBindMode>
      state.bindmode = true;
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	80 93 95 01 	sts	0x0195, r24
     eb4:	05 c0       	rjmp	.+10     	; 0xec0 <rxState+0x56>
    }
    else
    {
      cc2500WriteReg(CC2500_PKTLEN, sizeof(MessageData));
     eb6:	86 e0       	ldi	r24, 0x06	; 6
     eb8:	66 e0       	ldi	r22, 0x06	; 6
     eba:	46 d2       	rcall	.+1164   	; 0x1348 <cc2500WriteReg>
      state.bindmode = false;
     ebc:	10 92 95 01 	sts	0x0195, r1
    }
    calibrateSlow();                   // einmal Kalibrieren beim Wechsel auf RX
     ec0:	61 d2       	rcall	.+1218   	; 0x1384 <calibrateSlow>
    setFreeChanRx();                 // Kanal einstellen und Empfang ein
     ec2:	ba dd       	rcall	.-1164   	; 0xa38 <setFreeChanRx>
    counter = 0;
     ec4:	10 92 02 01 	sts	0x0102, r1
     ec8:	10 92 01 01 	sts	0x0101, r1
    state.errorCount = 1;
     ecc:	81 e0       	ldi	r24, 0x01	; 1
     ece:	80 93 a3 01 	sts	0x01A3, r24
    rxstate = checkRSSI;
     ed2:	80 93 03 01 	sts	0x0103, r24
     ed6:	fa c0       	rjmp	.+500    	; 0x10cc <rxState+0x262>
    setTimer(CHANTIME);
    break;
  case checkRSSI:                              // Kanal frei?
    if((counter > 100) || checkchanFree()      // lesen von RSSI und Status kann gleich sein
     ed8:	80 91 01 01 	lds	r24, 0x0101
     edc:	90 91 02 01 	lds	r25, 0x0102
     ee0:	85 36       	cpi	r24, 0x65	; 101
     ee2:	91 05       	cpc	r25, r1
     ee4:	60 f4       	brcc	.+24     	; 0xefe <rxState+0x94>
     ee6:	9e dd       	rcall	.-1220   	; 0xa24 <checkchanFree>
     ee8:	88 23       	and	r24, r24
     eea:	49 f4       	brne	.+18     	; 0xefe <rxState+0x94>
     eec:	4a 99       	sbic	0x09, 2	; 9
     eee:	07 c0       	rjmp	.+14     	; 0xefe <rxState+0x94>
     ef0:	38 d2       	rcall	.+1136   	; 0x1362 <cc2500GetState>
     ef2:	80 31       	cpi	r24, 0x10	; 16
     ef4:	21 f4       	brne	.+8      	; 0xefe <rxState+0x94>
     ef6:	80 91 c8 01 	lds	r24, 0x01C8
     efa:	88 23       	and	r24, r24
     efc:	49 f0       	breq	.+18     	; 0xf10 <rxState+0xa6>
        || (PIND & (1 << INP_D_CC2500_GDO0))
        || (cc2500GetState() != CC2500_STATE_RX)
        || ReceiverInterrupt)
    {
      counter = 0;
     efe:	10 92 02 01 	sts	0x0102, r1
     f02:	10 92 01 01 	sts	0x0101, r1
      rxstate = waitForData;
     f06:	82 e0       	ldi	r24, 0x02	; 2
     f08:	80 93 03 01 	sts	0x0103, r24
      setTimer(CHANTIME2);
     f0c:	85 e8       	ldi	r24, 0x85	; 133
     f0e:	df c0       	rjmp	.+446    	; 0x10ce <rxState+0x264>
    }
    else
    {
      cc2500Idle();
     f10:	2c d2       	rcall	.+1112   	; 0x136a <cc2500Idle>
      setFreeChanRx();                 // Neuer Kanal einstellen und Empfang ein
     f12:	92 dd       	rcall	.-1244   	; 0xa38 <setFreeChanRx>
      ++counter;
     f14:	80 91 01 01 	lds	r24, 0x0101
     f18:	90 91 02 01 	lds	r25, 0x0102
     f1c:	4e c0       	rjmp	.+156    	; 0xfba <rxState+0x150>
//      SET_BIT(TIFR2, OCF2A);
      TIFR2 = (1 << OCF2A);
    }
    break;
  case waitForData:                 // Eine Sekunde auf Empfang warten
    if(PIND & (1 << INP_D_CC2500_GDO0))        // Einsprung über Timerinterrupt und Empfang läuft gerade
     f1e:	4a 99       	sbic	0x09, 2	; 9
     f20:	37 c0       	rjmp	.+110    	; 0xf90 <rxState+0x126>
    {
//      SET_BIT(TIFR2, OCF2A);
      TIFR2 = (1 << OCF2A);
      return;
    }
    cc2500status = SPI_MasterTransmit(CC2500_SNOP | CC2500_READ_SINGLE);
     f22:	8d eb       	ldi	r24, 0xBD	; 189
     f24:	1d db       	rcall	.-2502   	; 0x560 <SPI_MasterTransmit>
     f26:	98 2f       	mov	r25, r24
    if((cc2500status & CC2500_STATUS_STATE_BM) != CC2500_STATE_RX)  // nicht mehr auf Empfang
     f28:	80 77       	andi	r24, 0x70	; 112
     f2a:	80 31       	cpi	r24, 0x10	; 16
     f2c:	99 f1       	breq	.+102    	; 0xf94 <rxState+0x12a>
    {
      if(ReceiverInterrupt)
     f2e:	80 91 c8 01 	lds	r24, 0x01C8
     f32:	88 23       	and	r24, r24
     f34:	49 f1       	breq	.+82     	; 0xf88 <rxState+0x11e>
      {
        if((data_len = cc2500status & CC2500_STATUS_FIFO_BYTES_AVAILABLE_BM))
     f36:	19 2f       	mov	r17, r25
     f38:	1f 70       	andi	r17, 0x0F	; 15
     f3a:	19 f1       	breq	.+70     	; 0xf82 <rxState+0x118>
        {                           // irgendwelche Daten da (Prüfsumme und Länge war ok!)
          calibrateFast();
     f3c:	2a d2       	rcall	.+1108   	; 0x1392 <calibrateFast>
          setFrequencyOffset(cc2500ReadStatusReg(CC2500_FREQEST), false);
     f3e:	82 e3       	ldi	r24, 0x32	; 50
     f40:	0b d2       	rcall	.+1046   	; 0x1358 <cc2500ReadStatusReg>
     f42:	60 e0       	ldi	r22, 0x00	; 0
     f44:	4b dd       	rcall	.-1386   	; 0x9dc <setFrequencyOffset>
          setNextChanGoRx(1);    // Schnell wieder auf Empfang
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	6c df       	rcall	.-296    	; 0xe22 <setNextChanGoRx>
          if(processData(data_len))            // Empfangsregister auswerten, muss als erstes kommen, wegen Auswertung Telegramm
     f4a:	81 2f       	mov	r24, r17
     f4c:	4e df       	rcall	.-356    	; 0xdea <processData>
     f4e:	88 23       	and	r24, r24
     f50:	09 f4       	brne	.+2      	; 0xf54 <rxState+0xea>
     f52:	d9 c0       	rjmp	.+434    	; 0x1106 <rxState+0x29c>
          {
            adjTimer();
     f54:	bf dc       	rcall	.-1666   	; 0x8d4 <adjTimer>
            if(state.RxCount < 7)
     f56:	80 91 98 01 	lds	r24, 0x0198
     f5a:	87 30       	cpi	r24, 0x07	; 7
     f5c:	10 f4       	brcc	.+4      	; 0xf62 <rxState+0xf8>
              setTimer(CHANTIME + CHANTIME02 + 1);
     f5e:	8f e4       	ldi	r24, 0x4F	; 79
     f60:	01 c0       	rjmp	.+2      	; 0xf64 <rxState+0xfa>
            else
              setTimer(CHANTIME + TELETIME + 1 + CHANTIME02 + 1);           // Beim ersten Mal nicht senden!!
     f62:	8c ea       	ldi	r24, 0xAC	; 172
     f64:	b2 dc       	rcall	.-1692   	; 0x8ca <setTimer>
            state.RxCount = 0;
     f66:	10 92 98 01 	sts	0x0198, r1
//            if(state.RxTimer == (uint8_t)-CHANTIME02)           // Timersync hat nicht funktioniert
//              setNextChanGoRx(1);    // Schnell wieder auf Empfang
//            else
//            {
            state.syncError = false;
     f6a:	10 92 9f 01 	sts	0x019F, r1
            rxstate = Main;
     f6e:	83 e0       	ldi	r24, 0x03	; 3
     f70:	80 93 03 01 	sts	0x0103, r24
            counter = 0;
     f74:	10 92 02 01 	sts	0x0102, r1
     f78:	10 92 01 01 	sts	0x0101, r1
//            SET_BIT(TIFR2, OCF2A);
            TIFR2 = (1 << OCF2A);
     f7c:	82 e0       	ldi	r24, 0x02	; 2
     f7e:	87 bb       	out	0x17, r24	; 23
     f80:	c2 c0       	rjmp	.+388    	; 0x1106 <rxState+0x29c>
//            }
          }
        }
        else
        {
          setNextChanGoRx(2);
     f82:	82 e0       	ldi	r24, 0x02	; 2
     f84:	4e df       	rcall	.-356    	; 0xe22 <setNextChanGoRx>
     f86:	bf c0       	rjmp	.+382    	; 0x1106 <rxState+0x29c>
        }
        ReceiverInterrupt = false;
      }
      else                      // Timerinterrupt
      {                         // eventuell nachschauen ob Syncword empfangen
        cc2500Idle();
     f88:	f0 d1       	rcall	.+992    	; 0x136a <cc2500Idle>
        cc2500CommandStrobe(CC2500_SFRX);
     f8a:	8a e3       	ldi	r24, 0x3A	; 58
     f8c:	09 d2       	rcall	.+1042   	; 0x13a0 <cc2500CommandStrobe>
        setRx();
     f8e:	50 dd       	rcall	.-1376   	; 0xa30 <setRx>
//        SET_BIT(TIFR2, OCF2A);
        TIFR2 = (1 << OCF2A);
     f90:	17 bb       	out	0x17, r17	; 23
     f92:	bb c0       	rjmp	.+374    	; 0x110a <rxState+0x2a0>
      }
    }
    else                                // Noch auf Empfang
    {
      if(counter > MAXHOPPCHAN)
     f94:	80 91 01 01 	lds	r24, 0x0101
     f98:	90 91 02 01 	lds	r25, 0x0102
     f9c:	84 3c       	cpi	r24, 0xC4	; 196
     f9e:	91 05       	cpc	r25, r1
     fa0:	60 f0       	brcs	.+24     	; 0xfba <rxState+0x150>
      {
        cc2500Idle();
     fa2:	e3 d1       	rcall	.+966    	; 0x136a <cc2500Idle>
        setNewRxFrequ();                // Frequenz verstellen
     fa4:	03 dd       	rcall	.-1530   	; 0x9ac <setNewRxFrequ>
        setFreeChanRx();                 // Kanal einstellen und Empfang ein
     fa6:	48 dd       	rcall	.-1392   	; 0xa38 <setFreeChanRx>
        counter = 0;
     fa8:	10 92 02 01 	sts	0x0102, r1
     fac:	10 92 01 01 	sts	0x0101, r1
        rxstate = checkRSSI;
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	80 93 03 01 	sts	0x0103, r24
        setTimer(CHANTIME);
     fb6:	82 e4       	ldi	r24, 0x42	; 66
     fb8:	6c c0       	rjmp	.+216    	; 0x1092 <rxState+0x228>
      }
      else
        ++counter;
     fba:	01 96       	adiw	r24, 0x01	; 1
     fbc:	90 93 02 01 	sts	0x0102, r25
     fc0:	80 93 01 01 	sts	0x0101, r24
     fc4:	67 c0       	rjmp	.+206    	; 0x1094 <rxState+0x22a>
//      SET_BIT(TIFR2, OCF2A);
      TIFR2 = (1 << OCF2A);
    }
    break;
  case Main:                                    // Frequenz einstellen und Kalibrieren
    if((state.errorCount > 20) && !ReceiverInterrupt)     // 20 Telegramme nicht empfangen
     fc6:	80 91 a3 01 	lds	r24, 0x01A3
     fca:	85 31       	cpi	r24, 0x15	; 21
     fcc:	00 f1       	brcs	.+64     	; 0x100e <rxState+0x1a4>
     fce:	80 91 c8 01 	lds	r24, 0x01C8
     fd2:	88 23       	and	r24, r24
     fd4:	e1 f4       	brne	.+56     	; 0x100e <rxState+0x1a4>
    {
      cc2500Idle();
     fd6:	c9 d1       	rcall	.+914    	; 0x136a <cc2500Idle>
      state.actFreqIdx = 7;
     fd8:	87 e0       	ldi	r24, 0x07	; 7
     fda:	80 93 9b 01 	sts	0x019B, r24
      setNewRxFrequ();                // Frequenz auf 0 verstellen
     fde:	e6 dc       	rcall	.-1588   	; 0x9ac <setNewRxFrequ>
      setNextChanGoRx(3);                 // Kanal einstellen und Empfang ein
     fe0:	83 e0       	ldi	r24, 0x03	; 3
     fe2:	1f df       	rcall	.-450    	; 0xe22 <setNextChanGoRx>
      counter = 0;
     fe4:	10 92 02 01 	sts	0x0102, r1
     fe8:	10 92 01 01 	sts	0x0101, r1
      state.errorCount = 1;
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	80 93 a3 01 	sts	0x01A3, r24
      rxstate = waitForData;
     ff2:	82 e0       	ldi	r24, 0x02	; 2
     ff4:	80 93 03 01 	sts	0x0103, r24
//      state.synch = false;
      setTimer(CHANTIME2);
     ff8:	85 e8       	ldi	r24, 0x85	; 133
     ffa:	67 dc       	rcall	.-1842   	; 0x8ca <setTimer>
      if(state.scanCount < 0xff)
     ffc:	80 91 a4 01 	lds	r24, 0x01A4
    1000:	8f 3f       	cpi	r24, 0xFF	; 255
    1002:	09 f4       	brne	.+2      	; 0x1006 <rxState+0x19c>
    1004:	82 c0       	rjmp	.+260    	; 0x110a <rxState+0x2a0>
        ++state.scanCount;
    1006:	8f 5f       	subi	r24, 0xFF	; 255
    1008:	80 93 a4 01 	sts	0x01A4, r24
    100c:	7e c0       	rjmp	.+252    	; 0x110a <rxState+0x2a0>
    }
    else
    {
      if(ReceiverInterrupt)
    100e:	80 91 c8 01 	lds	r24, 0x01C8
    1012:	88 23       	and	r24, r24
    1014:	09 f4       	brne	.+2      	; 0x1018 <rxState+0x1ae>
    1016:	45 c0       	rjmp	.+138    	; 0x10a2 <rxState+0x238>
      {
        ReceiverInterrupt = false;
    1018:	10 92 c8 01 	sts	0x01C8, r1
        cc2500status = SPI_MasterTransmit(CC2500_FREQEST | CC2500_READ_BURST);
    101c:	82 ef       	ldi	r24, 0xF2	; 242
    101e:	a0 da       	rcall	.-2752   	; 0x560 <SPI_MasterTransmit>
    1020:	18 2f       	mov	r17, r24
        frequ = SPI_MasterTransmit(CC2500_SNOP);
    1022:	8d e3       	ldi	r24, 0x3D	; 61
    1024:	9d da       	rcall	.-2758   	; 0x560 <SPI_MasterTransmit>
    1026:	08 2f       	mov	r16, r24

        if((cc2500status & CC2500_STATUS_STATE_BM) != CC2500_STATE_RX)  // nicht mehr auf Empfang
    1028:	c1 2f       	mov	r28, r17
    102a:	d0 e0       	ldi	r29, 0x00	; 0
    102c:	c0 77       	andi	r28, 0x70	; 112
    102e:	d0 70       	andi	r29, 0x00	; 0
    1030:	c0 31       	cpi	r28, 0x10	; 16
    1032:	d1 05       	cpc	r29, r1
    1034:	09 f4       	brne	.+2      	; 0x1038 <rxState+0x1ce>
    1036:	69 c0       	rjmp	.+210    	; 0x110a <rxState+0x2a0>
        {
          if((cc2500status & CC2500_STATUS_STATE_BM) != CC2500_STATE_IDLE)  // Auch nicht auf Idle
    1038:	20 97       	sbiw	r28, 0x00	; 0
    103a:	09 f0       	breq	.+2      	; 0x103e <rxState+0x1d4>
            cc2500Idle();                                       // dann jetzt auf Idle
    103c:	96 d1       	rcall	.+812    	; 0x136a <cc2500Idle>
          if((data_len = cc2500status & CC2500_STATUS_FIFO_BYTES_AVAILABLE_BM) // Daten da und es war Idle
    103e:	1f 70       	andi	r17, 0x0F	; 15
    1040:	61 f1       	breq	.+88     	; 0x109a <rxState+0x230>
    1042:	cd 2b       	or	r28, r29
    1044:	51 f5       	brne	.+84     	; 0x109a <rxState+0x230>
              && ((cc2500status & CC2500_STATUS_STATE_BM) == CC2500_STATE_IDLE))
          {
            if(state.errorCount > 3)
    1046:	80 91 a3 01 	lds	r24, 0x01A3
    104a:	84 30       	cpi	r24, 0x04	; 4
    104c:	18 f0       	brcs	.+6      	; 0x1054 <rxState+0x1ea>
              setFrequencyOffset(frequ, false);      // Obwohl noch nicht klar ist ob Daten gut sind!
    104e:	80 2f       	mov	r24, r16
    1050:	60 e0       	ldi	r22, 0x00	; 0
    1052:	02 c0       	rjmp	.+4      	; 0x1058 <rxState+0x1ee>
            else
              setFrequencyOffset(frequ, true);      // Obwohl noch nicht klar ist ob Daten gut sind!
    1054:	80 2f       	mov	r24, r16
    1056:	61 e0       	ldi	r22, 0x01	; 1
    1058:	c1 dc       	rcall	.-1662   	; 0x9dc <setFrequencyOffset>
            if(state.RxCount < 7)                   // es kommt noch was
    105a:	80 91 98 01 	lds	r24, 0x0198
    105e:	87 30       	cpi	r24, 0x07	; 7
    1060:	10 f4       	brcc	.+4      	; 0x1066 <rxState+0x1fc>
              setNextChanGoRx(1);                      // wechselt auf Rx
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	de de       	rcall	.-580    	; 0xe22 <setNextChanGoRx>
            if(processData(data_len))                // state.RxCount wird hier geändert
    1066:	81 2f       	mov	r24, r17
    1068:	c0 de       	rcall	.-640    	; 0xdea <processData>
    106a:	88 23       	and	r24, r24
    106c:	09 f4       	brne	.+2      	; 0x1070 <rxState+0x206>
    106e:	4d c0       	rjmp	.+154    	; 0x110a <rxState+0x2a0>
            {
              adjTimer();                           // Timer initialisieren
    1070:	31 dc       	rcall	.-1950   	; 0x8d4 <adjTimer>
              if(state.RxCount >= 7)                // als nächstes kommt Telemetrie
    1072:	80 91 98 01 	lds	r24, 0x0198
    1076:	87 30       	cpi	r24, 0x07	; 7
    1078:	40 f0       	brcs	.+16     	; 0x108a <rxState+0x220>
              {
                calibrateSlow();
    107a:	84 d1       	rcall	.+776    	; 0x1384 <calibrateSlow>
                rxstate = TxOn;
    107c:	84 e0       	ldi	r24, 0x04	; 4
    107e:	80 93 03 01 	sts	0x0103, r24
                state.RxCount = 0;
    1082:	10 92 98 01 	sts	0x0198, r1
                setTimer(TELETIME02);   // in 0,6 ms bezogen auf Empfangsinterrupt Timer auslösen
    1086:	81 e1       	ldi	r24, 0x11	; 17
    1088:	04 c0       	rjmp	.+8      	; 0x1092 <rxState+0x228>
              }                                         // Es kommt dann nur Timerinterrupt weil Idle
              else
              {
                ++state.RxCount;
    108a:	8f 5f       	subi	r24, 0xFF	; 255
    108c:	80 93 98 01 	sts	0x0198, r24
                setTimer(CHANTIME + CHANTIME02 + 1);
    1090:	8f e4       	ldi	r24, 0x4F	; 79
    1092:	1b dc       	rcall	.-1994   	; 0x8ca <setTimer>
              }		
//              SET_BIT(TIFR2, OCF2A);
              TIFR2 = (1 << OCF2A);
    1094:	82 e0       	ldi	r24, 0x02	; 2
    1096:	87 bb       	out	0x17, r24	; 23
    1098:	38 c0       	rjmp	.+112    	; 0x110a <rxState+0x2a0>
//              setReceiveError();              // Antenne wechseln
              // hier ++state.RxCount ??
          }
          else
          {  // keine Daten oder kein Idle beim Interrupt
            cc2500CommandStrobe(CC2500_SFRX);           // Empfänger leeren
    109a:	8a e3       	ldi	r24, 0x3A	; 58
    109c:	81 d1       	rcall	.+770    	; 0x13a0 <cc2500CommandStrobe>
            setRx();                                    // und nochmal versuchen
    109e:	c8 dc       	rcall	.-1648   	; 0xa30 <setRx>
    10a0:	34 c0       	rjmp	.+104    	; 0x110a <rxState+0x2a0>
        }
      }
      else                              // Timerinterrupt
      {                                 // eventuell nachschauen ob Syncword empfangen
//        SET_BIT(TIFR2, OCF2A);
        TIFR2 = (1 << OCF2A);
    10a2:	82 e0       	ldi	r24, 0x02	; 2
    10a4:	87 bb       	out	0x17, r24	; 23
        cc2500Idle();
    10a6:	61 d1       	rcall	.+706    	; 0x136a <cc2500Idle>
        setReceiveError();              // Antenne wechseln
    10a8:	a8 da       	rcall	.-2736   	; 0x5fa <setReceiveError>
        if(state.RxCount >= 7)
    10aa:	80 91 98 01 	lds	r24, 0x0198
    10ae:	87 30       	cpi	r24, 0x07	; 7
    10b0:	40 f0       	brcs	.+16     	; 0x10c2 <rxState+0x258>
        {
          setTimer(TELETIME - CHANTIME02 + 1);
    10b2:	81 e5       	ldi	r24, 0x51	; 81
    10b4:	0a dc       	rcall	.-2028   	; 0x8ca <setTimer>
          calibrateSlow();
    10b6:	66 d1       	rcall	.+716    	; 0x1384 <calibrateSlow>
          sendTelemetrie();             // Da wir schon später dran sind sofort senden
    10b8:	d5 dc       	rcall	.-1622   	; 0xa64 <sendTelemetrie>
          rxstate = RxOn;
    10ba:	85 e0       	ldi	r24, 0x05	; 5
    10bc:	80 93 03 01 	sts	0x0103, r24
    10c0:	24 c0       	rjmp	.+72     	; 0x110a <rxState+0x2a0>
        }
        else
        {
          ++state.RxCount;
    10c2:	8f 5f       	subi	r24, 0xFF	; 255
    10c4:	80 93 98 01 	sts	0x0198, r24
          setNextChanGoRx(1);
    10c8:	81 e0       	ldi	r24, 0x01	; 1
    10ca:	ab de       	rcall	.-682    	; 0xe22 <setNextChanGoRx>
	  setTimer(CHANTIME);
    10cc:	82 e4       	ldi	r24, 0x42	; 66
    10ce:	fd db       	rcall	.-2054   	; 0x8ca <setTimer>
    10d0:	1c c0       	rjmp	.+56     	; 0x110a <rxState+0x2a0>
        }
      }
    }
    break;
  case TxOn:                      // Daten reinschreiben Sender einschalten und senden
    setTimer(TELETIME08);
    10d2:	8a e4       	ldi	r24, 0x4A	; 74
    10d4:	fa db       	rcall	.-2060   	; 0x8ca <setTimer>
    sendTelemetrie();
    10d6:	c6 dc       	rcall	.-1652   	; 0xa64 <sendTelemetrie>
    rxstate = RxOn;
    10d8:	85 e0       	ldi	r24, 0x05	; 5
    10da:	13 c0       	rjmp	.+38     	; 0x1102 <rxState+0x298>
    ReceiverInterrupt = false;
    break;
  case RxOn:                    // Senden fertig, Empfänger ein
    state.RxCount = 0;
    10dc:	10 92 98 01 	sts	0x0198, r1
    setTimer(CHANTIME + CHANTIME02 + 1);    // Verschiebung wieder herstellen
    10e0:	8f e4       	ldi	r24, 0x4F	; 79
    10e2:	f3 db       	rcall	.-2074   	; 0x8ca <setTimer>
//    TimerInterrupt = false;    Macht setTimer
    calibrateFast();
    10e4:	56 d1       	rcall	.+684    	; 0x1392 <calibrateFast>
    if(state.syncError)
    10e6:	80 91 9f 01 	lds	r24, 0x019F
    10ea:	88 23       	and	r24, r24
    10ec:	21 f0       	breq	.+8      	; 0x10f6 <rxState+0x28c>
    {
      setRx();
    10ee:	a0 dc       	rcall	.-1728   	; 0xa30 <setRx>
      state.syncError = false;
    10f0:	10 92 9f 01 	sts	0x019F, r1
    10f4:	02 c0       	rjmp	.+4      	; 0x10fa <rxState+0x290>
    }
    else
      setNextChanGoRx(1);
    10f6:	81 e0       	ldi	r24, 0x01	; 1
    10f8:	94 de       	rcall	.-728    	; 0xe22 <setNextChanGoRx>

//    SET_BIT(EIFR, INTF0);
    EIFR = 1 << INTF0;
    10fa:	81 e0       	ldi	r24, 0x01	; 1
    10fc:	8c bb       	out	0x1c, r24	; 28

    SET_BIT(EIMSK, INT0);                    // INT0 ein
    10fe:	e8 9a       	sbi	0x1d, 0	; 29

    rxstate = Main;
    1100:	83 e0       	ldi	r24, 0x03	; 3
    1102:	80 93 03 01 	sts	0x0103, r24
    ReceiverInterrupt = false;
    1106:	10 92 c8 01 	sts	0x01C8, r1
    break;
  }
}
    110a:	df 91       	pop	r29
    110c:	cf 91       	pop	r28
    110e:	1f 91       	pop	r17
    1110:	0f 91       	pop	r16
    1112:	08 95       	ret

00001114 <main>:
  }
}

int __attribute__((naked)) main(void)
{
  cli();
    1114:	f8 94       	cli
  CLKPR = 0;
    1116:	10 92 61 00 	sts	0x0061, r1
  PRR = 0;        // Powerreduction für ADC?
    111a:	10 92 64 00 	sts	0x0064, r1

  uint8_t i;
  for(i = 0;i < 3;++i)
  {
    if(mcusr_mirror & 1)                // Power on Reset
    111e:	80 91 c9 01 	lds	r24, 0x01C9
    1122:	48 2f       	mov	r20, r24
    1124:	50 e0       	ldi	r21, 0x00	; 0
    1126:	ba 01       	movw	r22, r20
    1128:	61 70       	andi	r22, 0x01	; 1
    112a:	70 70       	andi	r23, 0x00	; 0
    112c:	ea ec       	ldi	r30, 0xCA	; 202
    112e:	f1 e0       	ldi	r31, 0x01	; 1
    1130:	20 e0       	ldi	r18, 0x00	; 0
    1132:	30 e0       	ldi	r19, 0x00	; 0
      resetCounter[i] = 0;              // Alle löschen
    else if(mcusr_mirror & (2 << i))
    1134:	a2 e0       	ldi	r26, 0x02	; 2
    1136:	b0 e0       	ldi	r27, 0x00	; 0
  PRR = 0;        // Powerreduction für ADC?

  uint8_t i;
  for(i = 0;i < 3;++i)
  {
    if(mcusr_mirror & 1)                // Power on Reset
    1138:	61 15       	cp	r22, r1
    113a:	71 05       	cpc	r23, r1
    113c:	11 f0       	breq	.+4      	; 0x1142 <main+0x2e>
      resetCounter[i] = 0;              // Alle löschen
    113e:	10 82       	st	Z, r1
    1140:	0e c0       	rjmp	.+28     	; 0x115e <main+0x4a>
    else if(mcusr_mirror & (2 << i))
    1142:	cd 01       	movw	r24, r26
    1144:	02 2e       	mov	r0, r18
    1146:	02 c0       	rjmp	.+4      	; 0x114c <main+0x38>
    1148:	88 0f       	add	r24, r24
    114a:	99 1f       	adc	r25, r25
    114c:	0a 94       	dec	r0
    114e:	e2 f7       	brpl	.-8      	; 0x1148 <main+0x34>
    1150:	84 23       	and	r24, r20
    1152:	95 23       	and	r25, r21
    1154:	89 2b       	or	r24, r25
    1156:	19 f0       	breq	.+6      	; 0x115e <main+0x4a>
      ++resetCounter[i];      // 0 -> External Reset, 1 -> Brown-out Reset, 2 -> Watchdog System Reset
    1158:	80 81       	ld	r24, Z
    115a:	8f 5f       	subi	r24, 0xFF	; 255
    115c:	80 83       	st	Z, r24
    115e:	2f 5f       	subi	r18, 0xFF	; 255
    1160:	3f 4f       	sbci	r19, 0xFF	; 255
    1162:	31 96       	adiw	r30, 0x01	; 1
  cli();
  CLKPR = 0;
  PRR = 0;        // Powerreduction für ADC?

  uint8_t i;
  for(i = 0;i < 3;++i)
    1164:	23 30       	cpi	r18, 0x03	; 3
    1166:	31 05       	cpc	r19, r1
    1168:	39 f7       	brne	.-50     	; 0x1138 <main+0x24>
      resetCounter[i] = 0;              // Alle löschen
    else if(mcusr_mirror & (2 << i))
      ++resetCounter[i];      // 0 -> External Reset, 1 -> Brown-out Reset, 2 -> Watchdog System Reset
  }

  PORTB = (1<<OUT_B_SPI_SS) | (1<<OUT_B_PRE);
    116a:	95 e0       	ldi	r25, 0x05	; 5
    116c:	95 b9       	out	0x05, r25	; 5
  DDRB =  (1<<OUT_B_SPI_MOSI) | (1<<OUT_B_SPI_SCK) | (1<<OUT_B_SPI_SS) | (1<<OUT_B_PRE);
    116e:	8d e2       	ldi	r24, 0x2D	; 45
    1170:	84 b9       	out	0x04, r24	; 4
  PORTB = (1<<OUT_B_SPI_SS) | (1<<OUT_B_PRE)
    1172:	87 ed       	ldi	r24, 0xD7	; 215
    1174:	85 b9       	out	0x05, r24	; 5
      | ~((1<<OUT_B_SPI_MOSI) | (1<<OUT_B_SPI_SCK) | (1<<OUT_B_SPI_SS) | (1<<OUT_B_PRE));


  DDRC = (1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2) | (1 << OUT_C_CHANNEL3) |
    1176:	8f e3       	ldi	r24, 0x3F	; 63
    1178:	87 b9       	out	0x07, r24	; 7
         (1 << OUT_C_CHANNEL4) | (1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6);
  PORTC = ~((1 << OUT_C_CHANNEL1) | (1 << OUT_C_CHANNEL2) | (1 << OUT_C_CHANNEL3) |
    117a:	80 ec       	ldi	r24, 0xC0	; 192
    117c:	88 b9       	out	0x08, r24	; 8
         (1 << OUT_C_CHANNEL4) | (1 << OUT_C_CHANNEL5) | (1 << OUT_C_CHANNEL6));

  DDRD = (1 << OUT_D_LED) | (1 << OUT_D_ANT1) | (1 << OUT_D_ANT2) |
    117e:	83 ed       	ldi	r24, 0xD3	; 211
    1180:	8a b9       	out	0x0a, r24	; 10
         (1 << OUT_D_CHANNEL7) | (1 << OUT_D_CHANNEL8);
  PORTD = ~((1 << OUT_D_LED) | (1 << OUT_D_ANT1) | (1 << OUT_D_ANT2) |
    1182:	8c ea       	ldi	r24, 0xAC	; 172
    1184:	8b b9       	out	0x0b, r24	; 11
         (1 << OUT_D_CHANNEL7) | (1 << OUT_D_CHANNEL8)) | (1 << OUT_D_ANT2);

  LED_ON;
    1186:	5c 9a       	sbi	0x0b, 4	; 11

// Timer0 25 ms für LED und Failsafe
  TCCR0A = 0;                               //(2 << WGM00);
    1188:	14 bc       	out	0x24, r1	; 36
  TCCR0B = (5 << CS00);                     // clk/1024
    118a:	95 bd       	out	0x25, r25	; 37
  OCR0A = (F_CPU * 10 / 1024 / 400 - 1);
    118c:	82 ec       	ldi	r24, 0xC2	; 194
    118e:	87 bd       	out	0x27, r24	; 39
//  TIFR0 = 0xff;
  TIMSK0 = 0;
    1190:	10 92 6e 00 	sts	0x006E, r1

// Timer1 8MHz   Servoausgänge
  TCCR1A = 0;
    1194:	10 92 80 00 	sts	0x0080, r1
  TCCR1B = 0;
    1198:	10 92 81 00 	sts	0x0081, r1
  OCR1B = (INTERRUPTOFFSET + 0x3ff) * 8;            // Wenn PPM- Signal ~2,5ms überschreitet ist es ganz schlecht
    119c:	88 ed       	ldi	r24, 0xD8	; 216
    119e:	9e e4       	ldi	r25, 0x4E	; 78
    11a0:	90 93 8b 00 	sts	0x008B, r25
    11a4:	80 93 8a 00 	sts	0x008A, r24
//  OCR1A = 500 * 8;        // in 500us beginnen


// Timer2 1ms für Timeout
//  TCCR2A = 0;
  TCCR2A = (2 << WGM20);                        //  CTC mode
    11a8:	32 e0       	ldi	r19, 0x02	; 2
    11aa:	30 93 b0 00 	sts	0x00B0, r19
//  TCCR2B = (3 << CS20);                         // clk/32
  TCCR2B = (6 << CS20);                         // clk/256
    11ae:	86 e0       	ldi	r24, 0x06	; 6
    11b0:	80 93 b1 00 	sts	0x00B1, r24

  OCR2A  = CHANTIME;
    11b4:	82 e4       	ldi	r24, 0x42	; 66
    11b6:	80 93 b3 00 	sts	0x00B3, r24
  TCNT2 = 0;
    11ba:	10 92 b2 00 	sts	0x00B2, r1
//  TIFR2  = 0xff;
  TIMSK2 = 0;
    11be:	10 92 70 00 	sts	0x0070, r1

  wdt_enable(WDTO_500MS);
    11c2:	2d e0       	ldi	r18, 0x0D	; 13
    11c4:	88 e1       	ldi	r24, 0x18	; 24
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	0f b6       	in	r0, 0x3f	; 63
    11ca:	f8 94       	cli
    11cc:	a8 95       	wdr
    11ce:	80 93 60 00 	sts	0x0060, r24
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	20 93 60 00 	sts	0x0060, r18
  EICRA = 1 << ISC01;           // int0 bei fallender Flanke
    11d8:	30 93 69 00 	sts	0x0069, r19
  EIMSK = 0;
    11dc:	1d ba       	out	0x1d, r1	; 29

//  EIFR = 0xff;
  state.minAb = 0x17;
    11de:	87 e1       	ldi	r24, 0x17	; 23
    11e0:	80 93 b1 01 	sts	0x01B1, r24

  eeprom_read_block(&eeprom, 0, sizeof(eeprom));
    11e4:	84 e4       	ldi	r24, 0x44	; 68
    11e6:	91 e0       	ldi	r25, 0x01	; 1
    11e8:	60 e0       	ldi	r22, 0x00	; 0
    11ea:	70 e0       	ldi	r23, 0x00	; 0
    11ec:	4e e2       	ldi	r20, 0x2E	; 46
    11ee:	50 e0       	ldi	r21, 0x00	; 0
    11f0:	8e d1       	rcall	.+796    	; 0x150e <__eerd_block_m88>
  cc2500_Init(0xff);
    11f2:	8f ef       	ldi	r24, 0xFF	; 255
    11f4:	5a d1       	rcall	.+692    	; 0x14aa <cc2500_Init>
  if(!checkcc2500())
    11f6:	1a d1       	rcall	.+564    	; 0x142c <checkcc2500>
    11f8:	88 23       	and	r24, r24
    11fa:	29 f4       	brne	.+10     	; 0x1206 <main+0xf2>
    SET_BIT(state.ledError, L_INIT_ERROR);
    11fc:	80 91 a2 01 	lds	r24, 0x01A2
    1200:	80 68       	ori	r24, 0x80	; 128
    1202:	80 93 a2 01 	sts	0x01A2, r24
  cc2500WriteReg(CC2500_SYNC0,(unsigned char)eeprom.bind.id);
    1206:	85 e0       	ldi	r24, 0x05	; 5
    1208:	60 91 44 01 	lds	r22, 0x0144
    120c:	9d d0       	rcall	.+314    	; 0x1348 <cc2500WriteReg>
  cc2500WriteReg(CC2500_SYNC1,(unsigned char)(eeprom.bind.id >> 8));
    120e:	60 91 44 01 	lds	r22, 0x0144
    1212:	70 91 45 01 	lds	r23, 0x0145
    1216:	67 2f       	mov	r22, r23
    1218:	77 27       	eor	r23, r23
    121a:	84 e0       	ldi	r24, 0x04	; 4
    121c:	95 d0       	rcall	.+298    	; 0x1348 <cc2500WriteReg>
  set_sleep_mode(SLEEP_MODE_IDLE);
    121e:	83 b7       	in	r24, 0x33	; 51
    1220:	81 7f       	andi	r24, 0xF1	; 241
    1222:	83 bf       	out	0x33, r24	; 51
  wdt_enable(WDTO_30MS);
    1224:	29 e0       	ldi	r18, 0x09	; 9
    1226:	88 e1       	ldi	r24, 0x18	; 24
    1228:	90 e0       	ldi	r25, 0x00	; 0
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	f8 94       	cli
    122e:	a8 95       	wdr
    1230:	80 93 60 00 	sts	0x0060, r24
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	20 93 60 00 	sts	0x0060, r18
  LED_OFF;
    123a:	5c 98       	cbi	0x0b, 4	; 11
  output.latenzMin = 0xff;
    123c:	8f ef       	ldi	r24, 0xFF	; 255
    123e:	80 93 91 01 	sts	0x0191, r24

  EIFR = 1 << INTF0;
    1242:	81 e0       	ldi	r24, 0x01	; 1
    1244:	8c bb       	out	0x1c, r24	; 28
  SET_BIT(EIMSK, INT0);                    // INT0 ein
    1246:	e8 9a       	sbi	0x1d, 0	; 29

  TIFR2 = (1 << OCF2A);
    1248:	82 e0       	ldi	r24, 0x02	; 2
    124a:	87 bb       	out	0x17, r24	; 23
//  SET_BIT(TIFR2, OCF2A);
  ReceiverInterrupt = false;
    124c:	10 92 c8 01 	sts	0x01C8, r1
  sei();
    1250:	78 94       	sei
  getFailSafe();                // FailSafe- Werte als Default, damit die Servos bei Einschalten nicht weglaufen
    1252:	f5 d9       	rcall	.-3094   	; 0x63e <getFailSafe>
  setupPulses(false);
    1254:	80 e0       	ldi	r24, 0x00	; 0
    1256:	2a d8       	rcall	.-4012   	; 0x2ac <setupPulses>

    static uint8_t FailSafeTimer;
    if(TIFR0 & (1 << OCF0B)) // 1,024 ms
    {
//      SET_BIT(TIFR0,OCF0B);
      TIFR0 = (1 << OCF0B);
    1258:	14 e0       	ldi	r17, 0x04	; 4
      }
    }
    if(TIFR0 & (1 << OCF0A))
    {
      OCR0A += (F_CPU * 10 / 1024 / 400);
      TIFR0 = (1 << OCF0A);
    125a:	02 e0       	ldi	r16, 0x02	; 2
  ReceiverInterrupt = false;
  sei();
  getFailSafe();                // FailSafe- Werte als Default, damit die Servos bei Einschalten nicht weglaufen
  setupPulses(false);
  while(1){
    cc2500_Off();
    125c:	bc d9       	rcall	.-3208   	; 0x5d6 <cc2500_Off>
    sei();
    125e:	78 94       	sei
    //nur bei Timer 1ms Interrupt oder Int0, nicht bei PPM- Interrupt
    if((TIFR2 & (1 << OCF2A)) || ReceiverInterrupt)
    1260:	b9 99       	sbic	0x17, 1	; 23
    1262:	03 c0       	rjmp	.+6      	; 0x126a <main+0x156>
    1264:	80 91 c8 01 	lds	r24, 0x01C8
    1268:	81 11       	cpse	r24, r1
    {
      rxState();
    126a:	ff dd       	rcall	.-1026   	; 0xe6a <rxState>
//      if(state.errorCount)
//        state.led = false;
    }

    static uint8_t FailSafeTimer;
    if(TIFR0 & (1 << OCF0B)) // 1,024 ms
    126c:	aa 9b       	sbis	0x15, 2	; 21
    126e:	2f c0       	rjmp	.+94     	; 0x12ce <main+0x1ba>
    {
//      SET_BIT(TIFR0,OCF0B);
      TIFR0 = (1 << OCF0B);
    1270:	15 bb       	out	0x15, r17	; 21
      OCR0B += (F_CPU * 10 / 1024 / 9765);
    1272:	88 b5       	in	r24, 0x28	; 40
    1274:	88 5f       	subi	r24, 0xF8	; 248
    1276:	88 bd       	out	0x28, r24	; 40
      ++FailSafeTimer;
    1278:	80 91 00 01 	lds	r24, 0x0100
    127c:	8f 5f       	subi	r24, 0xFF	; 255
    127e:	80 93 00 01 	sts	0x0100, r24
      if(FailSafeTimer > 20)
    1282:	85 31       	cpi	r24, 0x15	; 21
    1284:	18 f0       	brcs	.+6      	; 0x128c <main+0x178>
      {
        FailSafeTimer = 0;
    1286:	10 92 00 01 	sts	0x0100, r1
        tstFailSafe();
    128a:	15 da       	rcall	.-3030   	; 0x6b6 <tstFailSafe>
      }
      checkPulses();
    128c:	44 db       	rcall	.-2424   	; 0x916 <checkPulses>
      if(++output.pulsesOffset > 25)
    128e:	80 91 86 01 	lds	r24, 0x0186
    1292:	8f 5f       	subi	r24, 0xFF	; 255
    1294:	80 93 86 01 	sts	0x0186, r24
    1298:	8a 31       	cpi	r24, 0x1A	; 26
    129a:	10 f0       	brcs	.+4      	; 0x12a0 <main+0x18c>
        setupPulses(false);
    129c:	80 e0       	ldi	r24, 0x00	; 0
    129e:	06 d8       	rcall	.-4084   	; 0x2ac <setupPulses>
      if(output.pulsesOffset == eeprom.outputOffset)         // Versatz zwischen den Gruppen
    12a0:	90 91 86 01 	lds	r25, 0x0186
    12a4:	80 91 67 01 	lds	r24, 0x0167
    12a8:	98 17       	cp	r25, r24
    12aa:	11 f4       	brne	.+4      	; 0x12b0 <main+0x19c>
        setupPulses(true);
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	fe d7       	rcall	.+4092   	; 0x22ac <_etext+0xd46>

      if((TIFR1 & (1 << OCF1B)) && (state.ppmOverflow < 0xff))
    12b0:	b2 9b       	sbis	0x16, 2	; 22
    12b2:	0d c0       	rjmp	.+26     	; 0x12ce <main+0x1ba>
    12b4:	80 91 a1 01 	lds	r24, 0x01A1
    12b8:	8f 3f       	cpi	r24, 0xFF	; 255
    12ba:	49 f0       	breq	.+18     	; 0x12ce <main+0x1ba>
      {
        ++state.ppmOverflow;
    12bc:	8f 5f       	subi	r24, 0xFF	; 255
    12be:	80 93 a1 01 	sts	0x01A1, r24
//        SET_BIT(TIFR1, OCF1B);
        TIFR1 = (1 << OCF1B);
    12c2:	16 bb       	out	0x16, r17	; 22
        ++state.minAb;
    12c4:	80 91 b1 01 	lds	r24, 0x01B1
    12c8:	8f 5f       	subi	r24, 0xFF	; 255
    12ca:	80 93 b1 01 	sts	0x01B1, r24
      }
    }
    if(TIFR0 & (1 << OCF0A))
    12ce:	a9 9b       	sbis	0x15, 1	; 21
    12d0:	34 c0       	rjmp	.+104    	; 0x133a <main+0x226>
    {
      OCR0A += (F_CPU * 10 / 1024 / 400);
    12d2:	87 b5       	in	r24, 0x27	; 39
    12d4:	8d 53       	subi	r24, 0x3D	; 61
    12d6:	87 bd       	out	0x27, r24	; 39
      TIFR0 = (1 << OCF0A);
    12d8:	05 bb       	out	0x15, r16	; 21
//      SET_BIT(TIFR0,OCF0A);
      ++Timer25ms;
    12da:	80 91 93 01 	lds	r24, 0x0193
    12de:	90 91 94 01 	lds	r25, 0x0194
    12e2:	01 96       	adiw	r24, 0x01	; 1
    12e4:	90 93 94 01 	sts	0x0194, r25
    12e8:	80 93 93 01 	sts	0x0193, r24
      if(!Timer25ms)
    12ec:	80 91 93 01 	lds	r24, 0x0193
    12f0:	90 91 94 01 	lds	r25, 0x0194
    12f4:	89 2b       	or	r24, r25
    12f6:	29 f4       	brne	.+10     	; 0x1302 <main+0x1ee>
        RES_BIT(state.ledError, L_SET_FAILSAVE);
    12f8:	80 91 a2 01 	lds	r24, 0x01A2
    12fc:	8e 7f       	andi	r24, 0xFE	; 254
    12fe:	80 93 a2 01 	sts	0x01A2, r24
      set_led();
    1302:	82 da       	rcall	.-2812   	; 0x808 <set_led>
      if(checkKey())
    1304:	7a da       	rcall	.-2828   	; 0x7fa <checkKey>
    1306:	88 23       	and	r24, r24
    1308:	c1 f0       	breq	.+48     	; 0x133a <main+0x226>
      {
        state.errorSum = 0;
    130a:	10 92 a5 01 	sts	0x01A5, r1
    130e:	10 92 a6 01 	sts	0x01A6, r1
    1312:	10 92 a7 01 	sts	0x01A7, r1
    1316:	10 92 a8 01 	sts	0x01A8, r1
        state.frameLost = 0;
    131a:	10 92 ae 01 	sts	0x01AE, r1
    131e:	10 92 ad 01 	sts	0x01AD, r1
        state.scanCount = 0;
    1322:	10 92 a4 01 	sts	0x01A4, r1
        state.ppmOverflow = 0;
    1326:	10 92 a1 01 	sts	0x01A1, r1
        state.okSum = 0;
    132a:	10 92 a9 01 	sts	0x01A9, r1
    132e:	10 92 aa 01 	sts	0x01AA, r1
    1332:	10 92 ab 01 	sts	0x01AB, r1
    1336:	10 92 ac 01 	sts	0x01AC, r1
      }
    }
    wdt_reset();
    133a:	a8 95       	wdr
    133c:	8f cf       	rjmp	.-226    	; 0x125c <main+0x148>

0000133e <cc2500ReadReg>:
      cc2500Idle();
}

uint8_t cc2500ReadReg(uint8_t reg)
{
  SPI_MasterTransmit(reg | CC2500_READ_SINGLE);
    133e:	80 68       	ori	r24, 0x80	; 128
    1340:	0f d9       	rcall	.-3554   	; 0x560 <SPI_MasterTransmit>
  return(SPI_MasterTransmit(CC2500_SNOP));
    1342:	8d e3       	ldi	r24, 0x3D	; 61
    1344:	0d d9       	rcall	.-3558   	; 0x560 <SPI_MasterTransmit>
}
    1346:	08 95       	ret

00001348 <cc2500WriteReg>:
  SPI_MasterTransmit(reg | CC2500_READ_BURST);
  return(SPI_MasterTransmit(CC2500_SNOP));
}

uint8_t cc2500WriteReg(uint8_t reg, uint8_t c)
{
    1348:	1f 93       	push	r17
    134a:	16 2f       	mov	r17, r22
  SPI_MasterTransmit(reg & ~CC2500_READ_SINGLE);
    134c:	8f 77       	andi	r24, 0x7F	; 127
    134e:	08 d9       	rcall	.-3568   	; 0x560 <SPI_MasterTransmit>
  return(SPI_MasterTransmit(c));
    1350:	81 2f       	mov	r24, r17
    1352:	06 d9       	rcall	.-3572   	; 0x560 <SPI_MasterTransmit>
}
    1354:	1f 91       	pop	r17
    1356:	08 95       	ret

00001358 <cc2500ReadStatusReg>:
  return(SPI_MasterTransmit(CC2500_SNOP) & CC2500_STATUS_STATE_BM);
}

uint8_t cc2500ReadStatusReg(uint8_t reg)
{
  SPI_MasterTransmit(reg | CC2500_READ_BURST);
    1358:	80 6c       	ori	r24, 0xC0	; 192
    135a:	02 d9       	rcall	.-3580   	; 0x560 <SPI_MasterTransmit>
  return(SPI_MasterTransmit(CC2500_SNOP));
    135c:	8d e3       	ldi	r24, 0x3D	; 61
    135e:	00 d9       	rcall	.-3584   	; 0x560 <SPI_MasterTransmit>
}
    1360:	08 95       	ret

00001362 <cc2500GetState>:
  SPI_MasterTransmit(str);
}

uint8_t cc2500GetState(void)
{
  return(SPI_MasterTransmit(CC2500_SNOP) & CC2500_STATUS_STATE_BM);
    1362:	8d e3       	ldi	r24, 0x3D	; 61
    1364:	fd d8       	rcall	.-3590   	; 0x560 <SPI_MasterTransmit>
}
    1366:	80 77       	andi	r24, 0x70	; 112
    1368:	08 95       	ret

0000136a <cc2500Idle>:
  cc2500_Off();
}

void cc2500Idle(void)
{
  if((SPI_MasterTransmit(CC2500_SIDLE) & CC2500_STATUS_STATE_BM) != CC2500_STATE_IDLE)
    136a:	86 e3       	ldi	r24, 0x36	; 54
    136c:	f9 d8       	rcall	.-3598   	; 0x560 <SPI_MasterTransmit>
    136e:	80 77       	andi	r24, 0x70	; 112
    1370:	88 23       	and	r24, r24
    1372:	11 f0       	breq	.+4      	; 0x1378 <cc2500Idle+0xe>
    while(cc2500GetState() != CC2500_STATE_IDLE);   // Status lesen
    1374:	f6 df       	rcall	.-20     	; 0x1362 <cc2500GetState>
    1376:	fc cf       	rjmp	.-8      	; 0x1370 <cc2500Idle+0x6>
    1378:	08 95       	ret

0000137a <cc2500WriteRegCheckIdle>:
  return(SPI_MasterTransmit(c));
}

void cc2500WriteRegCheckIdle(uint8_t reg, uint8_t c)
{
  if((cc2500WriteReg(reg, c) & CC2500_STATUS_STATE_BM) != CC2500_STATE_IDLE)
    137a:	e6 df       	rcall	.-52     	; 0x1348 <cc2500WriteReg>
    137c:	80 77       	andi	r24, 0x70	; 112
    137e:	09 f0       	breq	.+2      	; 0x1382 <cc2500WriteRegCheckIdle+0x8>
      cc2500Idle();
    1380:	f4 df       	rcall	.-24     	; 0x136a <cc2500Idle>
    1382:	08 95       	ret

00001384 <calibrateSlow>:
  cc2500WriteRegCheckIdle(CC2500_FSCAL3, cc2500ReadReg(CC2500_FSCAL3) & ~0x20);
}

void calibrateSlow(void)
{
  cc2500WriteRegCheckIdle(CC2500_FSCAL3, (cc2500ReadReg(CC2500_FSCAL3) & ~0x20) | 0x20);
    1384:	83 e2       	ldi	r24, 0x23	; 35
    1386:	db df       	rcall	.-74     	; 0x133e <cc2500ReadReg>
    1388:	68 2f       	mov	r22, r24
    138a:	60 62       	ori	r22, 0x20	; 32
    138c:	83 e2       	ldi	r24, 0x23	; 35
    138e:	f5 df       	rcall	.-22     	; 0x137a <cc2500WriteRegCheckIdle>
}
    1390:	08 95       	ret

00001392 <calibrateFast>:
}

void calibrateFast(void)	                   //Disable charge pump calibration stage when 0
{

  cc2500WriteRegCheckIdle(CC2500_FSCAL3, cc2500ReadReg(CC2500_FSCAL3) & ~0x20);
    1392:	83 e2       	ldi	r24, 0x23	; 35
    1394:	d4 df       	rcall	.-88     	; 0x133e <cc2500ReadReg>
    1396:	68 2f       	mov	r22, r24
    1398:	6f 7d       	andi	r22, 0xDF	; 223
    139a:	83 e2       	ldi	r24, 0x23	; 35
    139c:	ee df       	rcall	.-36     	; 0x137a <cc2500WriteRegCheckIdle>
}
    139e:	08 95       	ret

000013a0 <cc2500CommandStrobe>:
  SMARTRF_SETTING_TEST0         //    TEST0  2e
};

void cc2500CommandStrobe(uint8_t str)
{
  SPI_MasterTransmit(str);
    13a0:	df d8       	rcall	.-3650   	; 0x560 <SPI_MasterTransmit>
}
    13a2:	08 95       	ret

000013a4 <cc2500setPatableMax>:
  while(n--)
    *p++ =cc2500ReadReg(CC2500_RXFIFO);
}

void cc2500setPatableMax(uint8_t power)
{
    13a4:	0f 93       	push	r16
    13a6:	1f 93       	push	r17
    13a8:	08 2f       	mov	r16, r24
  uint8_t i;
  SPI_MasterTransmit(CC2500_PATABLE | CC2500_WRITE_BURST);
    13aa:	8e e7       	ldi	r24, 0x7E	; 126
    13ac:	d9 d8       	rcall	.-3662   	; 0x560 <SPI_MasterTransmit>
    13ae:	10 e0       	ldi	r17, 0x00	; 0
  for(i = 0; i < 8; ++i)                 //// 8!!
    SPI_MasterTransmit(power);
    13b0:	80 2f       	mov	r24, r16
    13b2:	d6 d8       	rcall	.-3668   	; 0x560 <SPI_MasterTransmit>

void cc2500setPatableMax(uint8_t power)
{
  uint8_t i;
  SPI_MasterTransmit(CC2500_PATABLE | CC2500_WRITE_BURST);
  for(i = 0; i < 8; ++i)                 //// 8!!
    13b4:	1f 5f       	subi	r17, 0xFF	; 255
    13b6:	18 30       	cpi	r17, 0x08	; 8
    13b8:	d9 f7       	brne	.-10     	; 0x13b0 <cc2500setPatableMax+0xc>
    SPI_MasterTransmit(power);
  cc2500_Off();
    13ba:	0d d9       	rcall	.-3558   	; 0x5d6 <cc2500_Off>
}
    13bc:	1f 91       	pop	r17
    13be:	0f 91       	pop	r16
    13c0:	08 95       	ret

000013c2 <cc2500WriteFIFOBlock>:
  cc2500_Off();                      // Burstzugriff rücksetzen
  return(true);
}

uint8_t cc2500WriteFIFOBlock(uint8_t *p, uint8_t n)
{
    13c2:	0f 93       	push	r16
    13c4:	1f 93       	push	r17
    13c6:	cf 93       	push	r28
    13c8:	df 93       	push	r29
    13ca:	ec 01       	movw	r28, r24
    13cc:	16 2f       	mov	r17, r22
  uint8_t ret = 0;
  SPI_MasterTransmit(CC2500_WRITE_BURST | CC2500_TXFIFO);
    13ce:	8f e7       	ldi	r24, 0x7F	; 127
    13d0:	c7 d8       	rcall	.-3698   	; 0x560 <SPI_MasterTransmit>
    13d2:	00 e0       	ldi	r16, 0x00	; 0
    13d4:	04 c0       	rjmp	.+8      	; 0x13de <cc2500WriteFIFOBlock+0x1c>
  while(n--)
    ret = SPI_MasterTransmit(*p++);
    13d6:	89 91       	ld	r24, Y+
    13d8:	c3 d8       	rcall	.-3706   	; 0x560 <SPI_MasterTransmit>
    13da:	08 2f       	mov	r16, r24
    13dc:	11 50       	subi	r17, 0x01	; 1

uint8_t cc2500WriteFIFOBlock(uint8_t *p, uint8_t n)
{
  uint8_t ret = 0;
  SPI_MasterTransmit(CC2500_WRITE_BURST | CC2500_TXFIFO);
  while(n--)
    13de:	11 23       	and	r17, r17
    13e0:	d1 f7       	brne	.-12     	; 0x13d6 <cc2500WriteFIFOBlock+0x14>
    ret = SPI_MasterTransmit(*p++);
  cc2500_Off();                      // Burstzugriff rücksetzen
    13e2:	f9 d8       	rcall	.-3598   	; 0x5d6 <cc2500_Off>
  return(ret);
}
    13e4:	80 2f       	mov	r24, r16
    13e6:	df 91       	pop	r29
    13e8:	cf 91       	pop	r28
    13ea:	1f 91       	pop	r17
    13ec:	0f 91       	pop	r16
    13ee:	08 95       	ret

000013f0 <cc2500ReadFIFOBlock>:
  SPI_MasterTransmit(CC2500_READ_SINGLE | CC2500_RXFIFO);
  return(SPI_MasterTransmit(CC2500_SNOP));
}

bool cc2500ReadFIFOBlock(uint8_t *p, uint8_t n)
{
    13f0:	1f 93       	push	r17
    13f2:	cf 93       	push	r28
    13f4:	df 93       	push	r29
    13f6:	ec 01       	movw	r28, r24
    13f8:	16 2f       	mov	r17, r22
  if(n != (SPI_MasterTransmit(CC2500_RXFIFO | CC2500_READ_BURST) & CC2500_STATUS_FIFO_BYTES_AVAILABLE_BM))
    13fa:	8f ef       	ldi	r24, 0xFF	; 255
    13fc:	b1 d8       	rcall	.-3742   	; 0x560 <SPI_MasterTransmit>
    13fe:	21 2f       	mov	r18, r17
    1400:	30 e0       	ldi	r19, 0x00	; 0
    1402:	90 e0       	ldi	r25, 0x00	; 0
    1404:	8f 70       	andi	r24, 0x0F	; 15
    1406:	90 70       	andi	r25, 0x00	; 0
    1408:	28 17       	cp	r18, r24
    140a:	39 07       	cpc	r19, r25
    140c:	39 f0       	breq	.+14     	; 0x141c <cc2500ReadFIFOBlock+0x2c>
  {
    cc2500_Off();                      // Burstzugriff rücksetzen
    140e:	e3 d8       	rcall	.-3642   	; 0x5d6 <cc2500_Off>
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	08 c0       	rjmp	.+16     	; 0x1424 <cc2500ReadFIFOBlock+0x34>
    return(false);
  }
  while(n--)
    *p++ = SPI_MasterTransmit(CC2500_SNOP);
    1414:	8d e3       	ldi	r24, 0x3D	; 61
    1416:	a4 d8       	rcall	.-3768   	; 0x560 <SPI_MasterTransmit>
    1418:	89 93       	st	Y+, r24
    141a:	11 50       	subi	r17, 0x01	; 1
  if(n != (SPI_MasterTransmit(CC2500_RXFIFO | CC2500_READ_BURST) & CC2500_STATUS_FIFO_BYTES_AVAILABLE_BM))
  {
    cc2500_Off();                      // Burstzugriff rücksetzen
    return(false);
  }
  while(n--)
    141c:	11 23       	and	r17, r17
    141e:	d1 f7       	brne	.-12     	; 0x1414 <cc2500ReadFIFOBlock+0x24>
    *p++ = SPI_MasterTransmit(CC2500_SNOP);
  cc2500_Off();                      // Burstzugriff rücksetzen
    1420:	da d8       	rcall	.-3660   	; 0x5d6 <cc2500_Off>
    1422:	81 e0       	ldi	r24, 0x01	; 1
  return(true);
}
    1424:	df 91       	pop	r29
    1426:	cf 91       	pop	r28
    1428:	1f 91       	pop	r17
    142a:	08 95       	ret

0000142c <checkcc2500>:
  cc2500_Off();                    // SS wegnehmen wegen Burst
  cc2500setPatableMax(power);
}

bool checkcc2500(void)
{
    142c:	1f 93       	push	r17
    142e:	cf 93       	push	r28
    1430:	df 93       	push	r29
    1432:	88 ee       	ldi	r24, 0xE8	; 232
    1434:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1436:	28 ec       	ldi	r18, 0xC8	; 200
    1438:	30 e0       	ldi	r19, 0x00	; 0
    143a:	f9 01       	movw	r30, r18
    143c:	31 97       	sbiw	r30, 0x01	; 1
    143e:	f1 f7       	brne	.-4      	; 0x143c <checkcc2500+0x10>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1440:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1442:	d9 f7       	brne	.-10     	; 0x143a <checkcc2500+0xe>
  prog_uint8_t *init = cc2500InitValue;
  bool f = true;

  _delay_ms(100);
  SPI_MasterTransmit(CC2500_IOCFG2 | CC2500_READ_BURST);
    1444:	80 ec       	ldi	r24, 0xC0	; 192
    1446:	8c d8       	rcall	.-3816   	; 0x560 <SPI_MasterTransmit>
    1448:	cb e5       	ldi	r28, 0x5B	; 91
    144a:	d0 e0       	ldi	r29, 0x00	; 0
    144c:	11 e0       	ldi	r17, 0x01	; 1
  do
  {
    if(SPI_MasterTransmit(0) != pgm_read_byte(init++))
    144e:	80 e0       	ldi	r24, 0x00	; 0
    1450:	87 d8       	rcall	.-3826   	; 0x560 <SPI_MasterTransmit>
    1452:	fe 01       	movw	r30, r28
    1454:	21 96       	adiw	r28, 0x01	; 1
    1456:	e4 91       	lpm	r30, Z+
    1458:	8e 13       	cpse	r24, r30
    145a:	10 e0       	ldi	r17, 0x00	; 0
      f = false;
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue) - 3));
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	c5 38       	cpi	r28, 0x85	; 133
    1460:	d8 07       	cpc	r29, r24
    1462:	a8 f3       	brcs	.-22     	; 0x144e <checkcc2500+0x22>
  cc2500_Off();                    // SS wegnehmen wegen Burst
    1464:	b8 d8       	rcall	.-3728   	; 0x5d6 <cc2500_Off>
  SPI_MasterTransmit(CC2500_TEST2 | CC2500_READ_BURST);
    1466:	8c ee       	ldi	r24, 0xEC	; 236
    1468:	7b d8       	rcall	.-3850   	; 0x560 <SPI_MasterTransmit>
  do
  {
    if(SPI_MasterTransmit(0) != pgm_read_byte(init++))
    146a:	80 e0       	ldi	r24, 0x00	; 0
    146c:	79 d8       	rcall	.-3854   	; 0x560 <SPI_MasterTransmit>
    146e:	fe 01       	movw	r30, r28
    1470:	21 96       	adiw	r28, 0x01	; 1
    1472:	e4 91       	lpm	r30, Z+
    1474:	8e 13       	cpse	r24, r30
    1476:	10 e0       	ldi	r17, 0x00	; 0
      f = false;
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue)));
    1478:	80 e0       	ldi	r24, 0x00	; 0
    147a:	c8 38       	cpi	r28, 0x88	; 136
    147c:	d8 07       	cpc	r29, r24
    147e:	a8 f3       	brcs	.-22     	; 0x146a <checkcc2500+0x3e>
  cc2500_Off();                    // SS wegnehmen wegen Burst
    1480:	aa d8       	rcall	.-3756   	; 0x5d6 <cc2500_Off>
  return f;
}
    1482:	81 2f       	mov	r24, r17
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	1f 91       	pop	r17
    148a:	08 95       	ret

0000148c <SPI_MasterInit>:
#include "ORC.h"

void SPI_MasterInit(void)
{
  /* Set MOSI and SCK and SS output, all others input */
  cc2500_Off();
    148c:	a4 d8       	rcall	.-3768   	; 0x5d6 <cc2500_Off>
//  SPSR = 0;
  /* Enable SPI, Master, set clock rate fck/4 */
  SPCR = (1<<SPE) | (1<<MSTR); // | (1<<SPR0);       //fck/16
    148e:	80 e5       	ldi	r24, 0x50	; 80
    1490:	8c bd       	out	0x2c, r24	; 44
}
    1492:	08 95       	ret

00001494 <cc2500_Reset>:

void cc2500_Reset(void)
{
  cc2500CommandStrobe(CC2500_SRES);
    1494:	80 e3       	ldi	r24, 0x30	; 48
    1496:	84 df       	rcall	.-248    	; 0x13a0 <cc2500CommandStrobe>
    1498:	01 c0       	rjmp	.+2      	; 0x149c <cc2500_Reset+0x8>
  while(!(PINB & (1 << INP_B_SPI_MISO))) NOP();       // warten bis high
    149a:	00 00       	nop
    149c:	1c 9b       	sbis	0x03, 4	; 3
    149e:	fd cf       	rjmp	.-6      	; 0x149a <cc2500_Reset+0x6>
    14a0:	01 c0       	rjmp	.+2      	; 0x14a4 <cc2500_Reset+0x10>
  while(PINB & (1 << INP_B_SPI_MISO)) NOP();          // warten bis low
    14a2:	00 00       	nop
    14a4:	1c 99       	sbic	0x03, 4	; 3
    14a6:	fd cf       	rjmp	.-6      	; 0x14a2 <cc2500_Reset+0xe>
}
    14a8:	08 95       	ret

000014aa <cc2500_Init>:

void cc2500_Init(uint8_t power)
{
    14aa:	0f 93       	push	r16
    14ac:	1f 93       	push	r17
    14ae:	cf 93       	push	r28
    14b0:	df 93       	push	r29
    14b2:	08 2f       	mov	r16, r24
  prog_uint8_t *init = cc2500InitValue;

  SET_BIT(PORTB, OUT_B_SPI_SCK);
    14b4:	2d 9a       	sbi	0x05, 5	; 5
  RES_BIT(PORTB, OUT_B_SPI_MOSI);
    14b6:	2b 98       	cbi	0x05, 3	; 5
  RES_BIT(PORTB, OUT_B_SPI_SS);
    14b8:	2a 98       	cbi	0x05, 2	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    14ba:	1a e6       	ldi	r17, 0x6A	; 106
    14bc:	81 2f       	mov	r24, r17
    14be:	8a 95       	dec	r24
    14c0:	f1 f7       	brne	.-4      	; 0x14be <cc2500_Init+0x14>
  _delay_us(40);                    // warten 40us
  SPI_MasterInit();
    14c2:	e4 df       	rcall	.-56     	; 0x148c <SPI_MasterInit>
    14c4:	1a 95       	dec	r17
    14c6:	f1 f7       	brne	.-4      	; 0x14c4 <cc2500_Init+0x1a>
  _delay_us(40);                    // warten 40us
  cc2500_Reset();
    14c8:	e5 df       	rcall	.-54     	; 0x1494 <cc2500_Reset>
  cc2500_Off();                         // SS wegnehmen
    14ca:	85 d8       	rcall	.-3830   	; 0x5d6 <cc2500_Off>

  SPI_MasterTransmit(CC2500_IOCFG2 | CC2500_WRITE_BURST);
    14cc:	80 e4       	ldi	r24, 0x40	; 64
    14ce:	48 d8       	rcall	.-3952   	; 0x560 <SPI_MasterTransmit>
    14d0:	cb e5       	ldi	r28, 0x5B	; 91
    14d2:	d0 e0       	ldi	r29, 0x00	; 0
    14d4:	fe 01       	movw	r30, r28
  do
  {
    SPI_MasterTransmit(pgm_read_byte(init++));
    14d6:	21 96       	adiw	r28, 0x01	; 1
    14d8:	e4 91       	lpm	r30, Z+
    14da:	8e 2f       	mov	r24, r30
    14dc:	41 d8       	rcall	.-3966   	; 0x560 <SPI_MasterTransmit>
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue) - 3));
    14de:	80 e0       	ldi	r24, 0x00	; 0
    14e0:	c5 38       	cpi	r28, 0x85	; 133
    14e2:	d8 07       	cpc	r29, r24
    14e4:	b8 f3       	brcs	.-18     	; 0x14d4 <cc2500_Init+0x2a>
  cc2500_Off();                    // SS wegnehmen wegen Burst
    14e6:	77 d8       	rcall	.-3858   	; 0x5d6 <cc2500_Off>
  SPI_MasterTransmit(CC2500_TEST2 | CC2500_WRITE_BURST);
    14e8:	8c e6       	ldi	r24, 0x6C	; 108
    14ea:	3a d8       	rcall	.-3980   	; 0x560 <SPI_MasterTransmit>
    14ec:	fe 01       	movw	r30, r28
  do
  {
    SPI_MasterTransmit(pgm_read_byte(init++));
    14ee:	21 96       	adiw	r28, 0x01	; 1
    14f0:	e4 91       	lpm	r30, Z+
    14f2:	8e 2f       	mov	r24, r30
    14f4:	35 d8       	rcall	.-3990   	; 0x560 <SPI_MasterTransmit>
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue)));
    14f6:	80 e0       	ldi	r24, 0x00	; 0
    14f8:	c8 38       	cpi	r28, 0x88	; 136
    14fa:	d8 07       	cpc	r29, r24
    14fc:	b8 f3       	brcs	.-18     	; 0x14ec <cc2500_Init+0x42>
  cc2500_Off();                    // SS wegnehmen wegen Burst
    14fe:	6b d8       	rcall	.-3882   	; 0x5d6 <cc2500_Off>
  cc2500setPatableMax(power);
    1500:	80 2f       	mov	r24, r16
    1502:	50 df       	rcall	.-352    	; 0x13a4 <cc2500setPatableMax>
}
    1504:	df 91       	pop	r29
    1506:	cf 91       	pop	r28
    1508:	1f 91       	pop	r17
    150a:	0f 91       	pop	r16
    150c:	08 95       	ret

0000150e <__eerd_block_m88>:
    150e:	dc 01       	movw	r26, r24
    1510:	cb 01       	movw	r24, r22

00001512 <__eerd_blraw_m88>:
    1512:	fc 01       	movw	r30, r24
    1514:	f9 99       	sbic	0x1f, 1	; 31
    1516:	fe cf       	rjmp	.-4      	; 0x1514 <__eerd_blraw_m88+0x2>
    1518:	06 c0       	rjmp	.+12     	; 0x1526 <__eerd_blraw_m88+0x14>
    151a:	f2 bd       	out	0x22, r31	; 34
    151c:	e1 bd       	out	0x21, r30	; 33
    151e:	f8 9a       	sbi	0x1f, 0	; 31
    1520:	31 96       	adiw	r30, 0x01	; 1
    1522:	00 b4       	in	r0, 0x20	; 32
    1524:	0d 92       	st	X+, r0
    1526:	41 50       	subi	r20, 0x01	; 1
    1528:	50 40       	sbci	r21, 0x00	; 0
    152a:	b8 f7       	brcc	.-18     	; 0x151a <__eerd_blraw_m88+0x8>
    152c:	08 95       	ret

0000152e <__eewr_block_m88>:
    152e:	dc 01       	movw	r26, r24
    1530:	cb 01       	movw	r24, r22
    1532:	02 c0       	rjmp	.+4      	; 0x1538 <__eewr_block_m88+0xa>
    1534:	2d 91       	ld	r18, X+
    1536:	05 d0       	rcall	.+10     	; 0x1542 <__eewr_r18_m88>
    1538:	41 50       	subi	r20, 0x01	; 1
    153a:	50 40       	sbci	r21, 0x00	; 0
    153c:	d8 f7       	brcc	.-10     	; 0x1534 <__eewr_block_m88+0x6>
    153e:	08 95       	ret

00001540 <__eewr_byte_m88>:
    1540:	26 2f       	mov	r18, r22

00001542 <__eewr_r18_m88>:
    1542:	f9 99       	sbic	0x1f, 1	; 31
    1544:	fe cf       	rjmp	.-4      	; 0x1542 <__eewr_r18_m88>
    1546:	1f ba       	out	0x1f, r1	; 31
    1548:	92 bd       	out	0x22, r25	; 34
    154a:	81 bd       	out	0x21, r24	; 33
    154c:	20 bd       	out	0x20, r18	; 32
    154e:	0f b6       	in	r0, 0x3f	; 63
    1550:	f8 94       	cli
    1552:	fa 9a       	sbi	0x1f, 2	; 31
    1554:	f9 9a       	sbi	0x1f, 1	; 31
    1556:	0f be       	out	0x3f, r0	; 63
    1558:	01 96       	adiw	r24, 0x01	; 1
    155a:	08 95       	ret

0000155c <__eewr_word_m88>:
    155c:	f1 df       	rcall	.-30     	; 0x1540 <__eewr_byte_m88>
    155e:	27 2f       	mov	r18, r23
    1560:	f0 cf       	rjmp	.-32     	; 0x1542 <__eewr_r18_m88>

00001562 <_exit>:
    1562:	f8 94       	cli

00001564 <__stop_program>:
    1564:	ff cf       	rjmp	.-2      	; 0x1564 <__stop_program>
