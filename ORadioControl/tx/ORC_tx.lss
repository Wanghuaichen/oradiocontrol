
ORC_tx.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000efc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bloader      00000048  00000fb8  00000fb8  00000f90  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000061  00800100  00800100  00000fd8  2**0
                  ALLOC
  3 .noinit       00000001  00800161  00800161  00000fd8  2**0
                  ALLOC
  4 .stab         0000096c  00000000  00000000  00000fd8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000112  00000000  00000000  00001944  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000224  00000000  00000000  00001a58  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000049d  00000000  00000000  00001c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000171a  00000000  00000000  00002119  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000057a  00000000  00000000  00003833  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000016cf  00000000  00000000  00003dad  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000003c0  00000000  00000000  0000547c  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000822  00000000  00000000  0000583c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000071c  00000000  00000000  0000605e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000001f8  00000000  00000000  0000677a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

uint8_t get_Data(void)
{
  SPI_MasterTransmit(CC2500_READ_SINGLE | CC2500_RXFIFO);
  return(SPI_MasterTransmit(CC2500_SNOP));
}
   0:	30 c0       	rjmp	.+96     	; 0x62 <__ctors_end>
   2:	4f c4       	rjmp	.+2206   	; 0x8a2 <__vector_1>
   4:	56 c0       	rjmp	.+172    	; 0xb2 <__bad_interrupt>
   6:	55 c0       	rjmp	.+170    	; 0xb2 <__bad_interrupt>
   8:	54 c0       	rjmp	.+168    	; 0xb2 <__bad_interrupt>
   a:	53 c0       	rjmp	.+166    	; 0xb2 <__bad_interrupt>
   c:	52 c0       	rjmp	.+164    	; 0xb2 <__bad_interrupt>
   e:	2c c5       	rjmp	.+2648   	; 0xa68 <__vector_7>
  10:	50 c0       	rjmp	.+160    	; 0xb2 <__bad_interrupt>
  12:	4f c0       	rjmp	.+158    	; 0xb2 <__bad_interrupt>
  14:	4f c0       	rjmp	.+158    	; 0xb4 <__vector_10>
  16:	4d c0       	rjmp	.+154    	; 0xb2 <__bad_interrupt>
  18:	4c c0       	rjmp	.+152    	; 0xb2 <__bad_interrupt>
  1a:	4b c0       	rjmp	.+150    	; 0xb2 <__bad_interrupt>
  1c:	4a c0       	rjmp	.+148    	; 0xb2 <__bad_interrupt>
  1e:	49 c0       	rjmp	.+146    	; 0xb2 <__bad_interrupt>
  20:	48 c0       	rjmp	.+144    	; 0xb2 <__bad_interrupt>
  22:	47 c0       	rjmp	.+142    	; 0xb2 <__bad_interrupt>
  24:	67 c5       	rjmp	.+2766   	; 0xaf4 <__vector_18>
  26:	45 c0       	rjmp	.+138    	; 0xb2 <__bad_interrupt>
  28:	44 c0       	rjmp	.+136    	; 0xb2 <__bad_interrupt>
  2a:	43 c0       	rjmp	.+134    	; 0xb2 <__bad_interrupt>
  2c:	42 c0       	rjmp	.+132    	; 0xb2 <__bad_interrupt>
  2e:	41 c0       	rjmp	.+130    	; 0xb2 <__bad_interrupt>
  30:	40 c0       	rjmp	.+128    	; 0xb2 <__bad_interrupt>
  32:	3f c0       	rjmp	.+126    	; 0xb2 <__bad_interrupt>

00000034 <cc2500InitValue>:
  34:	29 2e 06 07 d3 91 03 0c 44 00 00 0a 00 5c 6c 4e     ).......D....\lN
  44:	2d 3b 73 f3 ff 00 07 00 18 1d 1c c7 00 b0 87 6b     -;s............k
  54:	f8 b6 10 ea 0a 00 11 41 00 59 88 31 0b 00           .......A.Y.1..

00000062 <__ctors_end>:
  62:	11 24       	eor	r1, r1
  64:	1f be       	out	0x3f, r1	; 63
  66:	cf ef       	ldi	r28, 0xFF	; 255
  68:	d2 e0       	ldi	r29, 0x02	; 2
  6a:	de bf       	out	0x3e, r29	; 62
  6c:	cd bf       	out	0x3d, r28	; 61

0000006e <get_mcusr>:
void get_mcusr(void) \
  __attribute__((naked)) \
  __attribute__((section(".init3")));
void get_mcusr(void)
{
  wdt_reset();
  6e:	a8 95       	wdr
  mcusr_mirror = MCUSR;
  70:	84 b7       	in	r24, 0x34	; 52
  72:	80 93 61 01 	sts	0x0161, r24
  MCUSR = 0;
  76:	14 be       	out	0x34, r1	; 52
  wdt_disable();
  78:	88 e1       	ldi	r24, 0x18	; 24
  7a:	0f b6       	in	r0, 0x3f	; 63
  7c:	f8 94       	cli
  7e:	80 93 60 00 	sts	0x0060, r24
  82:	10 92 60 00 	sts	0x0060, r1
  86:	0f be       	out	0x3f, r0	; 63

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	ec ef       	ldi	r30, 0xFC	; 252
  90:	fe e0       	ldi	r31, 0x0E	; 14
  92:	02 c0       	rjmp	.+4      	; 0x98 <.do_copy_data_start>

00000094 <.do_copy_data_loop>:
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0

00000098 <.do_copy_data_start>:
  98:	a0 30       	cpi	r26, 0x00	; 0
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <.do_copy_data_loop>

0000009e <__do_clear_bss>:
  9e:	11 e0       	ldi	r17, 0x01	; 1
  a0:	a0 e0       	ldi	r26, 0x00	; 0
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a1 36       	cpi	r26, 0x61	; 97
  aa:	b1 07       	cpc	r27, r17
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	34 d2       	rcall	.+1128   	; 0x518 <main>
  b0:	23 c7       	rjmp	.+3654   	; 0xef8 <_exit>

000000b2 <__bad_interrupt>:
  b2:	a6 cf       	rjmp	.-180    	; 0x0 <__vectors>

000000b4 <__vector_10>:
  cli();
  SET_BIT(TIMSK2, OCIE2A);                 // Timerinterrupt ein
}

ISR(TIMER1_CAPT_vect, ISR_NOBLOCK)                  //8MHz capture
{                                               // Timer läuft immer im Kreis
  b4:	78 94       	sei
  b6:	1f 92       	push	r1
  b8:	0f 92       	push	r0
  ba:	0f b6       	in	r0, 0x3f	; 63
  bc:	0f 92       	push	r0
  be:	11 24       	eor	r1, r1
  c0:	2f 93       	push	r18
  c2:	4f 93       	push	r20
  c4:	5f 93       	push	r21
  c6:	6f 93       	push	r22
  c8:	7f 93       	push	r23
  ca:	8f 93       	push	r24
  cc:	9f 93       	push	r25
  ce:	ef 93       	push	r30
  d0:	ff 93       	push	r31
  static uint16_t capture_alt;
  static uint8_t chanPtr;
  uint8_t chanPtrtemp = chanPtr;
  d2:	20 91 14 01 	lds	r18, 0x0114

  uint16_t capture = ICR1;
  d6:	40 91 86 00 	lds	r20, 0x0086
  da:	50 91 87 00 	lds	r21, 0x0087
  if(TIFR1 & (1 << OCF1A))              // Neuer PPM- Frame (>3ms Pause)
  de:	b1 9b       	sbis	0x16, 1	; 22
  e0:	04 c0       	rjmp	.+8      	; 0xea <__vector_10+0x36>
  {
    state.maxChan = chanPtrtemp;
  e2:	20 93 46 01 	sts	0x0146, r18
  e6:	20 e0       	ldi	r18, 0x00	; 0
  e8:	1f c0       	rjmp	.+62     	; 0x128 <__vector_10+0x74>
    chanPtrtemp = 0;
  }
  else if(chanPtrtemp < 16)
  ea:	20 31       	cpi	r18, 0x10	; 16
  ec:	e8 f4       	brcc	.+58     	; 0x128 <__vector_10+0x74>
  {                                                     // Auf 16 Kanäle begrenzen
    output.chan_1us[chanPtrtemp] = (capture - capture_alt) / 8 - 1500u;
  ee:	e2 2f       	mov	r30, r18
  f0:	f0 e0       	ldi	r31, 0x00	; 0
  f2:	80 91 15 01 	lds	r24, 0x0115
  f6:	90 91 16 01 	lds	r25, 0x0116
  fa:	ba 01       	movw	r22, r20
  fc:	68 1b       	sub	r22, r24
  fe:	79 0b       	sbc	r23, r25
 100:	cb 01       	movw	r24, r22
 102:	73 e0       	ldi	r23, 0x03	; 3
 104:	96 95       	lsr	r25
 106:	87 95       	ror	r24
 108:	7a 95       	dec	r23
 10a:	e1 f7       	brne	.-8      	; 0x104 <__vector_10+0x50>
 10c:	8c 5d       	subi	r24, 0xDC	; 220
 10e:	95 40       	sbci	r25, 0x05	; 5
 110:	ee 0f       	add	r30, r30
 112:	ff 1f       	adc	r31, r31
 114:	e2 5e       	subi	r30, 0xE2	; 226
 116:	fe 4f       	sbci	r31, 0xFE	; 254
 118:	91 83       	std	Z+1, r25	; 0x01
 11a:	80 83       	st	Z, r24
    if(chanPtrtemp == 3)
 11c:	23 30       	cpi	r18, 0x03	; 3
 11e:	19 f4       	brne	.+6      	; 0x126 <__vector_10+0x72>
      output.ppmSync = 4;
 120:	84 e0       	ldi	r24, 0x04	; 4
 122:	80 93 3e 01 	sts	0x013E, r24
    ++chanPtrtemp;
 126:	2f 5f       	subi	r18, 0xFF	; 255
  }	
  cli();
 128:	f8 94       	cli
  OCR1A = TCNT1 + (FOSC*100 / 33333); 			// 3ms
 12a:	80 91 84 00 	lds	r24, 0x0084
 12e:	90 91 85 00 	lds	r25, 0x0085
 132:	80 54       	subi	r24, 0x40	; 64
 134:	92 4a       	sbci	r25, 0xA2	; 162
 136:	90 93 89 00 	sts	0x0089, r25
 13a:	80 93 88 00 	sts	0x0088, r24
  sei();
 13e:	78 94       	sei
//  SET_BIT(TIFR1, OCF1A);
  TIFR1 = (1 << OCF1A);
 140:	82 e0       	ldi	r24, 0x02	; 2
 142:	86 bb       	out	0x16, r24	; 22
  capture_alt = capture;
 144:	50 93 16 01 	sts	0x0116, r21
 148:	40 93 15 01 	sts	0x0115, r20
  chanPtr = chanPtrtemp;
 14c:	20 93 14 01 	sts	0x0114, r18
}
 150:	ff 91       	pop	r31
 152:	ef 91       	pop	r30
 154:	9f 91       	pop	r25
 156:	8f 91       	pop	r24
 158:	7f 91       	pop	r23
 15a:	6f 91       	pop	r22
 15c:	5f 91       	pop	r21
 15e:	4f 91       	pop	r20
 160:	2f 91       	pop	r18
 162:	0f 90       	pop	r0
 164:	0f be       	out	0x3f, r0	; 63
 166:	0f 90       	pop	r0
 168:	1f 90       	pop	r1
 16a:	18 95       	reti

0000016c <SPI_MasterTransmit>:
//  else if(sendMes.MemoryWord.tar == 2)          // flash
//    ;
}

uint8_t SPI_MasterTransmit(uint8_t cData)
{
 16c:	98 2f       	mov	r25, r24
  uint8_t i = 0;
  if(PORTB & (1 << OUT_B_SPI_SS))
 16e:	2a 9b       	sbis	0x05, 2	; 5
 170:	27 c0       	rjmp	.+78     	; 0x1c0 <SPI_MasterTransmit+0x54>
  {
    RES_BIT(PORTB, OUT_B_SPI_SS);
 172:	2a 98       	cbi	0x05, 2	; 5
    NOP();
 174:	00 00       	nop
 176:	80 e0       	ldi	r24, 0x00	; 0
 178:	09 c0       	rjmp	.+18     	; 0x18c <SPI_MasterTransmit+0x20>
    while(PINB & (1<<OUT_B_SPI_SS))
      if(++i > 0xfe)
 17a:	8f 5f       	subi	r24, 0xFF	; 255
 17c:	8f 3f       	cpi	r24, 0xFF	; 255
 17e:	31 f4       	brne	.+12     	; 0x18c <SPI_MasterTransmit+0x20>
      {
        SET_BIT(state.ledError, L_SPI_ERROR);
 180:	80 91 48 01 	lds	r24, 0x0148
 184:	88 60       	ori	r24, 0x08	; 8
 186:	80 93 48 01 	sts	0x0148, r24
 18a:	02 c0       	rjmp	.+4      	; 0x190 <SPI_MasterTransmit+0x24>
  uint8_t i = 0;
  if(PORTB & (1 << OUT_B_SPI_SS))
  {
    RES_BIT(PORTB, OUT_B_SPI_SS);
    NOP();
    while(PINB & (1<<OUT_B_SPI_SS))
 18c:	1a 99       	sbic	0x03, 2	; 3
 18e:	f5 cf       	rjmp	.-22     	; 0x17a <SPI_MasterTransmit+0xe>
      if(++i > 0xfe)
      {
        SET_BIT(state.ledError, L_SPI_ERROR);
        break;
      }
    NOP();
 190:	00 00       	nop
 192:	80 e0       	ldi	r24, 0x00	; 0
 194:	09 c0       	rjmp	.+18     	; 0x1a8 <SPI_MasterTransmit+0x3c>
    i = 0;
    while(PINB & (1 << INP_B_SPI_MISO))
      if(++i > 0xfe)
 196:	8f 5f       	subi	r24, 0xFF	; 255
 198:	8f 3f       	cpi	r24, 0xFF	; 255
 19a:	31 f4       	brne	.+12     	; 0x1a8 <SPI_MasterTransmit+0x3c>
      {
        SET_BIT(state.ledError, L_SPI_ERROR);
 19c:	80 91 48 01 	lds	r24, 0x0148
 1a0:	88 60       	ori	r24, 0x08	; 8
 1a2:	80 93 48 01 	sts	0x0148, r24
 1a6:	0c c0       	rjmp	.+24     	; 0x1c0 <SPI_MasterTransmit+0x54>
        SET_BIT(state.ledError, L_SPI_ERROR);
        break;
      }
    NOP();
    i = 0;
    while(PINB & (1 << INP_B_SPI_MISO))
 1a8:	1c 99       	sbic	0x03, 4	; 3
 1aa:	f5 cf       	rjmp	.-22     	; 0x196 <SPI_MasterTransmit+0x2a>
 1ac:	09 c0       	rjmp	.+18     	; 0x1c0 <SPI_MasterTransmit+0x54>
        break;
      }
  }
  i = 0;
  while(PIND & (1<<INP_D_CC2500_GDO2))
    if(++i > 0xfe)
 1ae:	8f 5f       	subi	r24, 0xFF	; 255
 1b0:	8f 3f       	cpi	r24, 0xFF	; 255
 1b2:	39 f4       	brne	.+14     	; 0x1c2 <SPI_MasterTransmit+0x56>
    {
      SET_BIT(state.ledError, L_SPI_ERROR);
 1b4:	80 91 48 01 	lds	r24, 0x0148
 1b8:	88 60       	ori	r24, 0x08	; 8
 1ba:	80 93 48 01 	sts	0x0148, r24
 1be:	03 c0       	rjmp	.+6      	; 0x1c6 <SPI_MasterTransmit+0x5a>
      break;
 1c0:	80 e0       	ldi	r24, 0x00	; 0
        SET_BIT(state.ledError, L_SPI_ERROR);
        break;
      }
  }
  i = 0;
  while(PIND & (1<<INP_D_CC2500_GDO2))
 1c2:	4b 99       	sbic	0x09, 3	; 9
 1c4:	f4 cf       	rjmp	.-24     	; 0x1ae <SPI_MasterTransmit+0x42>
    if(++i > 0xfe)
    {
      SET_BIT(state.ledError, L_SPI_ERROR);
      break;
    }
  if(SPSR & (1<<SPIF))
 1c6:	0d b4       	in	r0, 0x2d	; 45
 1c8:	07 fc       	sbrc	r0, 7
    i = SPDR;
 1ca:	8e b5       	in	r24, 0x2e	; 46
  do
    SPDR = cData;
 1cc:	9e bd       	out	0x2e, r25	; 46
  while(SPSR & (1 << WCOL));
 1ce:	0d b4       	in	r0, 0x2d	; 45
 1d0:	06 fc       	sbrc	r0, 6
 1d2:	fc cf       	rjmp	.-8      	; 0x1cc <SPI_MasterTransmit+0x60>
 1d4:	01 c0       	rjmp	.+2      	; 0x1d8 <SPI_MasterTransmit+0x6c>
  while(!(SPSR & (1<<SPIF))) NOP();                            /* Wait for transmission complete */
 1d6:	00 00       	nop
 1d8:	0d b4       	in	r0, 0x2d	; 45
 1da:	07 fe       	sbrs	r0, 7
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <SPI_MasterTransmit+0x6a>
  return(SPDR);
 1de:	8e b5       	in	r24, 0x2e	; 46
}
 1e0:	08 95       	ret

000001e2 <cc2500_Off>:

void cc2500_Off(void)
{
  SET_BIT(PORTB, OUT_B_SPI_SS);
 1e2:	2a 9a       	sbi	0x05, 2	; 5
  do
  {
    NOP();
 1e4:	00 00       	nop
  }
  while(!(PINB & (1<<OUT_B_SPI_SS)));
 1e6:	1a 9b       	sbis	0x03, 2	; 3
 1e8:	fd cf       	rjmp	.-6      	; 0x1e4 <cc2500_Off+0x2>
}
 1ea:	08 95       	ret

000001ec <checkKey>:
//  cc2500WriteRegCheckIdle(CC2500_PKTLEN, sizeof(Telemetrie));
//}

bool checkKey(void)
{
  return(!(PINC & (1 << INP_C_KEY)));
 1ec:	86 b1       	in	r24, 0x06	; 6
 1ee:	86 95       	lsr	r24
 1f0:	86 95       	lsr	r24
 1f2:	80 95       	com	r24
}
 1f4:	81 70       	andi	r24, 0x01	; 1
 1f6:	08 95       	ret

000001f8 <set_led>:
{
  static uint8_t timer_alt;
  static uint8_t led_count;
  uint8_t ledErrorTemp;

  int8_t diff = ((uint8_t)Timer33ms) - timer_alt;
 1f8:	80 91 5e 01 	lds	r24, 0x015E
 1fc:	90 91 5f 01 	lds	r25, 0x015F
  if(diff > (1000 / 4 / 33))
 200:	20 91 0f 01 	lds	r18, 0x010F
 204:	82 1b       	sub	r24, r18
 206:	88 30       	cpi	r24, 0x08	; 8
 208:	ec f1       	brlt	.+122    	; 0x284 <set_led+0x8c>
  {
    timer_alt = (uint8_t)Timer33ms;
 20a:	80 91 5e 01 	lds	r24, 0x015E
 20e:	90 91 5f 01 	lds	r25, 0x015F
 212:	38 2f       	mov	r19, r24
 214:	80 93 0f 01 	sts	0x010F, r24

    if(!(led_count & 0xf))            // unteres Nibble 0
 218:	20 91 0e 01 	lds	r18, 0x010E
 21c:	82 2f       	mov	r24, r18
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	8f 70       	andi	r24, 0x0F	; 15
 222:	90 70       	andi	r25, 0x00	; 0
 224:	89 2b       	or	r24, r25
 226:	e9 f4       	brne	.+58     	; 0x262 <set_led+0x6a>
    {
      ledErrorTemp = state.ledError;
 228:	80 91 48 01 	lds	r24, 0x0148
      while(ledErrorTemp)
 22c:	88 23       	and	r24, r24
 22e:	51 f1       	breq	.+84     	; 0x284 <set_led+0x8c>
      {
        led_count += 0x10;
        led_count &= 0x7f;
        if(ledErrorTemp & (1 << (led_count >> 4)))
 230:	48 2f       	mov	r20, r24
 232:	50 e0       	ldi	r21, 0x00	; 0
    if(!(led_count & 0xf))            // unteres Nibble 0
    {
      ledErrorTemp = state.ledError;
      while(ledErrorTemp)
      {
        led_count += 0x10;
 234:	20 5f       	subi	r18, 0xF0	; 240
        led_count &= 0x7f;
 236:	2f 77       	andi	r18, 0x7F	; 127
        if(ledErrorTemp & (1 << (led_count >> 4)))
 238:	82 2f       	mov	r24, r18
 23a:	82 95       	swap	r24
 23c:	8f 70       	andi	r24, 0x0F	; 15
 23e:	ba 01       	movw	r22, r20
 240:	02 c0       	rjmp	.+4      	; 0x246 <set_led+0x4e>
 242:	75 95       	asr	r23
 244:	67 95       	ror	r22
 246:	8a 95       	dec	r24
 248:	e2 f7       	brpl	.-8      	; 0x242 <set_led+0x4a>
 24a:	60 ff       	sbrs	r22, 0
 24c:	f3 cf       	rjmp	.-26     	; 0x234 <set_led+0x3c>
        {
          led_count |= (led_count >> 3) | 1;      // Blinkzähler setzen
 24e:	82 2f       	mov	r24, r18
 250:	86 95       	lsr	r24
 252:	86 95       	lsr	r24
 254:	86 95       	lsr	r24
 256:	21 60       	ori	r18, 0x01	; 1
 258:	82 2b       	or	r24, r18
 25a:	80 93 0e 01 	sts	0x010E, r24
          LEDRED_ON;
 25e:	40 9a       	sbi	0x08, 0	; 8
 260:	08 95       	ret
        }
      }
    }
    else
    {
      --led_count;
 262:	82 2f       	mov	r24, r18
 264:	81 50       	subi	r24, 0x01	; 1
 266:	80 93 0e 01 	sts	0x010E, r24
      if(led_count & 1)
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	80 ff       	sbrs	r24, 0
 26e:	02 c0       	rjmp	.+4      	; 0x274 <set_led+0x7c>
        LEDRED_ON;
 270:	40 9a       	sbi	0x08, 0	; 8
 272:	01 c0       	rjmp	.+2      	; 0x276 <set_led+0x7e>
      else
        LEDRED_OFF;
 274:	40 98       	cbi	0x08, 0	; 8
      if(!(led_count & 0xf))
 276:	8f 70       	andi	r24, 0x0F	; 15
 278:	90 70       	andi	r25, 0x00	; 0
 27a:	89 2b       	or	r24, r25
 27c:	19 f4       	brne	.+6      	; 0x284 <set_led+0x8c>
        timer_alt += (1000 / 4 / 33 * 3);                    // Pause
 27e:	3b 5e       	subi	r19, 0xEB	; 235
 280:	30 93 0f 01 	sts	0x010F, r19
 284:	08 95       	ret

00000286 <checkId>:
  }
}

bool checkId(void)
{
  return (eeprom.bind.id && (eeprom.bind.id != 0xffff)
 286:	20 91 17 01 	lds	r18, 0x0117
 28a:	30 91 18 01 	lds	r19, 0x0118
 28e:	c9 01       	movw	r24, r18
 290:	01 97       	sbiw	r24, 0x01	; 1
 292:	8e 5f       	subi	r24, 0xFE	; 254
 294:	9f 4f       	sbci	r25, 0xFF	; 255
 296:	c0 f4       	brcc	.+48     	; 0x2c8 <checkId+0x42>
 298:	83 2f       	mov	r24, r19
 29a:	99 27       	eor	r25, r25
 29c:	30 70       	andi	r19, 0x00	; 0
 29e:	82 17       	cp	r24, r18
 2a0:	93 07       	cpc	r25, r19
 2a2:	91 f0       	breq	.+36     	; 0x2c8 <checkId+0x42>
 2a4:	8a 3a       	cpi	r24, 0xAA	; 170
 2a6:	91 05       	cpc	r25, r1
 2a8:	79 f0       	breq	.+30     	; 0x2c8 <checkId+0x42>
 2aa:	85 35       	cpi	r24, 0x55	; 85
 2ac:	91 05       	cpc	r25, r1
 2ae:	61 f0       	breq	.+24     	; 0x2c8 <checkId+0x42>
 2b0:	80 91 19 01 	lds	r24, 0x0119
 2b4:	85 30       	cpi	r24, 0x05	; 5
 2b6:	40 f0       	brcs	.+16     	; 0x2c8 <checkId+0x42>
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	8d 35       	cpi	r24, 0x5D	; 93
 2bc:	08 f0       	brcs	.+2      	; 0x2c0 <checkId+0x3a>
 2be:	91 e0       	ldi	r25, 0x01	; 1
 2c0:	81 e0       	ldi	r24, 0x01	; 1
 2c2:	98 27       	eor	r25, r24
 2c4:	89 2f       	mov	r24, r25
 2c6:	08 95       	ret
 2c8:	80 e0       	ldi	r24, 0x00	; 0
 2ca:	90 e0       	ldi	r25, 0x00	; 0
      && ((eeprom.bind.id >> 8) != (eeprom.bind.id & 0xff))
      && ((eeprom.bind.id >> 8) != 0xaa)
      && ((eeprom.bind.id >> 8) != 0x55)
      && (eeprom.bind.step > 4) && (eeprom.bind.step < MAXHOPPCHAN / 2 - 4));
}
 2cc:	08 95       	ret

000002ce <calcCheckSum>:

uint16_t calcCheckSum(uint8_t *p, uint16_t size)
{
 2ce:	fc 01       	movw	r30, r24
 2d0:	20 e0       	ldi	r18, 0x00	; 0
 2d2:	30 e0       	ldi	r19, 0x00	; 0
 2d4:	05 c0       	rjmp	.+10     	; 0x2e0 <calcCheckSum+0x12>
  uint16_t sum = 0;

  while(size--)
    sum += *p++;
 2d6:	81 91       	ld	r24, Z+
 2d8:	28 0f       	add	r18, r24
 2da:	31 1d       	adc	r19, r1
 2dc:	61 50       	subi	r22, 0x01	; 1
 2de:	70 40       	sbci	r23, 0x00	; 0

uint16_t calcCheckSum(uint8_t *p, uint16_t size)
{
  uint16_t sum = 0;

  while(size--)
 2e0:	61 15       	cp	r22, r1
 2e2:	71 05       	cpc	r23, r1
 2e4:	c1 f7       	brne	.-16     	; 0x2d6 <calcCheckSum+0x8>
    sum += *p++;
  return(sum);
}
 2e6:	c9 01       	movw	r24, r18
 2e8:	08 95       	ret

000002ea <tx_ok>:
  setNext();                            // Empfang ein
}

void tx_ok(void)
{
  if(state.ccaCount > 0)
 2ea:	80 91 49 01 	lds	r24, 0x0149
 2ee:	88 23       	and	r24, r24
 2f0:	29 f0       	breq	.+10     	; 0x2fc <tx_ok+0x12>
    --state.ccaCount;
 2f2:	80 91 49 01 	lds	r24, 0x0149
 2f6:	81 50       	subi	r24, 0x01	; 1
 2f8:	80 93 49 01 	sts	0x0149, r24
 2fc:	08 95       	ret

000002fe <UartTxReady>:
}
*/

void UartTxReady(void)
{
  while(!(UCSR0A & (1 << UDRE0)));              // warten bis Sendepuffer leer
 2fe:	80 91 c0 00 	lds	r24, 0x00C0
 302:	85 ff       	sbrs	r24, 5
 304:	fc cf       	rjmp	.-8      	; 0x2fe <UartTxReady>
}
 306:	08 95       	ret

00000308 <sendTelemetrie2UART>:

void sendTelemetrie2UART(void)
{
 308:	cf 93       	push	r28
 30a:	df 93       	push	r29
  if(TelemetrieMes.crcOk)
 30c:	80 91 5d 01 	lds	r24, 0x015D
 310:	87 ff       	sbrs	r24, 7
 312:	11 c0       	rjmp	.+34     	; 0x336 <sendTelemetrie2UART+0x2e>
  {
    UartTxReady();
 314:	f4 df       	rcall	.-24     	; 0x2fe <UartTxReady>
    UDR0 = 'T';
 316:	84 e5       	ldi	r24, 0x54	; 84
 318:	80 93 c6 00 	sts	0x00C6, r24
 31c:	c6 e5       	ldi	r28, 0x56	; 86
 31e:	d1 e0       	ldi	r29, 0x01	; 1
    uint8_t i;
    uint8_t *p;
    for(i = 0, p = &TelemetrieMes.data.Unspec.dataB6;i < 6;++i)
    {
      UartTxReady();
 320:	ee df       	rcall	.-36     	; 0x2fe <UartTxReady>
      UDR0 = *p++;
 322:	89 91       	ld	r24, Y+
 324:	80 93 c6 00 	sts	0x00C6, r24
  {
    UartTxReady();
    UDR0 = 'T';
    uint8_t i;
    uint8_t *p;
    for(i = 0, p = &TelemetrieMes.data.Unspec.dataB6;i < 6;++i)
 328:	81 e0       	ldi	r24, 0x01	; 1
 32a:	cc 35       	cpi	r28, 0x5C	; 92
 32c:	d8 07       	cpc	r29, r24
 32e:	c1 f7       	brne	.-16     	; 0x320 <sendTelemetrie2UART+0x18>
    {
      UartTxReady();
      UDR0 = *p++;
    }
    TelemetrieMes.crcOk = false;
 330:	89 81       	ldd	r24, Y+1	; 0x01
 332:	8f 77       	andi	r24, 0x7F	; 127
 334:	89 83       	std	Y+1, r24	; 0x01
  }
}
 336:	df 91       	pop	r29
 338:	cf 91       	pop	r28
 33a:	08 95       	ret

0000033c <chkFailSafe>:

void chkFailSafe(void)
{
  if(checkKey())
 33c:	57 df       	rcall	.-338    	; 0x1ec <checkKey>
 33e:	88 23       	and	r24, r24
 340:	39 f0       	breq	.+14     	; 0x350 <chkFailSafe+0x14>
  {
    state.SetFaileSafe = true;
 342:	81 e0       	ldi	r24, 0x01	; 1
 344:	80 93 42 01 	sts	0x0142, r24
    SET_BIT(state.ledError, L_SET_FAILSAVE);
 348:	80 91 48 01 	lds	r24, 0x0148
 34c:	81 60       	ori	r24, 0x01	; 1
 34e:	03 c0       	rjmp	.+6      	; 0x356 <chkFailSafe+0x1a>
  }
  else
    RES_BIT(state.ledError, L_SET_FAILSAVE);
 350:	80 91 48 01 	lds	r24, 0x0148
 354:	8e 7f       	andi	r24, 0xFE	; 254
 356:	80 93 48 01 	sts	0x0148, r24
 35a:	08 95       	ret

0000035c <USART_Init>:
  }
}

void USART_Init( unsigned int ubrr)
{
  UBRR0 = ubrr;
 35c:	90 93 c5 00 	sts	0x00C5, r25
 360:	80 93 c4 00 	sts	0x00C4, r24
  UCSR0A = 0;                                   //1 << U2X0;
 364:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0C = (3 << UCSZ00);                     /* Set frame format: 8data, 1stop bit */
 368:	86 e0       	ldi	r24, 0x06	; 6
 36a:	80 93 c2 00 	sts	0x00C2, r24
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);    /* Enable receiver and transmitter */
 36e:	88 e9       	ldi	r24, 0x98	; 152
 370:	80 93 c1 00 	sts	0x00C1, r24
  SET_BIT(PORTD, INP_D_RXD);                    // Pullup ein
 374:	58 9a       	sbi	0x0b, 0	; 11
}
 376:	08 95       	ret

00000378 <setNextChan>:
  cc2500setPatableMax(0x7f);             // Sendeleistung runter
}

void setNextChan(void)                // Kanal schreiben
{
  uint16_t tempChan = state.actTxChan;
 378:	80 91 45 01 	lds	r24, 0x0145
 37c:	68 2f       	mov	r22, r24
 37e:	70 e0       	ldi	r23, 0x00	; 0
  if(state.bindmode)
 380:	80 91 41 01 	lds	r24, 0x0141
 384:	88 23       	and	r24, r24
 386:	19 f0       	breq	.+6      	; 0x38e <setNextChan+0x16>
    tempChan += BINDMODESTEP * 2 + 1;
 388:	6f 57       	subi	r22, 0x7F	; 127
 38a:	7f 4f       	sbci	r23, 0xFF	; 255
 38c:	0c c0       	rjmp	.+24     	; 0x3a6 <setNextChan+0x2e>
  else
  tempChan += eeprom.bind.step * 2 + 1;
 38e:	6f 5f       	subi	r22, 0xFF	; 255
 390:	7f 4f       	sbci	r23, 0xFF	; 255
 392:	80 91 19 01 	lds	r24, 0x0119
 396:	90 e0       	ldi	r25, 0x00	; 0
 398:	88 0f       	add	r24, r24
 39a:	99 1f       	adc	r25, r25
 39c:	68 0f       	add	r22, r24
 39e:	79 1f       	adc	r23, r25
 3a0:	02 c0       	rjmp	.+4      	; 0x3a6 <setNextChan+0x2e>
  while(tempChan > MAXHOPPCHAN)
    tempChan -= (MAXHOPPCHAN + 1);
 3a2:	64 5c       	subi	r22, 0xC4	; 196
 3a4:	70 40       	sbci	r23, 0x00	; 0
  uint16_t tempChan = state.actTxChan;
  if(state.bindmode)
    tempChan += BINDMODESTEP * 2 + 1;
  else
  tempChan += eeprom.bind.step * 2 + 1;
  while(tempChan > MAXHOPPCHAN)
 3a6:	64 3c       	cpi	r22, 0xC4	; 196
 3a8:	71 05       	cpc	r23, r1
 3aa:	d8 f7       	brcc	.-10     	; 0x3a2 <setNextChan+0x2a>
    tempChan -= (MAXHOPPCHAN + 1);
  state.actTxChan = tempChan;
 3ac:	60 93 45 01 	sts	0x0145, r22
  cc2500WriteRegCheckIdle(CC2500_CHANNR, tempChan);
 3b0:	8a e0       	ldi	r24, 0x0A	; 10
 3b2:	a0 d4       	rcall	.+2368   	; 0xcf4 <cc2500WriteRegCheckIdle>
}
 3b4:	08 95       	ret

000003b6 <cc2500_EnableTx>:

bool cc2500_EnableTx(void)
{
  // heiße Sache, CPU hat 0,64ms Zeit um die Daten zu schreiben
  // aber das Timing ist konstanter!
  RES_BIT(PORTD, OUT_D_CRX);
 3b6:	5d 98       	cbi	0x0b, 5	; 11
  if((SPI_MasterTransmit(CC2500_STX) & CC2500_STATUS_STATE_BM) != CC2500_STATE_RX)
 3b8:	85 e3       	ldi	r24, 0x35	; 53
 3ba:	d8 de       	rcall	.-592    	; 0x16c <SPI_MasterTransmit>
 3bc:	80 77       	andi	r24, 0x70	; 112
 3be:	80 31       	cpi	r24, 0x10	; 16
 3c0:	41 f0       	breq	.+16     	; 0x3d2 <cc2500_EnableTx+0x1c>
  {
    sei();
 3c2:	78 94       	sei
    SET_BIT(state.ledError, L_NOT_RX);
 3c4:	80 91 48 01 	lds	r24, 0x0148
 3c8:	80 62       	ori	r24, 0x20	; 32
 3ca:	80 93 48 01 	sts	0x0148, r24
 3ce:	80 e0       	ldi	r24, 0x00	; 0
 3d0:	08 95       	ret
    return(false);
  }
  else
  {
    if(eeprom.ccaOff || (cc2500GetState() != CC2500_STATE_RX))
 3d2:	80 91 1b 01 	lds	r24, 0x011B
 3d6:	88 23       	and	r24, r24
 3d8:	19 f4       	brne	.+6      	; 0x3e0 <cc2500_EnableTx+0x2a>
 3da:	73 d4       	rcall	.+2278   	; 0xcc2 <cc2500GetState>
 3dc:	80 31       	cpi	r24, 0x10	; 16
 3de:	39 f0       	breq	.+14     	; 0x3ee <cc2500_EnableTx+0x38>
    {
      SET_BIT(PORTB, OUT_B_CTX);
 3e0:	29 9a       	sbi	0x05, 1	; 5
      sei();
 3e2:	78 94       	sei
      EIFR = 1 << INTF0;                          // Interruptflag löschen
 3e4:	81 e0       	ldi	r24, 0x01	; 1
 3e6:	8c bb       	out	0x1c, r24	; 28
      SET_BIT(EIMSK, INT0);                           // Interrupt ein
 3e8:	e8 9a       	sbi	0x1d, 0	; 29
      LEDGREEN_ON;
 3ea:	41 9a       	sbi	0x08, 1	; 8
 3ec:	08 95       	ret
      return(true);
    }
    else
    {
      sei();
 3ee:	78 94       	sei
      ++state.ccaSum;
 3f0:	80 91 4b 01 	lds	r24, 0x014B
 3f4:	90 91 4c 01 	lds	r25, 0x014C
 3f8:	a0 91 4d 01 	lds	r26, 0x014D
 3fc:	b0 91 4e 01 	lds	r27, 0x014E
 400:	01 96       	adiw	r24, 0x01	; 1
 402:	a1 1d       	adc	r26, r1
 404:	b1 1d       	adc	r27, r1
 406:	80 93 4b 01 	sts	0x014B, r24
 40a:	90 93 4c 01 	sts	0x014C, r25
 40e:	a0 93 4d 01 	sts	0x014D, r26
 412:	b0 93 4e 01 	sts	0x014E, r27
      if(state.ccaCount < 5)
 416:	80 91 49 01 	lds	r24, 0x0149
 41a:	85 30       	cpi	r24, 0x05	; 5
 41c:	28 f4       	brcc	.+10     	; 0x428 <cc2500_EnableTx+0x72>
        ++state.ccaCount;                   // hier CCA abschalten wenn zuviel
 41e:	80 91 49 01 	lds	r24, 0x0149
 422:	8f 5f       	subi	r24, 0xFF	; 255
 424:	80 93 49 01 	sts	0x0149, r24
      if(state.ccaCount >= 5)
 428:	80 91 49 01 	lds	r24, 0x0149
 42c:	85 30       	cpi	r24, 0x05	; 5
 42e:	18 f0       	brcs	.+6      	; 0x436 <cc2500_EnableTx+0x80>
      {
        cc2500WriteRegCheckIdle(CC2500_MCSM1, SMARTRF_SETTING_MCSM1 & ~0x30);  // aus
 430:	87 e1       	ldi	r24, 0x17	; 23
 432:	60 e0       	ldi	r22, 0x00	; 0
 434:	5f d4       	rcall	.+2238   	; 0xcf4 <cc2500WriteRegCheckIdle>
      }
      LEDGREEN_OFF;
 436:	41 98       	cbi	0x08, 1	; 8
 438:	80 e0       	ldi	r24, 0x00	; 0
      return(false);
    }
  }
}
 43a:	08 95       	ret

0000043c <TxReceive>:
  }
  output.ppmSync = syncTemp;                    // Interrupt macht nichts, so lange nicht zu oft
}

void TxReceive(uint8_t anz)
{
 43c:	1f 93       	push	r17
 43e:	18 2f       	mov	r17, r24
  if((anz != sizeof(TelemetrieMes))
 440:	88 30       	cpi	r24, 0x08	; 8
 442:	51 f4       	brne	.+20     	; 0x458 <TxReceive+0x1c>
 444:	86 e5       	ldi	r24, 0x56	; 86
 446:	91 e0       	ldi	r25, 0x01	; 1
 448:	68 e0       	ldi	r22, 0x08	; 8
 44a:	9f d4       	rcall	.+2366   	; 0xd8a <cc2500ReadFIFOBlock>
 44c:	88 23       	and	r24, r24
 44e:	21 f0       	breq	.+8      	; 0x458 <TxReceive+0x1c>
 450:	29 c0       	rjmp	.+82     	; 0x4a4 <TxReceive+0x68>
      || !cc2500ReadFIFOBlock((uint8_t *)&TelemetrieMes, sizeof(TelemetrieMes)))
  {
    while(anz-- > 0)
      cc2500ReadReg(CC2500_RXFIFO);         // Flush geht nicht weil rx
 452:	8f e3       	ldi	r24, 0x3F	; 63
 454:	29 d4       	rcall	.+2130   	; 0xca8 <cc2500ReadReg>
 456:	11 50       	subi	r17, 0x01	; 1
void TxReceive(uint8_t anz)
{
  if((anz != sizeof(TelemetrieMes))
      || !cc2500ReadFIFOBlock((uint8_t *)&TelemetrieMes, sizeof(TelemetrieMes)))
  {
    while(anz-- > 0)
 458:	11 23       	and	r17, r17
 45a:	d9 f7       	brne	.-10     	; 0x452 <TxReceive+0x16>
      cc2500ReadReg(CC2500_RXFIFO);         // Flush geht nicht weil rx
    if(Telem_error < 0xffff)
 45c:	80 91 3f 01 	lds	r24, 0x013F
 460:	90 91 40 01 	lds	r25, 0x0140
 464:	2f ef       	ldi	r18, 0xFF	; 255
 466:	8f 3f       	cpi	r24, 0xFF	; 255
 468:	92 07       	cpc	r25, r18
 46a:	29 f0       	breq	.+10     	; 0x476 <TxReceive+0x3a>
      ++Telem_error;
 46c:	01 96       	adiw	r24, 0x01	; 1
 46e:	90 93 40 01 	sts	0x0140, r25
 472:	80 93 3f 01 	sts	0x013F, r24
    TelemetrieMes.data.StatusTx.type = 0;
    TelemetrieMes.data.StatusTx.source = 0;
 476:	10 92 5b 01 	sts	0x015B, r1
    TelemetrieMes.data.StatusTx.Timer33ms = Timer33ms;
 47a:	80 91 5e 01 	lds	r24, 0x015E
 47e:	90 91 5f 01 	lds	r25, 0x015F
 482:	90 93 57 01 	sts	0x0157, r25
 486:	80 93 56 01 	sts	0x0156, r24
    TelemetrieMes.data.StatusTx.Telem_error = Telem_error;
 48a:	80 91 3f 01 	lds	r24, 0x013F
 48e:	90 91 40 01 	lds	r25, 0x0140
 492:	90 93 59 01 	sts	0x0159, r25
 496:	80 93 58 01 	sts	0x0158, r24
    TelemetrieMes.crcOk = true;
 49a:	80 91 5d 01 	lds	r24, 0x015D
 49e:	80 68       	ori	r24, 0x80	; 128
 4a0:	80 93 5d 01 	sts	0x015D, r24
//    TelemetrieMes.date.statusTx.
  }
}
 4a4:	1f 91       	pop	r17
 4a6:	08 95       	ret

000004a8 <calcNewId>:

void calcNewId(void)
{
  do
  {
    cli();
 4a8:	f8 94       	cli
    eeprom.bind.id += TCNT0 + TCNT1 + TCNT2 + BINDMODEID;
 4aa:	56 b5       	in	r21, 0x26	; 38
 4ac:	80 91 84 00 	lds	r24, 0x0084
 4b0:	90 91 85 00 	lds	r25, 0x0085
 4b4:	40 91 b2 00 	lds	r20, 0x00B2
 4b8:	20 91 17 01 	lds	r18, 0x0117
 4bc:	30 91 18 01 	lds	r19, 0x0118
 4c0:	82 0f       	add	r24, r18
 4c2:	93 1f       	adc	r25, r19
 4c4:	87 5f       	subi	r24, 0xF7	; 247
 4c6:	9f 4e       	sbci	r25, 0xEF	; 239
 4c8:	85 0f       	add	r24, r21
 4ca:	91 1d       	adc	r25, r1
 4cc:	84 0f       	add	r24, r20
 4ce:	91 1d       	adc	r25, r1
 4d0:	90 93 18 01 	sts	0x0118, r25
 4d4:	80 93 17 01 	sts	0x0117, r24
    sei();
 4d8:	78 94       	sei
    eeprom.bind.step += eeprom.bind.id;
    eeprom.bind.step &= 0x3f;
 4da:	20 91 19 01 	lds	r18, 0x0119
 4de:	28 0f       	add	r18, r24
 4e0:	2f 73       	andi	r18, 0x3F	; 63
 4e2:	20 93 19 01 	sts	0x0119, r18
  }
  while(!checkId());
 4e6:	cf de       	rcall	.-610    	; 0x286 <checkId>
 4e8:	88 23       	and	r24, r24
 4ea:	f1 f2       	breq	.-68     	; 0x4a8 <calcNewId>
  eeprom.checksum = calcCheckSum((uint8_t *)&eeprom, sizeof(eeprom) - sizeof(eeprom.checksum));
 4ec:	87 e1       	ldi	r24, 0x17	; 23
 4ee:	91 e0       	ldi	r25, 0x01	; 1
 4f0:	65 e0       	ldi	r22, 0x05	; 5
 4f2:	70 e0       	ldi	r23, 0x00	; 0
 4f4:	ec de       	rcall	.-552    	; 0x2ce <calcCheckSum>
 4f6:	90 93 1d 01 	sts	0x011D, r25
 4fa:	80 93 1c 01 	sts	0x011C, r24
  eeprom_write_block(&eeprom, 0, sizeof(eeprom));
 4fe:	87 e1       	ldi	r24, 0x17	; 23
 500:	91 e0       	ldi	r25, 0x01	; 1
 502:	60 e0       	ldi	r22, 0x00	; 0
 504:	70 e0       	ldi	r23, 0x00	; 0
 506:	47 e0       	ldi	r20, 0x07	; 7
 508:	50 e0       	ldi	r21, 0x00	; 0
 50a:	dd d4       	rcall	.+2490   	; 0xec6 <__eewr_block_m48>
  SET_BIT(state.ledError, L_EEPROM_ERR);
 50c:	80 91 48 01 	lds	r24, 0x0148
 510:	84 60       	ori	r24, 0x04	; 4
 512:	80 93 48 01 	sts	0x0148, r24
}
 516:	08 95       	ret

00000518 <main>:
  SET_BIT(PORTD, INP_D_RXD);                    // Pullup ein
}

int __attribute__((naked)) main(void)
{
  cli();
 518:	f8 94       	cli
  CLKPR = 0;
 51a:	10 92 61 00 	sts	0x0061, r1
  PRR = 0;        // Powerreduction für ADC?
 51e:	10 92 64 00 	sts	0x0064, r1

  PORTB = (1<<OUT_B_SPI_SS);
 522:	84 e0       	ldi	r24, 0x04	; 4
 524:	85 b9       	out	0x05, r24	; 5
  DDRB = (1<<OUT_B_SPI_MOSI) | (1<<OUT_B_SPI_SCK) | (1<<OUT_B_SPI_SS) | (1 << OUT_B_CTX);
 526:	8e e2       	ldi	r24, 0x2E	; 46
 528:	84 b9       	out	0x04, r24	; 4
  PORTB = (1<<OUT_B_SPI_SS)
 52a:	85 ed       	ldi	r24, 0xD5	; 213
 52c:	85 b9       	out	0x05, r24	; 5
      | ~((1<<OUT_B_SPI_MOSI) | (1<<OUT_B_SPI_SCK) | (1<<OUT_B_SPI_SS) | (1 << OUT_B_CTX));

  DDRC = (1 << OUT_C_LEDRED) | (1 << OUT_C_LEDGREEN);
 52e:	83 e0       	ldi	r24, 0x03	; 3
 530:	87 b9       	out	0x07, r24	; 7
  PORTC = ~((1 << OUT_C_LEDRED) | (1 << OUT_C_LEDGREEN));
 532:	8c ef       	ldi	r24, 0xFC	; 252
 534:	88 b9       	out	0x08, r24	; 8

  DDRD = (1 << OUT_D_CRX);
 536:	80 e2       	ldi	r24, 0x20	; 32
 538:	8a b9       	out	0x0a, r24	; 10
  PORTD = ~(1 << OUT_D_CRX);
 53a:	8f ed       	ldi	r24, 0xDF	; 223
 53c:	8b b9       	out	0x0b, r24	; 11

  LEDRED_ON;
 53e:	40 9a       	sbi	0x08, 0	; 8
// Timer0 32,768ms für clock
  TCCR0B = (5 << CS00);                 // clk/1024  -> 0,128 ms
 540:	85 e0       	ldi	r24, 0x05	; 5
 542:	85 bd       	out	0x25, r24	; 37
  TCNT0 = 0;
 544:	16 bc       	out	0x26, r1	; 38
  TIFR0 = 0xff;
 546:	8f ef       	ldi	r24, 0xFF	; 255
 548:	85 bb       	out	0x15, r24	; 21
  TIMSK0 = 0;
 54a:	10 92 6e 00 	sts	0x006E, r1

  wdt_enable(WDTO_500MS);
 54e:	2d e0       	ldi	r18, 0x0D	; 13
 550:	88 e1       	ldi	r24, 0x18	; 24
 552:	90 e0       	ldi	r25, 0x00	; 0
 554:	0f b6       	in	r0, 0x3f	; 63
 556:	f8 94       	cli
 558:	a8 95       	wdr
 55a:	80 93 60 00 	sts	0x0060, r24
 55e:	0f be       	out	0x3f, r0	; 63
 560:	20 93 60 00 	sts	0x0060, r18

  EICRA = (1 << ISC01);                       // int0 bei fallender Flanke
 564:	82 e0       	ldi	r24, 0x02	; 2
 566:	80 93 69 00 	sts	0x0069, r24
  EIMSK = 0;                               // Achtung cc2500 gibt hier Takt aus per default
 56a:	1d ba       	out	0x1d, r1	; 29

  eeprom_read_block(&eeprom, 0, sizeof(eeprom));
 56c:	87 e1       	ldi	r24, 0x17	; 23
 56e:	91 e0       	ldi	r25, 0x01	; 1
 570:	60 e0       	ldi	r22, 0x00	; 0
 572:	70 e0       	ldi	r23, 0x00	; 0
 574:	47 e0       	ldi	r20, 0x07	; 7
 576:	50 e0       	ldi	r21, 0x00	; 0
 578:	97 d4       	rcall	.+2350   	; 0xea8 <__eerd_block_m48>
  if(!checkId() || (eeprom.checksum !=
 57a:	85 de       	rcall	.-758    	; 0x286 <checkId>
 57c:	88 23       	and	r24, r24
 57e:	61 f0       	breq	.+24     	; 0x598 <main+0x80>
 580:	00 91 1c 01 	lds	r16, 0x011C
 584:	10 91 1d 01 	lds	r17, 0x011D
 588:	87 e1       	ldi	r24, 0x17	; 23
 58a:	91 e0       	ldi	r25, 0x01	; 1
 58c:	65 e0       	ldi	r22, 0x05	; 5
 58e:	70 e0       	ldi	r23, 0x00	; 0
 590:	9e de       	rcall	.-708    	; 0x2ce <calcCheckSum>
 592:	08 17       	cp	r16, r24
 594:	19 07       	cpc	r17, r25
 596:	09 f0       	breq	.+2      	; 0x59a <main+0x82>
            calcCheckSum((uint8_t *)&eeprom, sizeof(eeprom) - sizeof(eeprom.checksum))))
    calcNewId();
 598:	87 df       	rcall	.-242    	; 0x4a8 <calcNewId>
  cc2500_Init(eeprom.power);
 59a:	80 91 1a 01 	lds	r24, 0x011A
 59e:	52 d4       	rcall	.+2212   	; 0xe44 <cc2500_Init>
  if(!checkcc2500())
 5a0:	12 d4       	rcall	.+2084   	; 0xdc6 <checkcc2500>
 5a2:	88 23       	and	r24, r24
 5a4:	29 f4       	brne	.+10     	; 0x5b0 <main+0x98>
    SET_BIT(state.ledError, L_INIT_ERROR);
 5a6:	80 91 48 01 	lds	r24, 0x0148
 5aa:	80 68       	ori	r24, 0x80	; 128
 5ac:	80 93 48 01 	sts	0x0148, r24
  cc2500WriteReg(CC2500_SYNC0,(unsigned char)eeprom.bind.id);
 5b0:	85 e0       	ldi	r24, 0x05	; 5
 5b2:	60 91 17 01 	lds	r22, 0x0117
 5b6:	7d d3       	rcall	.+1786   	; 0xcb2 <cc2500WriteReg>
  cc2500WriteReg(CC2500_SYNC1,(unsigned char)(eeprom.bind.id >> 8));
 5b8:	60 91 17 01 	lds	r22, 0x0117
 5bc:	70 91 18 01 	lds	r23, 0x0118
 5c0:	67 2f       	mov	r22, r23
 5c2:	77 27       	eor	r23, r23
 5c4:	84 e0       	ldi	r24, 0x04	; 4
 5c6:	75 d3       	rcall	.+1770   	; 0xcb2 <cc2500WriteReg>
  if(eeprom.ccaOff)
 5c8:	80 91 1b 01 	lds	r24, 0x011B
 5cc:	88 23       	and	r24, r24
 5ce:	19 f0       	breq	.+6      	; 0x5d6 <main+0xbe>
    cc2500WriteReg(CC2500_MCSM1, SMARTRF_SETTING_MCSM1 & ~0x30);
 5d0:	87 e1       	ldi	r24, 0x17	; 23
 5d2:	60 e0       	ldi	r22, 0x00	; 0
 5d4:	02 c0       	rjmp	.+4      	; 0x5da <main+0xc2>
  else
    cc2500WriteReg(CC2500_MCSM1, (SMARTRF_SETTING_MCSM1 | 0x10) & ~0x20);
 5d6:	87 e1       	ldi	r24, 0x17	; 23
 5d8:	60 e1       	ldi	r22, 0x10	; 16
 5da:	6b d3       	rcall	.+1750   	; 0xcb2 <cc2500WriteReg>
  set_sleep_mode(SLEEP_MODE_IDLE);
 5dc:	83 b7       	in	r24, 0x33	; 51
 5de:	81 7f       	andi	r24, 0xF1	; 241
 5e0:	83 bf       	out	0x33, r24	; 51
  USART_Init(BRATE);
 5e2:	81 e0       	ldi	r24, 0x01	; 1
 5e4:	90 e0       	ldi	r25, 0x00	; 0
 5e6:	ba de       	rcall	.-652    	; 0x35c <USART_Init>

  wdt_enable(WDTO_30MS);
 5e8:	29 e0       	ldi	r18, 0x09	; 9
 5ea:	88 e1       	ldi	r24, 0x18	; 24
 5ec:	90 e0       	ldi	r25, 0x00	; 0
 5ee:	0f b6       	in	r0, 0x3f	; 63
 5f0:	f8 94       	cli
 5f2:	a8 95       	wdr
 5f4:	80 93 60 00 	sts	0x0060, r24
 5f8:	0f be       	out	0x3f, r0	; 63
 5fa:	20 93 60 00 	sts	0x0060, r18

// Timer1 8MHz   PPM Capture
  TCCR1A = 0;
 5fe:	10 92 80 00 	sts	0x0080, r1
  TCCR1B = (1 << ICNC1) | (1 << CS10);      // 8MHz, Input Capture Noise Canceler, falling edge
 602:	81 e8       	ldi	r24, 0x81	; 129
 604:	80 93 81 00 	sts	0x0081, r24
  TCNT1 = 0;
 608:	10 92 85 00 	sts	0x0085, r1
 60c:	10 92 84 00 	sts	0x0084, r1
  TIFR1 = 0xff;
 610:	2f ef       	ldi	r18, 0xFF	; 255
 612:	26 bb       	out	0x16, r18	; 22
  TIMSK1 = (1 << ICIE1);
 614:	80 e2       	ldi	r24, 0x20	; 32
 616:	80 93 6f 00 	sts	0x006F, r24

// Timer2  für Statemachine
  TCCR2A = (2 << WGM20);                        //  CTC mode
 61a:	92 e0       	ldi	r25, 0x02	; 2
 61c:	90 93 b0 00 	sts	0x00B0, r25
  TCCR2B = (6 << CS20);                         // clk/256
 620:	86 e0       	ldi	r24, 0x06	; 6
 622:	80 93 b1 00 	sts	0x00B1, r24
  OCR2A  = CHANTIME;
 626:	82 e4       	ldi	r24, 0x42	; 66
 628:	80 93 b3 00 	sts	0x00B3, r24
  TCNT2 = 0;
 62c:	10 92 b2 00 	sts	0x00B2, r1
  TIFR2  = 0xff;
 630:	27 bb       	out	0x17, r18	; 23
  TIMSK2 = (1 << OCIE2A);
 632:	90 93 70 00 	sts	0x0070, r25

  LEDRED_OFF;
 636:	40 98       	cbi	0x08, 0	; 8
  LEDGREEN_ON;
 638:	41 9a       	sbi	0x08, 1	; 8

#ifdef DEBUG
  testsperre = 0xff;
#endif

  sei();
 63a:	78 94       	sei
  while(1){
    if(TIFR0 & (1 << TOV0))
    {
      ++Timer33ms;
//      SET_BIT(TIFR0, TOV0);
      TIFR0 = (1 << TOV0);
 63c:	01 e0       	ldi	r16, 0x01	; 1
  testsperre = 0xff;
#endif

  sei();
  while(1){
    if(TIFR0 & (1 << TOV0))
 63e:	a8 9b       	sbis	0x15, 0	; 21
 640:	0c c0       	rjmp	.+24     	; 0x65a <main+0x142>
    {
      ++Timer33ms;
 642:	80 91 5e 01 	lds	r24, 0x015E
 646:	90 91 5f 01 	lds	r25, 0x015F
 64a:	01 96       	adiw	r24, 0x01	; 1
 64c:	90 93 5f 01 	sts	0x015F, r25
 650:	80 93 5e 01 	sts	0x015E, r24
//      SET_BIT(TIFR0, TOV0);
      TIFR0 = (1 << TOV0);
 654:	05 bb       	out	0x15, r16	; 21
      set_led();
 656:	d0 dd       	rcall	.-1120   	; 0x1f8 <set_led>
      chkFailSafe();
 658:	71 de       	rcall	.-798    	; 0x33c <chkFailSafe>
    }
    sendTelemetrie2UART();           // Hier ist am meisten Zeit
 65a:	56 de       	rcall	.-852    	; 0x308 <sendTelemetrie2UART>

//    if(state.InterruptAlive)
    {
//      state.InterruptAlive = false;
      if(Heartbeat)
 65c:	80 91 60 01 	lds	r24, 0x0160
 660:	88 23       	and	r24, r24
 662:	19 f0       	breq	.+6      	; 0x66a <main+0x152>
      {
        wdt_reset();
 664:	a8 95       	wdr
        Heartbeat = false;
 666:	10 92 60 01 	sts	0x0160, r1
      }
    }
    sleep_mode();                   //    warten bis Timer (Interrupt)
 66a:	83 b7       	in	r24, 0x33	; 51
 66c:	81 60       	ori	r24, 0x01	; 1
 66e:	83 bf       	out	0x33, r24	; 51
 670:	88 95       	sleep
 672:	83 b7       	in	r24, 0x33	; 51
 674:	8e 7f       	andi	r24, 0xFE	; 254
 676:	83 bf       	out	0x33, r24	; 51
 678:	e2 cf       	rjmp	.-60     	; 0x63e <main+0x126>

0000067a <setNextChanRx>:
  cc2500CommandStrobe(CC2500_SRX);
}

void setNextChanRx(void)                      // Kanal schreiben und nach RX
{
  RES_BIT(PORTB, OUT_B_CTX);
 67a:	29 98       	cbi	0x05, 1	; 5
  SET_BIT(PORTD, OUT_D_CRX);		      // Auf Empfang umschalten
 67c:	5d 9a       	sbi	0x0b, 5	; 11
  RES_BIT(EIMSK, INT0);                    // INT0 aus
 67e:	e8 98       	cbi	0x1d, 0	; 29
  if(PIND & (1<<INP_D_CC2500_GDO0))
 680:	4a 9b       	sbis	0x09, 2	; 9
 682:	05 c0       	rjmp	.+10     	; 0x68e <setNextChanRx+0x14>
    SET_BIT(state.ledError, L_NOT_READY);
 684:	80 91 48 01 	lds	r24, 0x0148
 688:	80 64       	ori	r24, 0x40	; 64
 68a:	80 93 48 01 	sts	0x0148, r24
  setNextChan();
 68e:	74 de       	rcall	.-792    	; 0x378 <setNextChan>

  if(!eeprom.ccaOff && !state.ccaCount)
 690:	80 91 1b 01 	lds	r24, 0x011B
 694:	88 23       	and	r24, r24
 696:	39 f4       	brne	.+14     	; 0x6a6 <setNextChanRx+0x2c>
 698:	80 91 49 01 	lds	r24, 0x0149
 69c:	88 23       	and	r24, r24
 69e:	19 f4       	brne	.+6      	; 0x6a6 <setNextChanRx+0x2c>
    cc2500WriteReg(CC2500_MCSM1, (SMARTRF_SETTING_MCSM1 | 0x10) & ~0x20);  // ein
 6a0:	87 e1       	ldi	r24, 0x17	; 23
 6a2:	60 e1       	ldi	r22, 0x10	; 16
 6a4:	06 d3       	rcall	.+1548   	; 0xcb2 <cc2500WriteReg>

  cc2500CommandStrobe(CC2500_SFTX);       // Flush TX
 6a6:	8b e3       	ldi	r24, 0x3B	; 59
 6a8:	48 d3       	rcall	.+1680   	; 0xd3a <cc2500CommandStrobe>
  cc2500CommandStrobe(CC2500_SRX);
 6aa:	84 e3       	ldi	r24, 0x34	; 52
 6ac:	46 d3       	rcall	.+1676   	; 0xd3a <cc2500CommandStrobe>
}
 6ae:	08 95       	ret

000006b0 <setRx>:
  cc2500WriteRegCheckIdle(CC2500_CHANNR, tempChan);
}

void setRx(void)                      // nach RX
{
  RES_BIT(PORTB, OUT_B_CTX);
 6b0:	29 98       	cbi	0x05, 1	; 5
  SET_BIT(PORTD, OUT_D_CRX);		      // Auf Empfang umschalten
 6b2:	5d 9a       	sbi	0x0b, 5	; 11
  RES_BIT(EIMSK, INT0);                    // INT0 aus
 6b4:	e8 98       	cbi	0x1d, 0	; 29
  if(PIND & (1<<INP_D_CC2500_GDO0))
 6b6:	4a 9b       	sbis	0x09, 2	; 9
 6b8:	05 c0       	rjmp	.+10     	; 0x6c4 <setRx+0x14>
    SET_BIT(state.ledError, L_NOT_READY);
 6ba:	80 91 48 01 	lds	r24, 0x0148
 6be:	80 64       	ori	r24, 0x40	; 64
 6c0:	80 93 48 01 	sts	0x0148, r24
  cc2500CommandStrobe(CC2500_SFTX);       // Flush TX
 6c4:	8b e3       	ldi	r24, 0x3B	; 59
 6c6:	39 d3       	rcall	.+1650   	; 0xd3a <cc2500CommandStrobe>
  cc2500CommandStrobe(CC2500_SRX);
 6c8:	84 e3       	ldi	r24, 0x34	; 52
 6ca:	37 d3       	rcall	.+1646   	; 0xd3a <cc2500CommandStrobe>
}
 6cc:	08 95       	ret

000006ce <setNext>:
  SET_BIT(state.ledError, L_EEPROM_ERR);
}

void setNext(void)
{
  if(!state.txCount)
 6ce:	80 91 47 01 	lds	r24, 0x0147
 6d2:	88 23       	and	r24, r24
 6d4:	19 f4       	brne	.+6      	; 0x6dc <setNext+0xe>
  {
    calibrateSlow();              // wechselt auf idle
 6d6:	23 d3       	rcall	.+1606   	; 0xd1e <calibrateSlow>
//    gotoIdle();                   // Wenn Daten empfangen auf Idle wechseln
//    cc2500WriteRegCheckIdle(CC2500_PKTLEN, sizeof(Telemetrie));  Ist gleich wie MessageData
    setRx();                     // Frequenz nicht wechseln
 6d8:	eb df       	rcall	.-42     	; 0x6b0 <setRx>
 6da:	08 95       	ret
  }
  else
    setNextChanRx();
 6dc:	ce df       	rcall	.-100    	; 0x67a <setNextChanRx>
 6de:	08 95       	ret

000006e0 <tx_error>:
}

void tx_error(void)       // Achtung bei CCA
{
//  if(eeprom.ccaOff)
    SET_BIT(state.ledError,L_NOT_TX);
 6e0:	80 91 48 01 	lds	r24, 0x0148
 6e4:	80 61       	ori	r24, 0x10	; 16
 6e6:	80 93 48 01 	sts	0x0148, r24
//    if(state.ccaCount >= 5)
//    {
//      cc2500WriteRegCheckIdle(CC2500_MCSM1, SMARTRF_SETTING_MCSM1 & ~0x30);  // aus
//    }
//  }
  setNext();                            // Empfang ein
 6ea:	f1 df       	rcall	.-30     	; 0x6ce <setNext>
}
 6ec:	08 95       	ret

000006ee <copyTx>:
  else
    return(0);
}*/

void copyTx(bool lastFlag, uint8_t type)
{
 6ee:	cf 93       	push	r28
 6f0:	df 93       	push	r29
  static MessageChan mes;
  uint8_t i;
  uint16_t high;
  high = 0;
  uint8_t ofs = (type & 0x3) * 4;
 6f2:	26 2f       	mov	r18, r22
 6f4:	22 0f       	add	r18, r18
 6f6:	22 0f       	add	r18, r18
 6f8:	2c 70       	andi	r18, 0x0C	; 12
  mes.rts = lastFlag;
 6fa:	87 95       	ror	r24
 6fc:	88 27       	eor	r24, r24
 6fe:	87 95       	ror	r24
 700:	90 91 07 01 	lds	r25, 0x0107
 704:	9f 70       	andi	r25, 0x0F	; 15
  mes.type = type;
 706:	67 70       	andi	r22, 0x07	; 7
 708:	62 95       	swap	r22
 70a:	60 7f       	andi	r22, 0xF0	; 240
 70c:	98 2b       	or	r25, r24
 70e:	96 2b       	or	r25, r22
 710:	90 93 07 01 	sts	0x0107, r25
 714:	60 e0       	ldi	r22, 0x00	; 0
 716:	70 e0       	ldi	r23, 0x00	; 0
 718:	a0 e0       	ldi	r26, 0x00	; 0
 71a:	b0 e0       	ldi	r27, 0x00	; 0
 71c:	c2 2f       	mov	r28, r18
 71e:	d0 e0       	ldi	r29, 0x00	; 0
 720:	fd 01       	movw	r30, r26
 722:	ec 0f       	add	r30, r28
 724:	fd 1f       	adc	r31, r29
  for(i = 0;i < 4;++i)
  {
    uint16_t temp;
    do
      temp = output.chan_1us[ofs + i];
 726:	ee 0f       	add	r30, r30
 728:	ff 1f       	adc	r31, r31
 72a:	e2 5e       	subi	r30, 0xE2	; 226
 72c:	fe 4f       	sbci	r31, 0xFE	; 254
 72e:	40 81       	ld	r20, Z
 730:	51 81       	ldd	r21, Z+1	; 0x01
    while(temp != output.chan_1us[ofs + i]);      // Testen ob Interrupt es verändert hat
 732:	80 81       	ld	r24, Z
 734:	91 81       	ldd	r25, Z+1	; 0x01
 736:	48 17       	cp	r20, r24
 738:	59 07       	cpc	r21, r25
 73a:	91 f7       	brne	.-28     	; 0x720 <copyTx+0x32>
    uint8_t temp_low = temp & 0xff;
    mes.chan_1uslow[i] = temp_low;
 73c:	fd 01       	movw	r30, r26
 73e:	ee 5f       	subi	r30, 0xFE	; 254
 740:	fe 4f       	sbci	r31, 0xFE	; 254
 742:	40 83       	st	Z, r20
    uint8_t temp_high = (temp >> 8) & 0x7;      // auf 3 Bits beschränken
    high <<= 3;
 744:	9b 01       	movw	r18, r22
 746:	93 e0       	ldi	r25, 0x03	; 3
 748:	22 0f       	add	r18, r18
 74a:	33 1f       	adc	r19, r19
 74c:	9a 95       	dec	r25
 74e:	e1 f7       	brne	.-8      	; 0x748 <copyTx+0x5a>
    high |= temp_high;
 750:	85 2f       	mov	r24, r21
 752:	99 27       	eor	r25, r25
 754:	87 70       	andi	r24, 0x07	; 7
 756:	68 2f       	mov	r22, r24
 758:	70 e0       	ldi	r23, 0x00	; 0
 75a:	62 2b       	or	r22, r18
 75c:	73 2b       	or	r23, r19
 75e:	11 96       	adiw	r26, 0x01	; 1
  uint16_t high;
  high = 0;
  uint8_t ofs = (type & 0x3) * 4;
  mes.rts = lastFlag;
  mes.type = type;
  for(i = 0;i < 4;++i)
 760:	a4 30       	cpi	r26, 0x04	; 4
 762:	b1 05       	cpc	r27, r1
 764:	e9 f6       	brne	.-70     	; 0x720 <copyTx+0x32>
    mes.chan_1uslow[i] = temp_low;
    uint8_t temp_high = (temp >> 8) & 0x7;      // auf 3 Bits beschränken
    high <<= 3;
    high |= temp_high;
  }
  mes.chan_1ushigh = high;
 766:	60 93 06 01 	sts	0x0106, r22
 76a:	97 2f       	mov	r25, r23
 76c:	9f 70       	andi	r25, 0x0F	; 15
 76e:	80 91 07 01 	lds	r24, 0x0107
 772:	80 7f       	andi	r24, 0xF0	; 240
 774:	89 2b       	or	r24, r25
 776:	80 93 07 01 	sts	0x0107, r24
  if((cc2500WriteFIFOBlock((uint8_t *)&mes, sizeof(MessageChan)) & CC2500_STATUS_STATE_BM) < CC2500_STATE_TX)
 77a:	82 e0       	ldi	r24, 0x02	; 2
 77c:	91 e0       	ldi	r25, 0x01	; 1
 77e:	66 e0       	ldi	r22, 0x06	; 6
 780:	ed d2       	rcall	.+1498   	; 0xd5c <cc2500WriteFIFOBlock>
 782:	90 e0       	ldi	r25, 0x00	; 0
 784:	80 77       	andi	r24, 0x70	; 112
 786:	90 70       	andi	r25, 0x00	; 0
 788:	80 97       	sbiw	r24, 0x20	; 32
 78a:	14 f4       	brge	.+4      	; 0x790 <copyTx+0xa2>
    tx_error();
 78c:	a9 df       	rcall	.-174    	; 0x6e0 <tx_error>
 78e:	01 c0       	rjmp	.+2      	; 0x792 <copyTx+0xa4>
  else
    tx_ok();
 790:	ac dd       	rcall	.-1192   	; 0x2ea <tx_ok>
}
 792:	df 91       	pop	r29
 794:	cf 91       	pop	r28
 796:	08 95       	ret

00000798 <TxSendcommand>:
  if(state.ccaCount > 0)
    --state.ccaCount;
}

void TxSendcommand(MessageData *mes)
{
 798:	df 93       	push	r29
 79a:	cf 93       	push	r28
 79c:	00 d0       	rcall	.+0      	; 0x79e <TxSendcommand+0x6>
 79e:	cd b7       	in	r28, 0x3d	; 61
 7a0:	de b7       	in	r29, 0x3e	; 62
 7a2:	9a 83       	std	Y+2, r25	; 0x02
 7a4:	89 83       	std	Y+1, r24	; 0x01
  if((cc2500WriteFIFOBlock((uint8_t *)&mes, sizeof(MessageData)) & CC2500_STATUS_STATE_BM) < CC2500_STATE_TX)
 7a6:	ce 01       	movw	r24, r28
 7a8:	01 96       	adiw	r24, 0x01	; 1
 7aa:	66 e0       	ldi	r22, 0x06	; 6
 7ac:	d7 d2       	rcall	.+1454   	; 0xd5c <cc2500WriteFIFOBlock>
 7ae:	90 e0       	ldi	r25, 0x00	; 0
 7b0:	80 77       	andi	r24, 0x70	; 112
 7b2:	90 70       	andi	r25, 0x00	; 0
 7b4:	80 97       	sbiw	r24, 0x20	; 32
 7b6:	14 f4       	brge	.+4      	; 0x7bc <TxSendcommand+0x24>
    tx_error();
 7b8:	93 df       	rcall	.-218    	; 0x6e0 <tx_error>
 7ba:	01 c0       	rjmp	.+2      	; 0x7be <TxSendcommand+0x26>
  else
    tx_ok();
 7bc:	96 dd       	rcall	.-1236   	; 0x2ea <tx_ok>
}
 7be:	0f 90       	pop	r0
 7c0:	0f 90       	pop	r0
 7c2:	cf 91       	pop	r28
 7c4:	df 91       	pop	r29
 7c6:	08 95       	ret

000007c8 <TxSendData>:

void TxSendData(bool lastFlag)
{
  static MessageCommand mes;

  mes.type = 0x7;               // Kommando
 7c8:	90 91 0d 01 	lds	r25, 0x010D
 7cc:	90 67       	ori	r25, 0x70	; 112
  mes.rts = lastFlag;
 7ce:	28 2f       	mov	r18, r24
 7d0:	27 95       	ror	r18
 7d2:	22 27       	eor	r18, r18
 7d4:	27 95       	ror	r18
 7d6:	9f 77       	andi	r25, 0x7F	; 127
 7d8:	92 2b       	or	r25, r18
 7da:	90 93 0d 01 	sts	0x010D, r25

  if(state.SetFaileSafe)
 7de:	80 91 42 01 	lds	r24, 0x0142
 7e2:	88 23       	and	r24, r24
 7e4:	61 f0       	breq	.+24     	; 0x7fe <TxSendData+0x36>
  {
    mes.command = 1;
 7e6:	81 e0       	ldi	r24, 0x01	; 1
 7e8:	90 e0       	ldi	r25, 0x00	; 0
 7ea:	90 93 0c 01 	sts	0x010C, r25
 7ee:	80 93 0b 01 	sts	0x010B, r24
    TxSendcommand((MessageData *)&mes);                 // Failsafe- Position auf aktuelle Position setzen
 7f2:	88 e0       	ldi	r24, 0x08	; 8
 7f4:	91 e0       	ldi	r25, 0x01	; 1
 7f6:	d0 df       	rcall	.-96     	; 0x798 <TxSendcommand>
    state.SetFaileSafe = false;
 7f8:	10 92 42 01 	sts	0x0142, r1
 7fc:	08 95       	ret
  }
  else
  {
    if(state.newCommand)                                // Kommando vom UART
 7fe:	80 91 44 01 	lds	r24, 0x0144
 802:	88 23       	and	r24, r24
 804:	61 f0       	breq	.+24     	; 0x81e <TxSendData+0x56>
    {
      sendMes.Uart.rts = lastFlag;
 806:	80 91 54 01 	lds	r24, 0x0154
 80a:	8f 77       	andi	r24, 0x7F	; 127
 80c:	82 2b       	or	r24, r18
 80e:	80 93 54 01 	sts	0x0154, r24
      TxSendcommand(&sendMes);
 812:	8f e4       	ldi	r24, 0x4F	; 79
 814:	91 e0       	ldi	r25, 0x01	; 1
 816:	c0 df       	rcall	.-128    	; 0x798 <TxSendcommand>
      state.newCommand = false;
 818:	10 92 44 01 	sts	0x0144, r1
 81c:	08 95       	ret
    }
    else
    {
      mes.command = 0;                                  // Dummy
 81e:	10 92 0c 01 	sts	0x010C, r1
 822:	10 92 0b 01 	sts	0x010B, r1
      TxSendcommand((MessageData *)&mes);
 826:	88 e0       	ldi	r24, 0x08	; 8
 828:	91 e0       	ldi	r25, 0x01	; 1
 82a:	b6 df       	rcall	.-148    	; 0x798 <TxSendcommand>
 82c:	08 95       	ret

0000082e <TxSend>:
  else
    tx_ok();
}

void TxSend(bool lastFlag)
{
 82e:	1f 93       	push	r17
 830:	98 2f       	mov	r25, r24
  static uint8_t groupBackup;

  uint8_t syncTemp = output.ppmSync;
 832:	10 91 3e 01 	lds	r17, 0x013E
  if(syncTemp == 4)
 836:	14 30       	cpi	r17, 0x04	; 4
 838:	21 f4       	brne	.+8      	; 0x842 <TxSend+0x14>
  {                                                   // untere Gruppe senden
//    UDR0 = 'B';                                       // Puls für Sender zum Synchronisieren
    copyTx(lastFlag, 4);
 83a:	64 e0       	ldi	r22, 0x04	; 4
 83c:	58 df       	rcall	.-336    	; 0x6ee <copyTx>
 83e:	13 e0       	ldi	r17, 0x03	; 3
 840:	2c c0       	rjmp	.+88     	; 0x89a <TxSend+0x6c>
    --syncTemp;
  }
  else if(syncTemp != 0)
 842:	11 23       	and	r17, r17
 844:	69 f0       	breq	.+26     	; 0x860 <TxSend+0x32>
  {                                                    // obere Gruppe senden
    copyTx(lastFlag, 4 - syncTemp);
 846:	64 e0       	ldi	r22, 0x04	; 4
 848:	61 1b       	sub	r22, r17
 84a:	51 df       	rcall	.-350    	; 0x6ee <copyTx>
    if((syncTemp == 3) && (state.maxChan <= 8))
 84c:	13 30       	cpi	r17, 0x03	; 3
 84e:	31 f4       	brne	.+12     	; 0x85c <TxSend+0x2e>
 850:	80 91 46 01 	lds	r24, 0x0146
 854:	89 30       	cpi	r24, 0x09	; 9
 856:	10 f4       	brcc	.+4      	; 0x85c <TxSend+0x2e>
 858:	10 e0       	ldi	r17, 0x00	; 0
 85a:	1f c0       	rjmp	.+62     	; 0x89a <TxSend+0x6c>
      syncTemp = 0;                             // nur untere 8 Kanäle ausgeben
    else
      --syncTemp;
 85c:	11 50       	subi	r17, 0x01	; 1
 85e:	1d c0       	rjmp	.+58     	; 0x89a <TxSend+0x6c>
  }
  else if(state.SetFaileSafe || state.newCommand)
 860:	80 91 42 01 	lds	r24, 0x0142
 864:	88 23       	and	r24, r24
 866:	21 f4       	brne	.+8      	; 0x870 <TxSend+0x42>
 868:	80 91 44 01 	lds	r24, 0x0144
 86c:	88 23       	and	r24, r24
 86e:	19 f0       	breq	.+6      	; 0x876 <TxSend+0x48>
  {
    TxSendData(lastFlag);
 870:	89 2f       	mov	r24, r25
 872:	aa df       	rcall	.-172    	; 0x7c8 <TxSendData>
 874:	12 c0       	rjmp	.+36     	; 0x89a <TxSend+0x6c>
  }
  else 
  {
    copyTx(lastFlag, groupBackup);
 876:	89 2f       	mov	r24, r25
 878:	60 91 01 01 	lds	r22, 0x0101
 87c:	38 df       	rcall	.-400    	; 0x6ee <copyTx>
    ++groupBackup;
 87e:	90 91 01 01 	lds	r25, 0x0101
 882:	9f 5f       	subi	r25, 0xFF	; 255
 884:	90 93 01 01 	sts	0x0101, r25
    if(state.maxChan <= 8)
 888:	80 91 46 01 	lds	r24, 0x0146
 88c:	89 30       	cpi	r24, 0x09	; 9
 88e:	10 f4       	brcc	.+4      	; 0x894 <TxSend+0x66>
      groupBackup &= 0x1;
 890:	91 70       	andi	r25, 0x01	; 1
 892:	01 c0       	rjmp	.+2      	; 0x896 <TxSend+0x68>
    else
      groupBackup &= 0x3;
 894:	93 70       	andi	r25, 0x03	; 3
 896:	90 93 01 01 	sts	0x0101, r25
  }
  output.ppmSync = syncTemp;                    // Interrupt macht nichts, so lange nicht zu oft
 89a:	10 93 3e 01 	sts	0x013E, r17
}
 89e:	1f 91       	pop	r17
 8a0:	08 95       	ret

000008a2 <__vector_1>:
  Heartbeat = true;
}

//uint8_t tes;
ISR(INT0_vect, ISR_NOBLOCK)                // Wird ausgelöst wenn Senden fertig
{
 8a2:	78 94       	sei
 8a4:	1f 92       	push	r1
 8a6:	0f 92       	push	r0
 8a8:	0f b6       	in	r0, 0x3f	; 63
 8aa:	0f 92       	push	r0
 8ac:	11 24       	eor	r1, r1
 8ae:	2f 93       	push	r18
 8b0:	3f 93       	push	r19
 8b2:	4f 93       	push	r20
 8b4:	5f 93       	push	r21
 8b6:	6f 93       	push	r22
 8b8:	7f 93       	push	r23
 8ba:	8f 93       	push	r24
 8bc:	9f 93       	push	r25
 8be:	af 93       	push	r26
 8c0:	bf 93       	push	r27
 8c2:	ef 93       	push	r30
 8c4:	ff 93       	push	r31
  RES_BIT(EIMSK, INT0);                    // INT0 aus
 8c6:	e8 98       	cbi	0x1d, 0	; 29
  RES_BIT(TIMSK2, OCIE2A);                 // Timerinterrupt aus
 8c8:	80 91 70 00 	lds	r24, 0x0070
 8cc:	8d 7f       	andi	r24, 0xFD	; 253
 8ce:	80 93 70 00 	sts	0x0070, r24
  if(InterruptAct)                         // Timerinterrupt ist noch aktiv
 8d2:	80 91 55 01 	lds	r24, 0x0155
 8d6:	88 23       	and	r24, r24
 8d8:	31 f0       	breq	.+12     	; 0x8e6 <__vector_1+0x44>
  {
    SET_BIT(state.ledError, L_NOT_RX);     // Ursache kann Capture sein
 8da:	80 91 48 01 	lds	r24, 0x0148
 8de:	80 62       	ori	r24, 0x20	; 32
 8e0:	80 93 48 01 	sts	0x0148, r24
 8e4:	0e c0       	rjmp	.+28     	; 0x902 <__vector_1+0x60>
//    tes = TCNT2;
  //  if(TCNT2 > CYCLETIME + 10)
  //    OCR2A = TCNT2 + 2;
//  RES_BIT(PORTB, OUT_B_CTX);
//  SET_BIT(PORTD, OUT_D_CRX);
  setNext();
 8e6:	f3 de       	rcall	.-538    	; 0x6ce <setNext>
  if(TIFR2 & (1 << OCF2A))
 8e8:	b9 9b       	sbis	0x17, 1	; 23
 8ea:	05 c0       	rjmp	.+10     	; 0x8f6 <__vector_1+0x54>
    SET_BIT(state.ledError, L_NOT_RX);     // Ursache kann Capture sein
 8ec:	80 91 48 01 	lds	r24, 0x0148
 8f0:	80 62       	ori	r24, 0x20	; 32
 8f2:	80 93 48 01 	sts	0x0148, r24
  cli();
 8f6:	f8 94       	cli
  SET_BIT(TIMSK2, OCIE2A);                 // Timerinterrupt ein
 8f8:	80 91 70 00 	lds	r24, 0x0070
 8fc:	82 60       	ori	r24, 0x02	; 2
 8fe:	80 93 70 00 	sts	0x0070, r24
}
 902:	ff 91       	pop	r31
 904:	ef 91       	pop	r30
 906:	bf 91       	pop	r27
 908:	af 91       	pop	r26
 90a:	9f 91       	pop	r25
 90c:	8f 91       	pop	r24
 90e:	7f 91       	pop	r23
 910:	6f 91       	pop	r22
 912:	5f 91       	pop	r21
 914:	4f 91       	pop	r20
 916:	3f 91       	pop	r19
 918:	2f 91       	pop	r18
 91a:	0f 90       	pop	r0
 91c:	0f be       	out	0x3f, r0	; 63
 91e:	0f 90       	pop	r0
 920:	1f 90       	pop	r1
 922:	18 95       	reti

00000924 <setBindMode>:
  while(!(PINB & (1<<OUT_B_SPI_SS)));
}

void setBindMode(void)
{
  cc2500WriteReg(CC2500_SYNC0, (unsigned char)BINDMODEID);
 924:	85 e0       	ldi	r24, 0x05	; 5
 926:	69 e0       	ldi	r22, 0x09	; 9
 928:	c4 d1       	rcall	.+904    	; 0xcb2 <cc2500WriteReg>
  cc2500WriteReg(CC2500_SYNC1, (unsigned char)(BINDMODEID >> 8));
 92a:	84 e0       	ldi	r24, 0x04	; 4
 92c:	60 e1       	ldi	r22, 0x10	; 16
 92e:	c1 d1       	rcall	.+898    	; 0xcb2 <cc2500WriteReg>
  cc2500WriteReg(CC2500_PKTLEN, sizeof(eeprom.bind));
 930:	86 e0       	ldi	r24, 0x06	; 6
 932:	63 e0       	ldi	r22, 0x03	; 3
 934:	be d1       	rcall	.+892    	; 0xcb2 <cc2500WriteReg>
  state.bindmode = true;
 936:	81 e0       	ldi	r24, 0x01	; 1
 938:	80 93 41 01 	sts	0x0141, r24
  cc2500setPatableMax(0x7f);             // Sendeleistung runter
 93c:	8f e7       	ldi	r24, 0x7F	; 127
 93e:	ff d1       	rcall	.+1022   	; 0xd3e <cc2500setPatableMax>
}
 940:	08 95       	ret

00000942 <txState>:
uint8_t testlaenge;
uint8_t sperre;
#endif

void txState(void)
{
 942:	1f 93       	push	r17
  static enum transmitter txstate;
  uint8_t anz;
  bool res;

  switch(txstate)
 944:	80 91 00 01 	lds	r24, 0x0100
 948:	82 30       	cpi	r24, 0x02	; 2
 94a:	09 f4       	brne	.+2      	; 0x94e <txState+0xc>
 94c:	4d c0       	rjmp	.+154    	; 0x9e8 <txState+0xa6>
 94e:	83 30       	cpi	r24, 0x03	; 3
 950:	30 f4       	brcc	.+12     	; 0x95e <txState+0x1c>
 952:	88 23       	and	r24, r24
 954:	59 f0       	breq	.+22     	; 0x96c <txState+0x2a>
 956:	81 30       	cpi	r24, 0x01	; 1
 958:	09 f0       	breq	.+2      	; 0x95c <txState+0x1a>
 95a:	84 c0       	rjmp	.+264    	; 0xa64 <txState+0x122>
 95c:	18 c0       	rjmp	.+48     	; 0x98e <txState+0x4c>
 95e:	83 30       	cpi	r24, 0x03	; 3
 960:	09 f4       	brne	.+2      	; 0x964 <txState+0x22>
 962:	4f c0       	rjmp	.+158    	; 0xa02 <txState+0xc0>
 964:	84 30       	cpi	r24, 0x04	; 4
 966:	09 f0       	breq	.+2      	; 0x96a <txState+0x28>
 968:	7d c0       	rjmp	.+250    	; 0xa64 <txState+0x122>
 96a:	69 c0       	rjmp	.+210    	; 0xa3e <txState+0xfc>
  {
  case Start:
    sei();
 96c:	78 94       	sei
    if(checkKey())               // Taste prüfen
 96e:	3e dc       	rcall	.-1924   	; 0x1ec <checkKey>
 970:	88 23       	and	r24, r24
 972:	11 f0       	breq	.+4      	; 0x978 <txState+0x36>
      txstate = TxBindCheck;
 974:	83 e0       	ldi	r24, 0x03	; 3
 976:	60 c0       	rjmp	.+192    	; 0xa38 <txState+0xf6>
    else
    {
      OCR2A  = TELETIME;              // 3,003 ms
 978:	8c e5       	ldi	r24, 0x5C	; 92
 97a:	80 93 b3 00 	sts	0x00B3, r24
      cc2500WriteRegCheckIdle(CC2500_PKTLEN, sizeof(MessageData));
 97e:	86 e0       	ldi	r24, 0x06	; 6
 980:	66 e0       	ldi	r22, 0x06	; 6
 982:	b8 d1       	rcall	.+880    	; 0xcf4 <cc2500WriteRegCheckIdle>
      calibrateSlow();
 984:	cc d1       	rcall	.+920    	; 0xd1e <calibrateSlow>
      gotoIdle();                   // Wenn Daten empfangen auf Idle wechseln
 986:	c3 d1       	rcall	.+902    	; 0xd0e <gotoIdle>
      setNextChanRx();            // Frequenz einstellen
 988:	78 de       	rcall	.-784    	; 0x67a <setNextChanRx>
      txstate = RxCalc;           // Erstmal auf Empfang damit auch Kalibriert wird
 98a:	82 e0       	ldi	r24, 0x02	; 2
 98c:	55 c0       	rjmp	.+170    	; 0xa38 <txState+0xf6>
    break;
  case TxOn:                      // Daten senden
#ifdef DEBUG
    if((testsperre != state.txCount) && !sperre)
#endif
     res = cc2500_EnableTx();
 98e:	13 dd       	rcall	.-1498   	; 0x3b6 <cc2500_EnableTx>
 990:	98 2f       	mov	r25, r24
      else
        --sperre;
      res = false;
    }
#endif
    if(state.txCount >= 7)
 992:	80 91 47 01 	lds	r24, 0x0147
 996:	87 30       	cpi	r24, 0x07	; 7
 998:	80 f0       	brcs	.+32     	; 0x9ba <txState+0x78>
    {
      state.txCount = 0;
 99a:	10 92 47 01 	sts	0x0147, r1
      if(res)
 99e:	99 23       	and	r25, r25
 9a0:	19 f0       	breq	.+6      	; 0x9a8 <txState+0x66>
        TxSend(true);                // Empfang wird im Interrupt aktiviert
 9a2:	81 e0       	ldi	r24, 0x01	; 1
 9a4:	44 df       	rcall	.-376    	; 0x82e <TxSend>
 9a6:	01 c0       	rjmp	.+2      	; 0x9aa <txState+0x68>
      else
        setNext();
 9a8:	92 de       	rcall	.-732    	; 0x6ce <setNext>
      OCR2A  = (TELETIME08 + CHANTIME + 1);
 9aa:	8d e8       	ldi	r24, 0x8D	; 141
 9ac:	80 93 b3 00 	sts	0x00B3, r24
      txstate = RxCalc;
 9b0:	82 e0       	ldi	r24, 0x02	; 2
 9b2:	80 93 00 01 	sts	0x0100, r24
      UDR0 = 'C';                  // Aufforderung Kanäle schicken
 9b6:	83 e4       	ldi	r24, 0x43	; 67
 9b8:	14 c0       	rjmp	.+40     	; 0x9e2 <txState+0xa0>
    }
    else
    {
      ++state.txCount;
 9ba:	80 91 47 01 	lds	r24, 0x0147
 9be:	8f 5f       	subi	r24, 0xFF	; 255
 9c0:	80 93 47 01 	sts	0x0147, r24
      if(res)
 9c4:	99 23       	and	r25, r25
 9c6:	19 f0       	breq	.+6      	; 0x9ce <txState+0x8c>
        TxSend(false);
 9c8:	80 e0       	ldi	r24, 0x00	; 0
 9ca:	31 df       	rcall	.-414    	; 0x82e <TxSend>
 9cc:	01 c0       	rjmp	.+2      	; 0x9d0 <txState+0x8e>
      else
        setNext();
 9ce:	7f de       	rcall	.-770    	; 0x6ce <setNext>
      OCR2A  = CHANTIME;
 9d0:	82 e4       	ldi	r24, 0x42	; 66
 9d2:	80 93 b3 00 	sts	0x00B3, r24
      if(!state.newCommand)
 9d6:	80 91 44 01 	lds	r24, 0x0144
 9da:	88 23       	and	r24, r24
 9dc:	09 f0       	breq	.+2      	; 0x9e0 <txState+0x9e>
 9de:	40 c0       	rjmp	.+128    	; 0xa60 <txState+0x11e>
        UDR0 = 'Q';
 9e0:	81 e5       	ldi	r24, 0x51	; 81
 9e2:	80 93 c6 00 	sts	0x00C6, r24
 9e6:	3c c0       	rjmp	.+120    	; 0xa60 <txState+0x11e>
    }
    InterruptAct = false;
    break;
  case RxCalc:
    sei();
 9e8:	78 94       	sei
    OCR2A  = TELETIME02;
 9ea:	81 e1       	ldi	r24, 0x11	; 17
 9ec:	80 93 b3 00 	sts	0x00B3, r24
    anz = cc2500IdleGetRXB();
 9f0:	6c d1       	rcall	.+728    	; 0xcca <cc2500IdleGetRXB>
 9f2:	18 2f       	mov	r17, r24
    calibrateFast();
 9f4:	9b d1       	rcall	.+822    	; 0xd2c <calibrateFast>
    stayInRx();                         // Auf Empfang bleiben auch wenn Daten kommen (für CCA)
 9f6:	83 d1       	rcall	.+774    	; 0xcfe <stayInRx>
//    cc2500WriteRegCheckIdle(CC2500_PKTLEN, sizeof(MessageData));
    setNextChanRx();
 9f8:	40 de       	rcall	.-896    	; 0x67a <setNextChanRx>
    TxReceive(anz);                     // Empfangsdaten auswerten
 9fa:	81 2f       	mov	r24, r17
 9fc:	1f dd       	rcall	.-1474   	; 0x43c <TxReceive>
    txstate = TxOn;                     // Ein Durchlauf = 8*0,4c + 8*0,6c + 3 = 20,15 ms
 9fe:	81 e0       	ldi	r24, 0x01	; 1
 a00:	1b c0       	rjmp	.+54     	; 0xa38 <txState+0xf6>
    InterruptAct = false;
    break;
  case TxBindCheck:                     // Warten bis Taste losgelassen
    sei();
 a02:	78 94       	sei
    if(!checkKey())                     // Wenn Taste losgelassen
 a04:	f3 db       	rcall	.-2074   	; 0x1ec <checkKey>
 a06:	88 23       	and	r24, r24
 a08:	59 f5       	brne	.+86     	; 0xa60 <txState+0x11e>
    {
      if(Timer33ms > (5000 / 33))       // sehr langer Tastendruck (5s)
 a0a:	80 91 5e 01 	lds	r24, 0x015E
 a0e:	90 91 5f 01 	lds	r25, 0x015F
 a12:	88 39       	cpi	r24, 0x98	; 152
 a14:	91 05       	cpc	r25, r1
 a16:	08 f0       	brcs	.+2      	; 0xa1a <txState+0xd8>
        calcNewId();
 a18:	47 dd       	rcall	.-1394   	; 0x4a8 <calcNewId>
      setBindMode();
 a1a:	84 df       	rcall	.-248    	; 0x924 <setBindMode>
      calibrateSlow();
 a1c:	80 d1       	rcall	.+768    	; 0xd1e <calibrateSlow>
      setNextChanRx();
 a1e:	2d de       	rcall	.-934    	; 0x67a <setNextChanRx>
      state.txCount = 1;                // damit Sender immer läuft
 a20:	81 e0       	ldi	r24, 0x01	; 1
 a22:	80 93 47 01 	sts	0x0147, r24
      SET_BIT(state.ledError, L_BIND_ON);
 a26:	80 91 48 01 	lds	r24, 0x0148
 a2a:	82 60       	ori	r24, 0x02	; 2
 a2c:	80 93 48 01 	sts	0x0148, r24
      OCR2A  = CHANTIME2;
 a30:	85 e8       	ldi	r24, 0x85	; 133
 a32:	80 93 b3 00 	sts	0x00B3, r24
      txstate = TxOnBind;               // CHANTIME zum Senden
 a36:	84 e0       	ldi	r24, 0x04	; 4
 a38:	80 93 00 01 	sts	0x0100, r24
 a3c:	11 c0       	rjmp	.+34     	; 0xa60 <txState+0x11e>
    }
    InterruptAct = false;
    break;
  case TxOnBind:                        // Daten ins Senderegister
    if(cc2500_EnableTx())                  // Sender aktivieren, Interrupt ein
 a3e:	bb dc       	rcall	.-1674   	; 0x3b6 <cc2500_EnableTx>
 a40:	88 23       	and	r24, r24
 a42:	69 f0       	breq	.+26     	; 0xa5e <txState+0x11c>
    {
      if((cc2500WriteFIFOBlock((uint8_t *)&eeprom.bind, sizeof(eeprom.bind)) & CC2500_STATUS_STATE_BM) < CC2500_STATE_TX)
 a44:	87 e1       	ldi	r24, 0x17	; 23
 a46:	91 e0       	ldi	r25, 0x01	; 1
 a48:	63 e0       	ldi	r22, 0x03	; 3
 a4a:	88 d1       	rcall	.+784    	; 0xd5c <cc2500WriteFIFOBlock>
 a4c:	90 e0       	ldi	r25, 0x00	; 0
 a4e:	80 77       	andi	r24, 0x70	; 112
 a50:	90 70       	andi	r25, 0x00	; 0
 a52:	80 97       	sbiw	r24, 0x20	; 32
 a54:	14 f4       	brge	.+4      	; 0xa5a <txState+0x118>
        tx_error();
 a56:	44 de       	rcall	.-888    	; 0x6e0 <tx_error>
 a58:	03 c0       	rjmp	.+6      	; 0xa60 <txState+0x11e>
      else
        tx_ok();
 a5a:	47 dc       	rcall	.-1906   	; 0x2ea <tx_ok>
 a5c:	01 c0       	rjmp	.+2      	; 0xa60 <txState+0x11e>
    }
    else
      setNext();
 a5e:	37 de       	rcall	.-914    	; 0x6ce <setNext>
    InterruptAct = false;
 a60:	10 92 55 01 	sts	0x0155, r1
//    state.InterruptAlive = true;
    break;
  }
}
 a64:	1f 91       	pop	r17
 a66:	08 95       	ret

00000a68 <__vector_7>:
  MCUSR = 0;
  wdt_disable();
}

ISR(TIMER2_COMPA_vect)                 
{                                                // Wenn außerhalb Interrupt auch spi läuft krachts
 a68:	1f 92       	push	r1
 a6a:	0f 92       	push	r0
 a6c:	0f b6       	in	r0, 0x3f	; 63
 a6e:	0f 92       	push	r0
 a70:	11 24       	eor	r1, r1
 a72:	1f 93       	push	r17
 a74:	2f 93       	push	r18
 a76:	3f 93       	push	r19
 a78:	4f 93       	push	r20
 a7a:	5f 93       	push	r21
 a7c:	6f 93       	push	r22
 a7e:	7f 93       	push	r23
 a80:	8f 93       	push	r24
 a82:	9f 93       	push	r25
 a84:	af 93       	push	r26
 a86:	bf 93       	push	r27
 a88:	ef 93       	push	r30
 a8a:	ff 93       	push	r31
  InterruptAct = true;
 a8c:	11 e0       	ldi	r17, 0x01	; 1
 a8e:	10 93 55 01 	sts	0x0155, r17
  txState();
 a92:	57 df       	rcall	.-338    	; 0x942 <txState>
  cc2500_Off();
 a94:	a6 db       	rcall	.-2228   	; 0x1e2 <cc2500_Off>
  Heartbeat = true;
 a96:	10 93 60 01 	sts	0x0160, r17
}
 a9a:	ff 91       	pop	r31
 a9c:	ef 91       	pop	r30
 a9e:	bf 91       	pop	r27
 aa0:	af 91       	pop	r26
 aa2:	9f 91       	pop	r25
 aa4:	8f 91       	pop	r24
 aa6:	7f 91       	pop	r23
 aa8:	6f 91       	pop	r22
 aaa:	5f 91       	pop	r21
 aac:	4f 91       	pop	r20
 aae:	3f 91       	pop	r19
 ab0:	2f 91       	pop	r18
 ab2:	1f 91       	pop	r17
 ab4:	0f 90       	pop	r0
 ab6:	0f be       	out	0x3f, r0	; 63
 ab8:	0f 90       	pop	r0
 aba:	1f 90       	pop	r1
 abc:	18 95       	reti

00000abe <readWriteMemory>:
  SET_BIT(UCSR0B, RXCIE0);                      // Interrupt ein
}

void readWriteMemory(void)
{
  if(sendMes.MemoryWord.tar == 0)               // eeprom
 abe:	90 91 54 01 	lds	r25, 0x0154
 ac2:	89 2f       	mov	r24, r25
 ac4:	8c 70       	andi	r24, 0x0C	; 12
 ac6:	a9 f4       	brne	.+42     	; 0xaf2 <readWriteMemory+0x34>
  {
    if(sendMes.MemoryWord.wr)                   // schreiben
 ac8:	90 ff       	sbrs	r25, 0
 aca:	13 c0       	rjmp	.+38     	; 0xaf2 <readWriteMemory+0x34>
    {
      if(sendMes.MemoryWord.size)
 acc:	91 ff       	sbrs	r25, 1
 ace:	0a c0       	rjmp	.+20     	; 0xae4 <readWriteMemory+0x26>
        eeprom_write_word(sendMes.MemoryWord.adr, sendMes.MemoryWord.data);
 ad0:	60 91 4f 01 	lds	r22, 0x014F
 ad4:	70 91 50 01 	lds	r23, 0x0150
 ad8:	80 91 51 01 	lds	r24, 0x0151
 adc:	90 91 52 01 	lds	r25, 0x0152
 ae0:	08 d2       	rcall	.+1040   	; 0xef2 <__eewr_word_m48>
 ae2:	08 95       	ret
      else
        eeprom_write_byte(sendMes.MemoryByte.adr, sendMes.MemoryByte.data);
 ae4:	80 91 51 01 	lds	r24, 0x0151
 ae8:	90 91 52 01 	lds	r25, 0x0152
 aec:	60 91 50 01 	lds	r22, 0x0150
 af0:	f2 d1       	rcall	.+996    	; 0xed6 <__eewr_byte_m48>
 af2:	08 95       	ret

00000af4 <__vector_18>:
//  if(uartRead < sizeof(uartTxBuf))        // Noch Daten da
//    SET_BIT(UCSR0B, UDRIE0);              // USART- Interrupt ein
//}

ISR(USART_RX_vect)
{
 af4:	1f 92       	push	r1
 af6:	0f 92       	push	r0
 af8:	0f b6       	in	r0, 0x3f	; 63
 afa:	0f 92       	push	r0
 afc:	11 24       	eor	r1, r1
 afe:	2f 93       	push	r18
 b00:	3f 93       	push	r19
 b02:	4f 93       	push	r20
 b04:	5f 93       	push	r21
 b06:	6f 93       	push	r22
 b08:	7f 93       	push	r23
 b0a:	8f 93       	push	r24
 b0c:	9f 93       	push	r25
 b0e:	af 93       	push	r26
 b10:	bf 93       	push	r27
 b12:	ef 93       	push	r30
 b14:	ff 93       	push	r31
  static uint8_t chantemp, msbdata, i;
  static enum uart rxstate;

  RES_BIT(UCSR0B, RXCIE0);                      // Interrupt aus
 b16:	80 91 c1 00 	lds	r24, 0x00C1
 b1a:	8f 77       	andi	r24, 0x7F	; 127
 b1c:	80 93 c1 00 	sts	0x00C1, r24
  sei();
 b20:	78 94       	sei
  uint8_t rxbuf = UDR0;
 b22:	30 91 c6 00 	lds	r19, 0x00C6
  OCR0A = TCNT0 + 10;                           // Timeout 1,28 ms
 b26:	86 b5       	in	r24, 0x26	; 38
 b28:	86 5f       	subi	r24, 0xF6	; 246
 b2a:	87 bd       	out	0x27, r24	; 39
  if(TIFR0 & (1 << OCF0A))
 b2c:	a9 9b       	sbis	0x15, 1	; 21
 b2e:	04 c0       	rjmp	.+8      	; 0xb38 <__vector_18+0x44>
  {
    rxstate = WaitToken;
 b30:	10 92 10 01 	sts	0x0110, r1
//    SET_BIT(TIFR0, OCF0A);
    TIFR0 = (1 << OCF0A);
 b34:	82 e0       	ldi	r24, 0x02	; 2
 b36:	85 bb       	out	0x15, r24	; 21
  }
  switch(rxstate)
 b38:	80 91 10 01 	lds	r24, 0x0110
 b3c:	83 30       	cpi	r24, 0x03	; 3
 b3e:	09 f4       	brne	.+2      	; 0xb42 <__vector_18+0x4e>
 b40:	47 c0       	rjmp	.+142    	; 0xbd0 <__vector_18+0xdc>
 b42:	84 30       	cpi	r24, 0x04	; 4
 b44:	30 f4       	brcc	.+12     	; 0xb52 <__vector_18+0x5e>
 b46:	81 30       	cpi	r24, 0x01	; 1
 b48:	39 f1       	breq	.+78     	; 0xb98 <__vector_18+0xa4>
 b4a:	82 30       	cpi	r24, 0x02	; 2
 b4c:	08 f0       	brcs	.+2      	; 0xb50 <__vector_18+0x5c>
 b4e:	3c c0       	rjmp	.+120    	; 0xbc8 <__vector_18+0xd4>
 b50:	0a c0       	rjmp	.+20     	; 0xb66 <__vector_18+0x72>
 b52:	85 30       	cpi	r24, 0x05	; 5
 b54:	09 f4       	brne	.+2      	; 0xb58 <__vector_18+0x64>
 b56:	67 c0       	rjmp	.+206    	; 0xc26 <__vector_18+0x132>
 b58:	85 30       	cpi	r24, 0x05	; 5
 b5a:	08 f4       	brcc	.+2      	; 0xb5e <__vector_18+0x6a>
 b5c:	53 c0       	rjmp	.+166    	; 0xc04 <__vector_18+0x110>
 b5e:	86 30       	cpi	r24, 0x06	; 6
 b60:	09 f0       	breq	.+2      	; 0xb64 <__vector_18+0x70>
 b62:	8b c0       	rjmp	.+278    	; 0xc7a <__vector_18+0x186>
 b64:	81 c0       	rjmp	.+258    	; 0xc68 <__vector_18+0x174>
  {
  case WaitToken:
    if(rxbuf == 'C')
 b66:	33 34       	cpi	r19, 0x43	; 67
 b68:	11 f4       	brne	.+4      	; 0xb6e <__vector_18+0x7a>
      rxstate = ReadChan;
 b6a:	81 e0       	ldi	r24, 0x01	; 1
 b6c:	1f c0       	rjmp	.+62     	; 0xbac <__vector_18+0xb8>
    else if(rxbuf == 'T')
 b6e:	34 35       	cpi	r19, 0x54	; 84
 b70:	11 f4       	brne	.+4      	; 0xb76 <__vector_18+0x82>
      rxstate = ReadCommandMSB;
 b72:	84 e0       	ldi	r24, 0x04	; 4
 b74:	1b c0       	rjmp	.+54     	; 0xbac <__vector_18+0xb8>
    else if((rxbuf == 'F') && checkKey())
 b76:	36 34       	cpi	r19, 0x46	; 70
 b78:	09 f0       	breq	.+2      	; 0xb7c <__vector_18+0x88>
 b7a:	7f c0       	rjmp	.+254    	; 0xc7a <__vector_18+0x186>
 b7c:	37 db       	rcall	.-2450   	; 0x1ec <checkKey>
 b7e:	88 23       	and	r24, r24
 b80:	09 f4       	brne	.+2      	; 0xb84 <__vector_18+0x90>
 b82:	7b c0       	rjmp	.+246    	; 0xc7a <__vector_18+0x186>
    {
      wdt_disable();                // macht auch cli()
 b84:	88 e1       	ldi	r24, 0x18	; 24
 b86:	0f b6       	in	r0, 0x3f	; 63
 b88:	f8 94       	cli
 b8a:	80 93 60 00 	sts	0x0060, r24
 b8e:	10 92 60 00 	sts	0x0060, r1
 b92:	0f be       	out	0x3f, r0	; 63
      flashProgram();
 b94:	11 d2       	rcall	.+1058   	; 0xfb8 <flashProgram>
 b96:	71 c0       	rjmp	.+226    	; 0xc7a <__vector_18+0x186>
    }
    break;
  case ReadChan:
    UDR0 = 'A';
 b98:	81 e4       	ldi	r24, 0x41	; 65
 b9a:	80 93 c6 00 	sts	0x00C6, r24
    if(rxbuf & ~0x7)
 b9e:	83 2f       	mov	r24, r19
 ba0:	88 7f       	andi	r24, 0xF8	; 248
 ba2:	39 f0       	breq	.+14     	; 0xbb2 <__vector_18+0xbe>
    {
      i = 2;
 ba4:	82 e0       	ldi	r24, 0x02	; 2
 ba6:	80 93 11 01 	sts	0x0111, r24
      rxstate = ReadDummy;
 baa:	86 e0       	ldi	r24, 0x06	; 6
 bac:	80 93 10 01 	sts	0x0110, r24
 bb0:	64 c0       	rjmp	.+200    	; 0xc7a <__vector_18+0x186>
    }
    else
    {
      if(rxbuf < chantemp)
 bb2:	80 91 13 01 	lds	r24, 0x0113
 bb6:	38 17       	cp	r19, r24
 bb8:	18 f4       	brcc	.+6      	; 0xbc0 <__vector_18+0xcc>
        state.maxChan = chantemp + 1;           // Bedingt, dass die Kanäle aufsteigend reinkommen
 bba:	8f 5f       	subi	r24, 0xFF	; 255
 bbc:	80 93 46 01 	sts	0x0146, r24
      chantemp = rxbuf;
 bc0:	30 93 13 01 	sts	0x0113, r19
      rxstate = ReadMSB;
 bc4:	82 e0       	ldi	r24, 0x02	; 2
 bc6:	f2 cf       	rjmp	.-28     	; 0xbac <__vector_18+0xb8>
    }
    break;
  case ReadMSB:
    msbdata = rxbuf;
 bc8:	30 93 12 01 	sts	0x0112, r19
    rxstate = ReadLSB;
 bcc:	83 e0       	ldi	r24, 0x03	; 3
 bce:	ee cf       	rjmp	.-36     	; 0xbac <__vector_18+0xb8>
    break;
  case ReadLSB:
    UDR0 = 'A';
 bd0:	81 e4       	ldi	r24, 0x41	; 65
 bd2:	80 93 c6 00 	sts	0x00C6, r24
    output.chan_1us[chantemp] = (msbdata << 8) + rxbuf;
 bd6:	20 91 13 01 	lds	r18, 0x0113
 bda:	e2 2f       	mov	r30, r18
 bdc:	f0 e0       	ldi	r31, 0x00	; 0
 bde:	80 91 12 01 	lds	r24, 0x0112
 be2:	90 e0       	ldi	r25, 0x00	; 0
 be4:	98 2f       	mov	r25, r24
 be6:	88 27       	eor	r24, r24
 be8:	83 0f       	add	r24, r19
 bea:	91 1d       	adc	r25, r1
 bec:	ee 0f       	add	r30, r30
 bee:	ff 1f       	adc	r31, r31
 bf0:	e2 5e       	subi	r30, 0xE2	; 226
 bf2:	fe 4f       	sbci	r31, 0xFE	; 254
 bf4:	91 83       	std	Z+1, r25	; 0x01
 bf6:	80 83       	st	Z, r24
    if(chantemp == 3)
 bf8:	23 30       	cpi	r18, 0x03	; 3
 bfa:	e9 f5       	brne	.+122    	; 0xc76 <__vector_18+0x182>
      output.ppmSync = 4;
 bfc:	84 e0       	ldi	r24, 0x04	; 4
 bfe:	80 93 3e 01 	sts	0x013E, r24
 c02:	39 c0       	rjmp	.+114    	; 0xc76 <__vector_18+0x182>
    rxstate = WaitToken;
    break;
  case ReadCommandMSB:
    if(state.newCommand)        // Altes Kommando ist noch nicht weg
 c04:	80 91 44 01 	lds	r24, 0x0144
 c08:	88 23       	and	r24, r24
 c0a:	11 f0       	breq	.+4      	; 0xc10 <__vector_18+0x11c>
    {
      i = 4;
 c0c:	84 e0       	ldi	r24, 0x04	; 4
 c0e:	cb cf       	rjmp	.-106    	; 0xba6 <__vector_18+0xb2>
      rxstate = ReadDummy;
    }
    else
    {
      sendMes.Uart.b0 = rxbuf;
 c10:	3f 77       	andi	r19, 0x7F	; 127
 c12:	80 91 54 01 	lds	r24, 0x0154
 c16:	80 78       	andi	r24, 0x80	; 128
 c18:	83 2b       	or	r24, r19
 c1a:	80 93 54 01 	sts	0x0154, r24
      i = 0;
 c1e:	10 92 11 01 	sts	0x0111, r1
      rxstate = ReadCommand;
 c22:	85 e0       	ldi	r24, 0x05	; 5
 c24:	c3 cf       	rjmp	.-122    	; 0xbac <__vector_18+0xb8>
    }
    break;
  case ReadCommand:
    if(!(i & 1))
 c26:	90 91 11 01 	lds	r25, 0x0111
 c2a:	e9 2f       	mov	r30, r25
 c2c:	f0 e0       	ldi	r31, 0x00	; 0
 c2e:	90 fd       	sbrc	r25, 0
 c30:	03 c0       	rjmp	.+6      	; 0xc38 <__vector_18+0x144>
      UDR0 = 'A';
 c32:	81 e4       	ldi	r24, 0x41	; 65
 c34:	80 93 c6 00 	sts	0x00C6, r24
    sendMes.Uart.b[i++] = rxbuf;
 c38:	e1 5b       	subi	r30, 0xB1	; 177
 c3a:	fe 4f       	sbci	r31, 0xFE	; 254
 c3c:	30 83       	st	Z, r19
 c3e:	89 2f       	mov	r24, r25
 c40:	8f 5f       	subi	r24, 0xFF	; 255
 c42:	80 93 11 01 	sts	0x0111, r24
    if(i > 4)
 c46:	85 30       	cpi	r24, 0x05	; 5
 c48:	c0 f0       	brcs	.+48     	; 0xc7a <__vector_18+0x186>
    {
      if((sendMes.MemoryWord.type == 5) && (sendMes.MemoryWord.des == 0))
 c4a:	80 91 54 01 	lds	r24, 0x0154
 c4e:	80 77       	andi	r24, 0x70	; 112
 c50:	80 35       	cpi	r24, 0x50	; 80
 c52:	31 f4       	brne	.+12     	; 0xc60 <__vector_18+0x16c>
 c54:	80 91 53 01 	lds	r24, 0x0153
 c58:	88 23       	and	r24, r24
 c5a:	11 f4       	brne	.+4      	; 0xc60 <__vector_18+0x16c>
        readWriteMemory();
 c5c:	30 df       	rcall	.-416    	; 0xabe <readWriteMemory>
 c5e:	0b c0       	rjmp	.+22     	; 0xc76 <__vector_18+0x182>
      else
        state.newCommand = true;
 c60:	81 e0       	ldi	r24, 0x01	; 1
 c62:	80 93 44 01 	sts	0x0144, r24
 c66:	07 c0       	rjmp	.+14     	; 0xc76 <__vector_18+0x182>
      rxstate = WaitToken;
    }
    break;
  case ReadDummy:
    --i;
 c68:	80 91 11 01 	lds	r24, 0x0111
 c6c:	81 50       	subi	r24, 0x01	; 1
 c6e:	80 93 11 01 	sts	0x0111, r24
    if(!i)
 c72:	88 23       	and	r24, r24
 c74:	11 f4       	brne	.+4      	; 0xc7a <__vector_18+0x186>
      rxstate = WaitToken;
 c76:	10 92 10 01 	sts	0x0110, r1
    break;
  }
  cli();
 c7a:	f8 94       	cli
  SET_BIT(UCSR0B, RXCIE0);                      // Interrupt ein
 c7c:	80 91 c1 00 	lds	r24, 0x00C1
 c80:	80 68       	ori	r24, 0x80	; 128
 c82:	80 93 c1 00 	sts	0x00C1, r24
}
 c86:	ff 91       	pop	r31
 c88:	ef 91       	pop	r30
 c8a:	bf 91       	pop	r27
 c8c:	af 91       	pop	r26
 c8e:	9f 91       	pop	r25
 c90:	8f 91       	pop	r24
 c92:	7f 91       	pop	r23
 c94:	6f 91       	pop	r22
 c96:	5f 91       	pop	r21
 c98:	4f 91       	pop	r20
 c9a:	3f 91       	pop	r19
 c9c:	2f 91       	pop	r18
 c9e:	0f 90       	pop	r0
 ca0:	0f be       	out	0x3f, r0	; 63
 ca2:	0f 90       	pop	r0
 ca4:	1f 90       	pop	r1
 ca6:	18 95       	reti

00000ca8 <cc2500ReadReg>:
      cc2500Idle();
}

uint8_t cc2500ReadReg(uint8_t reg)
{
  SPI_MasterTransmit(reg | CC2500_READ_SINGLE);
 ca8:	80 68       	ori	r24, 0x80	; 128
 caa:	60 da       	rcall	.-2880   	; 0x16c <SPI_MasterTransmit>
  return(SPI_MasterTransmit(CC2500_SNOP));
 cac:	8d e3       	ldi	r24, 0x3D	; 61
 cae:	5e da       	rcall	.-2884   	; 0x16c <SPI_MasterTransmit>
}
 cb0:	08 95       	ret

00000cb2 <cc2500WriteReg>:
  SPI_MasterTransmit(reg | CC2500_READ_BURST);
  return(SPI_MasterTransmit(CC2500_SNOP));
}

uint8_t cc2500WriteReg(uint8_t reg, uint8_t c)
{
 cb2:	1f 93       	push	r17
 cb4:	16 2f       	mov	r17, r22
  SPI_MasterTransmit(reg & ~CC2500_READ_SINGLE);
 cb6:	8f 77       	andi	r24, 0x7F	; 127
 cb8:	59 da       	rcall	.-2894   	; 0x16c <SPI_MasterTransmit>
  return(SPI_MasterTransmit(c));
 cba:	81 2f       	mov	r24, r17
 cbc:	57 da       	rcall	.-2898   	; 0x16c <SPI_MasterTransmit>
}
 cbe:	1f 91       	pop	r17
 cc0:	08 95       	ret

00000cc2 <cc2500GetState>:
  SPI_MasterTransmit(str);
}

uint8_t cc2500GetState(void)
{
  return(SPI_MasterTransmit(CC2500_SNOP) & CC2500_STATUS_STATE_BM);
 cc2:	8d e3       	ldi	r24, 0x3D	; 61
 cc4:	53 da       	rcall	.-2906   	; 0x16c <SPI_MasterTransmit>
}
 cc6:	80 77       	andi	r24, 0x70	; 112
 cc8:	08 95       	ret

00000cca <cc2500IdleGetRXB>:
  if((SPI_MasterTransmit(CC2500_SIDLE) & CC2500_STATUS_STATE_BM) != CC2500_STATE_IDLE)
    while(cc2500GetState() != CC2500_STATE_IDLE);   // Status lesen
}

uint8_t cc2500IdleGetRXB(void)
{
 cca:	1f 93       	push	r17
  uint8_t temp;
  if(((temp = SPI_MasterTransmit(CC2500_SIDLE | CC2500_READ_SINGLE)) & CC2500_STATUS_STATE_BM) != CC2500_STATE_IDLE)
 ccc:	86 eb       	ldi	r24, 0xB6	; 182
 cce:	4e da       	rcall	.-2916   	; 0x16c <SPI_MasterTransmit>
 cd0:	18 2f       	mov	r17, r24
 cd2:	80 77       	andi	r24, 0x70	; 112
 cd4:	88 23       	and	r24, r24
 cd6:	11 f0       	breq	.+4      	; 0xcdc <cc2500IdleGetRXB+0x12>
    while(cc2500GetState() != CC2500_STATE_IDLE);   // Status lesen
 cd8:	f4 df       	rcall	.-24     	; 0xcc2 <cc2500GetState>
 cda:	fc cf       	rjmp	.-8      	; 0xcd4 <cc2500IdleGetRXB+0xa>
  return(temp & CC2500_STATUS_FIFO_BYTES_AVAILABLE_BM);
}
 cdc:	81 2f       	mov	r24, r17
 cde:	8f 70       	andi	r24, 0x0F	; 15
 ce0:	1f 91       	pop	r17
 ce2:	08 95       	ret

00000ce4 <cc2500Idle>:
  cc2500_Off();
}

void cc2500Idle(void)
{
  if((SPI_MasterTransmit(CC2500_SIDLE) & CC2500_STATUS_STATE_BM) != CC2500_STATE_IDLE)
 ce4:	86 e3       	ldi	r24, 0x36	; 54
 ce6:	42 da       	rcall	.-2940   	; 0x16c <SPI_MasterTransmit>
 ce8:	80 77       	andi	r24, 0x70	; 112
 cea:	88 23       	and	r24, r24
 cec:	11 f0       	breq	.+4      	; 0xcf2 <cc2500Idle+0xe>
    while(cc2500GetState() != CC2500_STATE_IDLE);   // Status lesen
 cee:	e9 df       	rcall	.-46     	; 0xcc2 <cc2500GetState>
 cf0:	fc cf       	rjmp	.-8      	; 0xcea <cc2500Idle+0x6>
 cf2:	08 95       	ret

00000cf4 <cc2500WriteRegCheckIdle>:
  return(SPI_MasterTransmit(c));
}

void cc2500WriteRegCheckIdle(uint8_t reg, uint8_t c)
{
  if((cc2500WriteReg(reg, c) & CC2500_STATUS_STATE_BM) != CC2500_STATE_IDLE)
 cf4:	de df       	rcall	.-68     	; 0xcb2 <cc2500WriteReg>
 cf6:	80 77       	andi	r24, 0x70	; 112
 cf8:	09 f0       	breq	.+2      	; 0xcfc <cc2500WriteRegCheckIdle+0x8>
      cc2500Idle();
 cfa:	f4 df       	rcall	.-24     	; 0xce4 <cc2500Idle>
 cfc:	08 95       	ret

00000cfe <stayInRx>:
  cc2500WriteRegCheckIdle(CC2500_MCSM1, pgm_read_byte(&cc2500InitValue[CC2500_MCSM1]) & ~0xc);
}

void stayInRx(void)
{
  cc2500WriteRegCheckIdle(CC2500_MCSM1, pgm_read_byte(&cc2500InitValue[CC2500_MCSM1]) | 0xc);
 cfe:	eb e4       	ldi	r30, 0x4B	; 75
 d00:	f0 e0       	ldi	r31, 0x00	; 0
 d02:	e4 91       	lpm	r30, Z+
 d04:	ec 60       	ori	r30, 0x0C	; 12
 d06:	87 e1       	ldi	r24, 0x17	; 23
 d08:	6e 2f       	mov	r22, r30
 d0a:	f4 df       	rcall	.-24     	; 0xcf4 <cc2500WriteRegCheckIdle>
}
 d0c:	08 95       	ret

00000d0e <gotoIdle>:
  cc2500WriteRegCheckIdle(CC2500_FSCAL3, (cc2500ReadReg(CC2500_FSCAL3) & ~0x20) | 0x20);
}

void gotoIdle(void)
{
  cc2500WriteRegCheckIdle(CC2500_MCSM1, pgm_read_byte(&cc2500InitValue[CC2500_MCSM1]) & ~0xc);
 d0e:	eb e4       	ldi	r30, 0x4B	; 75
 d10:	f0 e0       	ldi	r31, 0x00	; 0
 d12:	e4 91       	lpm	r30, Z+
 d14:	e3 7f       	andi	r30, 0xF3	; 243
 d16:	87 e1       	ldi	r24, 0x17	; 23
 d18:	6e 2f       	mov	r22, r30
 d1a:	ec df       	rcall	.-40     	; 0xcf4 <cc2500WriteRegCheckIdle>
}
 d1c:	08 95       	ret

00000d1e <calibrateSlow>:
  cc2500WriteRegCheckIdle(CC2500_FSCAL3, cc2500ReadReg(CC2500_FSCAL3) & ~0x20);
}

void calibrateSlow(void)
{
  cc2500WriteRegCheckIdle(CC2500_FSCAL3, (cc2500ReadReg(CC2500_FSCAL3) & ~0x20) | 0x20);
 d1e:	83 e2       	ldi	r24, 0x23	; 35
 d20:	c3 df       	rcall	.-122    	; 0xca8 <cc2500ReadReg>
 d22:	68 2f       	mov	r22, r24
 d24:	60 62       	ori	r22, 0x20	; 32
 d26:	83 e2       	ldi	r24, 0x23	; 35
 d28:	e5 df       	rcall	.-54     	; 0xcf4 <cc2500WriteRegCheckIdle>
}
 d2a:	08 95       	ret

00000d2c <calibrateFast>:
}

void calibrateFast(void)	                   //Disable charge pump calibration stage when 0
{

  cc2500WriteRegCheckIdle(CC2500_FSCAL3, cc2500ReadReg(CC2500_FSCAL3) & ~0x20);
 d2c:	83 e2       	ldi	r24, 0x23	; 35
 d2e:	bc df       	rcall	.-136    	; 0xca8 <cc2500ReadReg>
 d30:	68 2f       	mov	r22, r24
 d32:	6f 7d       	andi	r22, 0xDF	; 223
 d34:	83 e2       	ldi	r24, 0x23	; 35
 d36:	de df       	rcall	.-68     	; 0xcf4 <cc2500WriteRegCheckIdle>
}
 d38:	08 95       	ret

00000d3a <cc2500CommandStrobe>:
  SMARTRF_SETTING_TEST0         //    TEST0  2e
};

void cc2500CommandStrobe(uint8_t str)
{
  SPI_MasterTransmit(str);
 d3a:	18 da       	rcall	.-3024   	; 0x16c <SPI_MasterTransmit>
}
 d3c:	08 95       	ret

00000d3e <cc2500setPatableMax>:
  while(n--)
    *p++ =cc2500ReadReg(CC2500_RXFIFO);
}

void cc2500setPatableMax(uint8_t power)
{
 d3e:	0f 93       	push	r16
 d40:	1f 93       	push	r17
 d42:	08 2f       	mov	r16, r24
  uint8_t i;
  SPI_MasterTransmit(CC2500_PATABLE | CC2500_WRITE_BURST);
 d44:	8e e7       	ldi	r24, 0x7E	; 126
 d46:	12 da       	rcall	.-3036   	; 0x16c <SPI_MasterTransmit>
 d48:	10 e0       	ldi	r17, 0x00	; 0
  for(i = 0; i < 8; ++i)                 //// 8!!
    SPI_MasterTransmit(power);
 d4a:	80 2f       	mov	r24, r16
 d4c:	0f da       	rcall	.-3042   	; 0x16c <SPI_MasterTransmit>

void cc2500setPatableMax(uint8_t power)
{
  uint8_t i;
  SPI_MasterTransmit(CC2500_PATABLE | CC2500_WRITE_BURST);
  for(i = 0; i < 8; ++i)                 //// 8!!
 d4e:	1f 5f       	subi	r17, 0xFF	; 255
 d50:	18 30       	cpi	r17, 0x08	; 8
 d52:	d9 f7       	brne	.-10     	; 0xd4a <cc2500setPatableMax+0xc>
    SPI_MasterTransmit(power);
  cc2500_Off();
 d54:	46 da       	rcall	.-2932   	; 0x1e2 <cc2500_Off>
}
 d56:	1f 91       	pop	r17
 d58:	0f 91       	pop	r16
 d5a:	08 95       	ret

00000d5c <cc2500WriteFIFOBlock>:
  cc2500_Off();                      // Burstzugriff rücksetzen
  return(true);
}

uint8_t cc2500WriteFIFOBlock(uint8_t *p, uint8_t n)
{
 d5c:	0f 93       	push	r16
 d5e:	1f 93       	push	r17
 d60:	cf 93       	push	r28
 d62:	df 93       	push	r29
 d64:	ec 01       	movw	r28, r24
 d66:	16 2f       	mov	r17, r22
  uint8_t ret = 0;
  SPI_MasterTransmit(CC2500_WRITE_BURST | CC2500_TXFIFO);
 d68:	8f e7       	ldi	r24, 0x7F	; 127
 d6a:	00 da       	rcall	.-3072   	; 0x16c <SPI_MasterTransmit>
 d6c:	00 e0       	ldi	r16, 0x00	; 0
 d6e:	04 c0       	rjmp	.+8      	; 0xd78 <cc2500WriteFIFOBlock+0x1c>
  while(n--)
    ret = SPI_MasterTransmit(*p++);
 d70:	89 91       	ld	r24, Y+
 d72:	fc d9       	rcall	.-3080   	; 0x16c <SPI_MasterTransmit>
 d74:	08 2f       	mov	r16, r24
 d76:	11 50       	subi	r17, 0x01	; 1

uint8_t cc2500WriteFIFOBlock(uint8_t *p, uint8_t n)
{
  uint8_t ret = 0;
  SPI_MasterTransmit(CC2500_WRITE_BURST | CC2500_TXFIFO);
  while(n--)
 d78:	11 23       	and	r17, r17
 d7a:	d1 f7       	brne	.-12     	; 0xd70 <cc2500WriteFIFOBlock+0x14>
    ret = SPI_MasterTransmit(*p++);
  cc2500_Off();                      // Burstzugriff rücksetzen
 d7c:	32 da       	rcall	.-2972   	; 0x1e2 <cc2500_Off>
  return(ret);
}
 d7e:	80 2f       	mov	r24, r16
 d80:	df 91       	pop	r29
 d82:	cf 91       	pop	r28
 d84:	1f 91       	pop	r17
 d86:	0f 91       	pop	r16
 d88:	08 95       	ret

00000d8a <cc2500ReadFIFOBlock>:
  SPI_MasterTransmit(CC2500_READ_SINGLE | CC2500_RXFIFO);
  return(SPI_MasterTransmit(CC2500_SNOP));
}

bool cc2500ReadFIFOBlock(uint8_t *p, uint8_t n)
{
 d8a:	1f 93       	push	r17
 d8c:	cf 93       	push	r28
 d8e:	df 93       	push	r29
 d90:	ec 01       	movw	r28, r24
 d92:	16 2f       	mov	r17, r22
  if(n != (SPI_MasterTransmit(CC2500_RXFIFO | CC2500_READ_BURST) & CC2500_STATUS_FIFO_BYTES_AVAILABLE_BM))
 d94:	8f ef       	ldi	r24, 0xFF	; 255
 d96:	ea d9       	rcall	.-3116   	; 0x16c <SPI_MasterTransmit>
 d98:	21 2f       	mov	r18, r17
 d9a:	30 e0       	ldi	r19, 0x00	; 0
 d9c:	90 e0       	ldi	r25, 0x00	; 0
 d9e:	8f 70       	andi	r24, 0x0F	; 15
 da0:	90 70       	andi	r25, 0x00	; 0
 da2:	28 17       	cp	r18, r24
 da4:	39 07       	cpc	r19, r25
 da6:	39 f0       	breq	.+14     	; 0xdb6 <cc2500ReadFIFOBlock+0x2c>
  {
    cc2500_Off();                      // Burstzugriff rücksetzen
 da8:	1c da       	rcall	.-3016   	; 0x1e2 <cc2500_Off>
 daa:	80 e0       	ldi	r24, 0x00	; 0
 dac:	08 c0       	rjmp	.+16     	; 0xdbe <cc2500ReadFIFOBlock+0x34>
    return(false);
  }
  while(n--)
    *p++ = SPI_MasterTransmit(CC2500_SNOP);
 dae:	8d e3       	ldi	r24, 0x3D	; 61
 db0:	dd d9       	rcall	.-3142   	; 0x16c <SPI_MasterTransmit>
 db2:	89 93       	st	Y+, r24
 db4:	11 50       	subi	r17, 0x01	; 1
  if(n != (SPI_MasterTransmit(CC2500_RXFIFO | CC2500_READ_BURST) & CC2500_STATUS_FIFO_BYTES_AVAILABLE_BM))
  {
    cc2500_Off();                      // Burstzugriff rücksetzen
    return(false);
  }
  while(n--)
 db6:	11 23       	and	r17, r17
 db8:	d1 f7       	brne	.-12     	; 0xdae <cc2500ReadFIFOBlock+0x24>
    *p++ = SPI_MasterTransmit(CC2500_SNOP);
  cc2500_Off();                      // Burstzugriff rücksetzen
 dba:	13 da       	rcall	.-3034   	; 0x1e2 <cc2500_Off>
 dbc:	81 e0       	ldi	r24, 0x01	; 1
  return(true);
}
 dbe:	df 91       	pop	r29
 dc0:	cf 91       	pop	r28
 dc2:	1f 91       	pop	r17
 dc4:	08 95       	ret

00000dc6 <checkcc2500>:
  cc2500_Off();                    // SS wegnehmen wegen Burst
  cc2500setPatableMax(power);
}

bool checkcc2500(void)
{
 dc6:	1f 93       	push	r17
 dc8:	cf 93       	push	r28
 dca:	df 93       	push	r29
 dcc:	88 ee       	ldi	r24, 0xE8	; 232
 dce:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 dd0:	28 ec       	ldi	r18, 0xC8	; 200
 dd2:	30 e0       	ldi	r19, 0x00	; 0
 dd4:	f9 01       	movw	r30, r18
 dd6:	31 97       	sbiw	r30, 0x01	; 1
 dd8:	f1 f7       	brne	.-4      	; 0xdd6 <checkcc2500+0x10>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 dda:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 ddc:	d9 f7       	brne	.-10     	; 0xdd4 <checkcc2500+0xe>
  prog_uint8_t *init = cc2500InitValue;
  bool f = true;

  _delay_ms(100);
  SPI_MasterTransmit(CC2500_IOCFG2 | CC2500_READ_BURST);
 dde:	80 ec       	ldi	r24, 0xC0	; 192
 de0:	c5 d9       	rcall	.-3190   	; 0x16c <SPI_MasterTransmit>
 de2:	c4 e3       	ldi	r28, 0x34	; 52
 de4:	d0 e0       	ldi	r29, 0x00	; 0
 de6:	11 e0       	ldi	r17, 0x01	; 1
  do
  {
    if(SPI_MasterTransmit(0) != pgm_read_byte(init++))
 de8:	80 e0       	ldi	r24, 0x00	; 0
 dea:	c0 d9       	rcall	.-3200   	; 0x16c <SPI_MasterTransmit>
 dec:	fe 01       	movw	r30, r28
 dee:	21 96       	adiw	r28, 0x01	; 1
 df0:	e4 91       	lpm	r30, Z+
 df2:	8e 13       	cpse	r24, r30
 df4:	10 e0       	ldi	r17, 0x00	; 0
      f = false;
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue) - 3));
 df6:	80 e0       	ldi	r24, 0x00	; 0
 df8:	ce 35       	cpi	r28, 0x5E	; 94
 dfa:	d8 07       	cpc	r29, r24
 dfc:	a8 f3       	brcs	.-22     	; 0xde8 <checkcc2500+0x22>
  cc2500_Off();                    // SS wegnehmen wegen Burst
 dfe:	f1 d9       	rcall	.-3102   	; 0x1e2 <cc2500_Off>
  SPI_MasterTransmit(CC2500_TEST2 | CC2500_READ_BURST);
 e00:	8c ee       	ldi	r24, 0xEC	; 236
 e02:	b4 d9       	rcall	.-3224   	; 0x16c <SPI_MasterTransmit>
  do
  {
    if(SPI_MasterTransmit(0) != pgm_read_byte(init++))
 e04:	80 e0       	ldi	r24, 0x00	; 0
 e06:	b2 d9       	rcall	.-3228   	; 0x16c <SPI_MasterTransmit>
 e08:	fe 01       	movw	r30, r28
 e0a:	21 96       	adiw	r28, 0x01	; 1
 e0c:	e4 91       	lpm	r30, Z+
 e0e:	8e 13       	cpse	r24, r30
 e10:	10 e0       	ldi	r17, 0x00	; 0
      f = false;
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue)));
 e12:	80 e0       	ldi	r24, 0x00	; 0
 e14:	c1 36       	cpi	r28, 0x61	; 97
 e16:	d8 07       	cpc	r29, r24
 e18:	a8 f3       	brcs	.-22     	; 0xe04 <checkcc2500+0x3e>
  cc2500_Off();                    // SS wegnehmen wegen Burst
 e1a:	e3 d9       	rcall	.-3130   	; 0x1e2 <cc2500_Off>
  return f;
}
 e1c:	81 2f       	mov	r24, r17
 e1e:	df 91       	pop	r29
 e20:	cf 91       	pop	r28
 e22:	1f 91       	pop	r17
 e24:	08 95       	ret

00000e26 <SPI_MasterInit>:
#include "ORC.h"

void SPI_MasterInit(void)
{
  /* Set MOSI and SCK and SS output, all others input */
  cc2500_Off();
 e26:	dd d9       	rcall	.-3142   	; 0x1e2 <cc2500_Off>
//  SPSR = 0;
  /* Enable SPI, Master, set clock rate fck/4 */
  SPCR = (1<<SPE) | (1<<MSTR); // | (1<<SPR0);       //fck/16
 e28:	80 e5       	ldi	r24, 0x50	; 80
 e2a:	8c bd       	out	0x2c, r24	; 44
}
 e2c:	08 95       	ret

00000e2e <cc2500_Reset>:

void cc2500_Reset(void)
{
  cc2500CommandStrobe(CC2500_SRES);
 e2e:	80 e3       	ldi	r24, 0x30	; 48
 e30:	84 df       	rcall	.-248    	; 0xd3a <cc2500CommandStrobe>
 e32:	01 c0       	rjmp	.+2      	; 0xe36 <cc2500_Reset+0x8>
  while(!(PINB & (1 << INP_B_SPI_MISO))) NOP();       // warten bis high
 e34:	00 00       	nop
 e36:	1c 9b       	sbis	0x03, 4	; 3
 e38:	fd cf       	rjmp	.-6      	; 0xe34 <cc2500_Reset+0x6>
 e3a:	01 c0       	rjmp	.+2      	; 0xe3e <cc2500_Reset+0x10>
  while(PINB & (1 << INP_B_SPI_MISO)) NOP();          // warten bis low
 e3c:	00 00       	nop
 e3e:	1c 99       	sbic	0x03, 4	; 3
 e40:	fd cf       	rjmp	.-6      	; 0xe3c <cc2500_Reset+0xe>
}
 e42:	08 95       	ret

00000e44 <cc2500_Init>:

void cc2500_Init(uint8_t power)
{
 e44:	0f 93       	push	r16
 e46:	1f 93       	push	r17
 e48:	cf 93       	push	r28
 e4a:	df 93       	push	r29
 e4c:	08 2f       	mov	r16, r24
  prog_uint8_t *init = cc2500InitValue;

  SET_BIT(PORTB, OUT_B_SPI_SCK);
 e4e:	2d 9a       	sbi	0x05, 5	; 5
  RES_BIT(PORTB, OUT_B_SPI_MOSI);
 e50:	2b 98       	cbi	0x05, 3	; 5
  RES_BIT(PORTB, OUT_B_SPI_SS);
 e52:	2a 98       	cbi	0x05, 2	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 e54:	1a e6       	ldi	r17, 0x6A	; 106
 e56:	81 2f       	mov	r24, r17
 e58:	8a 95       	dec	r24
 e5a:	f1 f7       	brne	.-4      	; 0xe58 <cc2500_Init+0x14>
  _delay_us(40);                    // warten 40us
  SPI_MasterInit();
 e5c:	e4 df       	rcall	.-56     	; 0xe26 <SPI_MasterInit>
 e5e:	1a 95       	dec	r17
 e60:	f1 f7       	brne	.-4      	; 0xe5e <cc2500_Init+0x1a>
  _delay_us(40);                    // warten 40us
  cc2500_Reset();
 e62:	e5 df       	rcall	.-54     	; 0xe2e <cc2500_Reset>
  cc2500_Off();                         // SS wegnehmen
 e64:	be d9       	rcall	.-3204   	; 0x1e2 <cc2500_Off>

  SPI_MasterTransmit(CC2500_IOCFG2 | CC2500_WRITE_BURST);
 e66:	80 e4       	ldi	r24, 0x40	; 64
 e68:	81 d9       	rcall	.-3326   	; 0x16c <SPI_MasterTransmit>
 e6a:	c4 e3       	ldi	r28, 0x34	; 52
 e6c:	d0 e0       	ldi	r29, 0x00	; 0
 e6e:	fe 01       	movw	r30, r28
  do
  {
    SPI_MasterTransmit(pgm_read_byte(init++));
 e70:	21 96       	adiw	r28, 0x01	; 1
 e72:	e4 91       	lpm	r30, Z+
 e74:	8e 2f       	mov	r24, r30
 e76:	7a d9       	rcall	.-3340   	; 0x16c <SPI_MasterTransmit>
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue) - 3));
 e78:	80 e0       	ldi	r24, 0x00	; 0
 e7a:	ce 35       	cpi	r28, 0x5E	; 94
 e7c:	d8 07       	cpc	r29, r24
 e7e:	b8 f3       	brcs	.-18     	; 0xe6e <cc2500_Init+0x2a>
  cc2500_Off();                    // SS wegnehmen wegen Burst
 e80:	b0 d9       	rcall	.-3232   	; 0x1e2 <cc2500_Off>
  SPI_MasterTransmit(CC2500_TEST2 | CC2500_WRITE_BURST);
 e82:	8c e6       	ldi	r24, 0x6C	; 108
 e84:	73 d9       	rcall	.-3354   	; 0x16c <SPI_MasterTransmit>
 e86:	fe 01       	movw	r30, r28
  do
  {
    SPI_MasterTransmit(pgm_read_byte(init++));
 e88:	21 96       	adiw	r28, 0x01	; 1
 e8a:	e4 91       	lpm	r30, Z+
 e8c:	8e 2f       	mov	r24, r30
 e8e:	6e d9       	rcall	.-3364   	; 0x16c <SPI_MasterTransmit>
  }
  while(init < (cc2500InitValue + sizeof(cc2500InitValue)));
 e90:	80 e0       	ldi	r24, 0x00	; 0
 e92:	c1 36       	cpi	r28, 0x61	; 97
 e94:	d8 07       	cpc	r29, r24
 e96:	b8 f3       	brcs	.-18     	; 0xe86 <cc2500_Init+0x42>
  cc2500_Off();                    // SS wegnehmen wegen Burst
 e98:	a4 d9       	rcall	.-3256   	; 0x1e2 <cc2500_Off>
  cc2500setPatableMax(power);
 e9a:	80 2f       	mov	r24, r16
 e9c:	50 df       	rcall	.-352    	; 0xd3e <cc2500setPatableMax>
}
 e9e:	df 91       	pop	r29
 ea0:	cf 91       	pop	r28
 ea2:	1f 91       	pop	r17
 ea4:	0f 91       	pop	r16
 ea6:	08 95       	ret

00000ea8 <__eerd_block_m48>:
 ea8:	dc 01       	movw	r26, r24
 eaa:	86 2f       	mov	r24, r22

00000eac <__eerd_blraw_m48>:
 eac:	e8 2f       	mov	r30, r24
 eae:	f9 99       	sbic	0x1f, 1	; 31
 eb0:	fe cf       	rjmp	.-4      	; 0xeae <__eerd_blraw_m48+0x2>
 eb2:	12 bc       	out	0x22, r1	; 34
 eb4:	05 c0       	rjmp	.+10     	; 0xec0 <__eerd_blraw_m48+0x14>
 eb6:	e1 bd       	out	0x21, r30	; 33
 eb8:	f8 9a       	sbi	0x1f, 0	; 31
 eba:	e3 95       	inc	r30
 ebc:	00 b4       	in	r0, 0x20	; 32
 ebe:	0d 92       	st	X+, r0
 ec0:	41 50       	subi	r20, 0x01	; 1
 ec2:	c8 f7       	brcc	.-14     	; 0xeb6 <__eerd_blraw_m48+0xa>
 ec4:	08 95       	ret

00000ec6 <__eewr_block_m48>:
 ec6:	dc 01       	movw	r26, r24
 ec8:	86 2f       	mov	r24, r22
 eca:	02 c0       	rjmp	.+4      	; 0xed0 <__eewr_block_m48+0xa>
 ecc:	2d 91       	ld	r18, X+
 ece:	04 d0       	rcall	.+8      	; 0xed8 <__eewr_r18_m48>
 ed0:	41 50       	subi	r20, 0x01	; 1
 ed2:	e0 f7       	brcc	.-8      	; 0xecc <__eewr_block_m48+0x6>
 ed4:	08 95       	ret

00000ed6 <__eewr_byte_m48>:
 ed6:	26 2f       	mov	r18, r22

00000ed8 <__eewr_r18_m48>:
 ed8:	f9 99       	sbic	0x1f, 1	; 31
 eda:	fe cf       	rjmp	.-4      	; 0xed8 <__eewr_r18_m48>
 edc:	1f ba       	out	0x1f, r1	; 31
 ede:	12 bc       	out	0x22, r1	; 34
 ee0:	81 bd       	out	0x21, r24	; 33
 ee2:	20 bd       	out	0x20, r18	; 32
 ee4:	0f b6       	in	r0, 0x3f	; 63
 ee6:	f8 94       	cli
 ee8:	fa 9a       	sbi	0x1f, 2	; 31
 eea:	f9 9a       	sbi	0x1f, 1	; 31
 eec:	0f be       	out	0x3f, r0	; 63
 eee:	01 96       	adiw	r24, 0x01	; 1
 ef0:	08 95       	ret

00000ef2 <__eewr_word_m48>:
 ef2:	f1 df       	rcall	.-30     	; 0xed6 <__eewr_byte_m48>
 ef4:	27 2f       	mov	r18, r23
 ef6:	f0 cf       	rjmp	.-32     	; 0xed8 <__eewr_r18_m48>

00000ef8 <_exit>:
 ef8:	f8 94       	cli

00000efa <__stop_program>:
 efa:	ff cf       	rjmp	.-2      	; 0xefa <__stop_program>

Disassembly of section .bloader:

00000fb8 <flashProgram>:

  .global flashProgram
  .section .bloader, "ax"

flashProgram:
  ldi   ZH, 0
     fb8:	f0 e0       	ldi	r31, 0x00	; 0
  ldi   ZL, 0
     fba:	e0 e0       	ldi	r30, 0x00	; 0

00000fbc <Write_page>:
Write_page:
Wrloop:
  rcall Get_data
     fbc:	18 d0       	rcall	.+48     	; 0xfee <Get_data>
  mov   r0, r1
     fbe:	01 2c       	mov	r0, r1
  rcall Get_data
     fc0:	16 d0       	rcall	.+44     	; 0xfee <Get_data>
  ldi   r20, (1<<SELFPRGEN)
     fc2:	41 e0       	ldi	r20, 0x01	; 1
  rcall Do_spm
     fc4:	0e d0       	rcall	.+28     	; 0xfe2 <Do_spm>
  adiw  ZL, 2
     fc6:	32 96       	adiw	r30, 0x02	; 2

  mov   r24, ZL
     fc8:	8e 2f       	mov	r24, r30
  andi  r24, SPM_PAGESIZE-1            ; Wenn alle Bits 0
     fca:	8f 73       	andi	r24, 0x3F	; 63
  brne  Wrloop
     fcc:	b9 f7       	brne	.-18     	; 0xfbc <Write_page>
  ;
  sbiw  ZL, 1
     fce:	31 97       	sbiw	r30, 0x01	; 1
  ; Page Erase
  ldi   r20, (1<<PGERS) | (1<<SELFPRGEN)
     fd0:	43 e0       	ldi	r20, 0x03	; 3
  rcall Do_spm
     fd2:	07 d0       	rcall	.+14     	; 0xfe2 <Do_spm>
  ; execute Page Write
  ldi   r20, (1<<PGWRT) | (1<<SELFPRGEN)
     fd4:	45 e0       	ldi	r20, 0x05	; 5
  rcall Do_spm
     fd6:	05 d0       	rcall	.+10     	; 0xfe2 <Do_spm>
  adiw  ZL, 1
     fd8:	31 96       	adiw	r30, 0x01	; 1
  mov   r24, ZH
     fda:	8f 2f       	mov	r24, r31
  subi  r24, (63 * SPM_PAGESIZE) / 256
     fdc:	8f 50       	subi	r24, 0x0F	; 15
  brne  Write_page
     fde:	71 f7       	brne	.-36     	; 0xfbc <Write_page>

00000fe0 <Return>:
Return:
  rjmp  __vector_default
     fe0:	0f c8       	rjmp	.-4066   	; 0x0 <__heap_end>

00000fe2 <Do_spm>:
Do_spm:
; check for previous SPM complete
Wait_spm:
  in    r16, _SFR_IO_ADDR(SPMCSR)
     fe2:	07 b7       	in	r16, 0x37	; 55
  sbrc  r16, SELFPRGEN
     fe4:	00 fd       	sbrc	r16, 0
  rjmp  Wait_spm
     fe6:	fd cf       	rjmp	.-6      	; 0xfe2 <Do_spm>
; SPM timed sequence
  out   _SFR_IO_ADDR(SPMCSR), r20
     fe8:	47 bf       	out	0x37, r20	; 55
  spm
     fea:	e8 95       	spm
  ret
     fec:	08 95       	ret

00000fee <Get_data>:
Get_data:
  lds   r1, UCSR0A
     fee:	10 90 c0 00 	lds	r1, 0x00C0
  sbrs  r1, 7
     ff2:	17 fe       	sbrs	r1, 7
  rjmp  .-8
     ff4:	fc cf       	rjmp	.-8      	; 0xfee <Get_data>
  lds   r1, UDR0
     ff6:	10 90 c6 00 	lds	r1, 0x00C6
  sts   UDR0, ZL
     ffa:	e0 93 c6 00 	sts	0x00C6, r30
  ret
     ffe:	08 95       	ret
